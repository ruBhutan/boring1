
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Tour
 * 
 */
export type Tour = $Result.DefaultSelection<Prisma.$TourPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Guide
 * 
 */
export type Guide = $Result.DefaultSelection<Prisma.$GuidePayload>
/**
 * Model Itinerary
 * 
 */
export type Itinerary = $Result.DefaultSelection<Prisma.$ItineraryPayload>
/**
 * Model ItineraryDay
 * 
 */
export type ItineraryDay = $Result.DefaultSelection<Prisma.$ItineraryDayPayload>
/**
 * Model CustomTourRequest
 * 
 */
export type CustomTourRequest = $Result.DefaultSelection<Prisma.$CustomTourRequestPayload>
/**
 * Model TourOperator
 * 
 */
export type TourOperator = $Result.DefaultSelection<Prisma.$TourOperatorPayload>
/**
 * Model Festival
 * 
 */
export type Festival = $Result.DefaultSelection<Prisma.$FestivalPayload>
/**
 * Model FestivalBooking
 * 
 */
export type FestivalBooking = $Result.DefaultSelection<Prisma.$FestivalBookingPayload>
/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model HotelRoom
 * 
 */
export type HotelRoom = $Result.DefaultSelection<Prisma.$HotelRoomPayload>
/**
 * Model HotelBooking
 * 
 */
export type HotelBooking = $Result.DefaultSelection<Prisma.$HotelBookingPayload>
/**
 * Model UserAccount
 * 
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model UserFeedback
 * 
 */
export type UserFeedback = $Result.DefaultSelection<Prisma.$UserFeedbackPayload>
/**
 * Model TourCategory
 * 
 */
export type TourCategory = $Result.DefaultSelection<Prisma.$TourCategoryPayload>
/**
 * Model HotelCategory
 * 
 */
export type HotelCategory = $Result.DefaultSelection<Prisma.$HotelCategoryPayload>
/**
 * Model TravelActivity
 * 
 */
export type TravelActivity = $Result.DefaultSelection<Prisma.$TravelActivityPayload>
/**
 * Model TravelInterest
 * 
 */
export type TravelInterest = $Result.DefaultSelection<Prisma.$TravelInterestPayload>
/**
 * Model FlightRoute
 * 
 */
export type FlightRoute = $Result.DefaultSelection<Prisma.$FlightRoutePayload>
/**
 * Model AccommodationType
 * 
 */
export type AccommodationType = $Result.DefaultSelection<Prisma.$AccommodationTypePayload>
/**
 * Model DifficultyLevel
 * 
 */
export type DifficultyLevel = $Result.DefaultSelection<Prisma.$DifficultyLevelPayload>
/**
 * Model SeasonalPeriod
 * 
 */
export type SeasonalPeriod = $Result.DefaultSelection<Prisma.$SeasonalPeriodPayload>
/**
 * Model BookingActivity
 * 
 */
export type BookingActivity = $Result.DefaultSelection<Prisma.$BookingActivityPayload>
/**
 * Model UserInterest
 * 
 */
export type UserInterest = $Result.DefaultSelection<Prisma.$UserInterestPayload>
/**
 * Model CustomTourInterest
 * 
 */
export type CustomTourInterest = $Result.DefaultSelection<Prisma.$CustomTourInterestPayload>
/**
 * Model FlightBooking
 * 
 */
export type FlightBooking = $Result.DefaultSelection<Prisma.$FlightBookingPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model TourActivityJunction
 * 
 */
export type TourActivityJunction = $Result.DefaultSelection<Prisma.$TourActivityJunctionPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model Flight
 * 
 */
export type Flight = $Result.DefaultSelection<Prisma.$FlightPayload>
/**
 * Model TourFestival
 * 
 */
export type TourFestival = $Result.DefaultSelection<Prisma.$TourFestivalPayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.guide`: Exposes CRUD operations for the **Guide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guides
    * const guides = await prisma.guide.findMany()
    * ```
    */
  get guide(): Prisma.GuideDelegate<ExtArgs>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<ExtArgs>;

  /**
   * `prisma.itineraryDay`: Exposes CRUD operations for the **ItineraryDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItineraryDays
    * const itineraryDays = await prisma.itineraryDay.findMany()
    * ```
    */
  get itineraryDay(): Prisma.ItineraryDayDelegate<ExtArgs>;

  /**
   * `prisma.customTourRequest`: Exposes CRUD operations for the **CustomTourRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomTourRequests
    * const customTourRequests = await prisma.customTourRequest.findMany()
    * ```
    */
  get customTourRequest(): Prisma.CustomTourRequestDelegate<ExtArgs>;

  /**
   * `prisma.tourOperator`: Exposes CRUD operations for the **TourOperator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourOperators
    * const tourOperators = await prisma.tourOperator.findMany()
    * ```
    */
  get tourOperator(): Prisma.TourOperatorDelegate<ExtArgs>;

  /**
   * `prisma.festival`: Exposes CRUD operations for the **Festival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Festivals
    * const festivals = await prisma.festival.findMany()
    * ```
    */
  get festival(): Prisma.FestivalDelegate<ExtArgs>;

  /**
   * `prisma.festivalBooking`: Exposes CRUD operations for the **FestivalBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FestivalBookings
    * const festivalBookings = await prisma.festivalBooking.findMany()
    * ```
    */
  get festivalBooking(): Prisma.FestivalBookingDelegate<ExtArgs>;

  /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs>;

  /**
   * `prisma.hotelRoom`: Exposes CRUD operations for the **HotelRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelRooms
    * const hotelRooms = await prisma.hotelRoom.findMany()
    * ```
    */
  get hotelRoom(): Prisma.HotelRoomDelegate<ExtArgs>;

  /**
   * `prisma.hotelBooking`: Exposes CRUD operations for the **HotelBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelBookings
    * const hotelBookings = await prisma.hotelBooking.findMany()
    * ```
    */
  get hotelBooking(): Prisma.HotelBookingDelegate<ExtArgs>;

  /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs>;

  /**
   * `prisma.userFeedback`: Exposes CRUD operations for the **UserFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeedbacks
    * const userFeedbacks = await prisma.userFeedback.findMany()
    * ```
    */
  get userFeedback(): Prisma.UserFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.tourCategory`: Exposes CRUD operations for the **TourCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourCategories
    * const tourCategories = await prisma.tourCategory.findMany()
    * ```
    */
  get tourCategory(): Prisma.TourCategoryDelegate<ExtArgs>;

  /**
   * `prisma.hotelCategory`: Exposes CRUD operations for the **HotelCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelCategories
    * const hotelCategories = await prisma.hotelCategory.findMany()
    * ```
    */
  get hotelCategory(): Prisma.HotelCategoryDelegate<ExtArgs>;

  /**
   * `prisma.travelActivity`: Exposes CRUD operations for the **TravelActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TravelActivities
    * const travelActivities = await prisma.travelActivity.findMany()
    * ```
    */
  get travelActivity(): Prisma.TravelActivityDelegate<ExtArgs>;

  /**
   * `prisma.travelInterest`: Exposes CRUD operations for the **TravelInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TravelInterests
    * const travelInterests = await prisma.travelInterest.findMany()
    * ```
    */
  get travelInterest(): Prisma.TravelInterestDelegate<ExtArgs>;

  /**
   * `prisma.flightRoute`: Exposes CRUD operations for the **FlightRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlightRoutes
    * const flightRoutes = await prisma.flightRoute.findMany()
    * ```
    */
  get flightRoute(): Prisma.FlightRouteDelegate<ExtArgs>;

  /**
   * `prisma.accommodationType`: Exposes CRUD operations for the **AccommodationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccommodationTypes
    * const accommodationTypes = await prisma.accommodationType.findMany()
    * ```
    */
  get accommodationType(): Prisma.AccommodationTypeDelegate<ExtArgs>;

  /**
   * `prisma.difficultyLevel`: Exposes CRUD operations for the **DifficultyLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DifficultyLevels
    * const difficultyLevels = await prisma.difficultyLevel.findMany()
    * ```
    */
  get difficultyLevel(): Prisma.DifficultyLevelDelegate<ExtArgs>;

  /**
   * `prisma.seasonalPeriod`: Exposes CRUD operations for the **SeasonalPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeasonalPeriods
    * const seasonalPeriods = await prisma.seasonalPeriod.findMany()
    * ```
    */
  get seasonalPeriod(): Prisma.SeasonalPeriodDelegate<ExtArgs>;

  /**
   * `prisma.bookingActivity`: Exposes CRUD operations for the **BookingActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingActivities
    * const bookingActivities = await prisma.bookingActivity.findMany()
    * ```
    */
  get bookingActivity(): Prisma.BookingActivityDelegate<ExtArgs>;

  /**
   * `prisma.userInterest`: Exposes CRUD operations for the **UserInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInterests
    * const userInterests = await prisma.userInterest.findMany()
    * ```
    */
  get userInterest(): Prisma.UserInterestDelegate<ExtArgs>;

  /**
   * `prisma.customTourInterest`: Exposes CRUD operations for the **CustomTourInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomTourInterests
    * const customTourInterests = await prisma.customTourInterest.findMany()
    * ```
    */
  get customTourInterest(): Prisma.CustomTourInterestDelegate<ExtArgs>;

  /**
   * `prisma.flightBooking`: Exposes CRUD operations for the **FlightBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlightBookings
    * const flightBookings = await prisma.flightBooking.findMany()
    * ```
    */
  get flightBooking(): Prisma.FlightBookingDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.tourActivityJunction`: Exposes CRUD operations for the **TourActivityJunction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourActivityJunctions
    * const tourActivityJunctions = await prisma.tourActivityJunction.findMany()
    * ```
    */
  get tourActivityJunction(): Prisma.TourActivityJunctionDelegate<ExtArgs>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs>;

  /**
   * `prisma.flight`: Exposes CRUD operations for the **Flight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flights
    * const flights = await prisma.flight.findMany()
    * ```
    */
  get flight(): Prisma.FlightDelegate<ExtArgs>;

  /**
   * `prisma.tourFestival`: Exposes CRUD operations for the **TourFestival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourFestivals
    * const tourFestivals = await prisma.tourFestival.findMany()
    * ```
    */
  get tourFestival(): Prisma.TourFestivalDelegate<ExtArgs>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Tour: 'Tour',
    Booking: 'Booking',
    Inquiry: 'Inquiry',
    Testimonial: 'Testimonial',
    BlogPost: 'BlogPost',
    Guide: 'Guide',
    Itinerary: 'Itinerary',
    ItineraryDay: 'ItineraryDay',
    CustomTourRequest: 'CustomTourRequest',
    TourOperator: 'TourOperator',
    Festival: 'Festival',
    FestivalBooking: 'FestivalBooking',
    Hotel: 'Hotel',
    HotelRoom: 'HotelRoom',
    HotelBooking: 'HotelBooking',
    UserAccount: 'UserAccount',
    UserFeedback: 'UserFeedback',
    TourCategory: 'TourCategory',
    HotelCategory: 'HotelCategory',
    TravelActivity: 'TravelActivity',
    TravelInterest: 'TravelInterest',
    FlightRoute: 'FlightRoute',
    AccommodationType: 'AccommodationType',
    DifficultyLevel: 'DifficultyLevel',
    SeasonalPeriod: 'SeasonalPeriod',
    BookingActivity: 'BookingActivity',
    UserInterest: 'UserInterest',
    CustomTourInterest: 'CustomTourInterest',
    FlightBooking: 'FlightBooking',
    Activity: 'Activity',
    TourActivityJunction: 'TourActivityJunction',
    Interest: 'Interest',
    Flight: 'Flight',
    TourFestival: 'TourFestival',
    ChatSession: 'ChatSession',
    ChatMessage: 'ChatMessage',
    Notification: 'Notification',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "tour" | "booking" | "inquiry" | "testimonial" | "blogPost" | "guide" | "itinerary" | "itineraryDay" | "customTourRequest" | "tourOperator" | "festival" | "festivalBooking" | "hotel" | "hotelRoom" | "hotelBooking" | "userAccount" | "userFeedback" | "tourCategory" | "hotelCategory" | "travelActivity" | "travelInterest" | "flightRoute" | "accommodationType" | "difficultyLevel" | "seasonalPeriod" | "bookingActivity" | "userInterest" | "customTourInterest" | "flightBooking" | "activity" | "tourActivityJunction" | "interest" | "flight" | "tourFestival" | "chatSession" | "chatMessage" | "notification" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Tour: {
        payload: Prisma.$TourPayload<ExtArgs>
        fields: Prisma.TourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findFirst: {
            args: Prisma.TourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findMany: {
            args: Prisma.TourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          create: {
            args: Prisma.TourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          createMany: {
            args: Prisma.TourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          delete: {
            args: Prisma.TourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          update: {
            args: Prisma.TourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          deleteMany: {
            args: Prisma.TourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.TourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Guide: {
        payload: Prisma.$GuidePayload<ExtArgs>
        fields: Prisma.GuideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findFirst: {
            args: Prisma.GuideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findMany: {
            args: Prisma.GuideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          create: {
            args: Prisma.GuideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          createMany: {
            args: Prisma.GuideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          delete: {
            args: Prisma.GuideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          update: {
            args: Prisma.GuideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          deleteMany: {
            args: Prisma.GuideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          aggregate: {
            args: Prisma.GuideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuide>
          }
          groupBy: {
            args: Prisma.GuideGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideCountArgs<ExtArgs>
            result: $Utils.Optional<GuideCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: Prisma.$ItineraryPayload<ExtArgs>
        fields: Prisma.ItineraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      ItineraryDay: {
        payload: Prisma.$ItineraryDayPayload<ExtArgs>
        fields: Prisma.ItineraryDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          findFirst: {
            args: Prisma.ItineraryDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          findMany: {
            args: Prisma.ItineraryDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>[]
          }
          create: {
            args: Prisma.ItineraryDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          createMany: {
            args: Prisma.ItineraryDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItineraryDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>[]
          }
          delete: {
            args: Prisma.ItineraryDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          update: {
            args: Prisma.ItineraryDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItineraryDayPayload>
          }
          aggregate: {
            args: Prisma.ItineraryDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItineraryDay>
          }
          groupBy: {
            args: Prisma.ItineraryDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItineraryDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryDayCountArgs<ExtArgs>
            result: $Utils.Optional<ItineraryDayCountAggregateOutputType> | number
          }
        }
      }
      CustomTourRequest: {
        payload: Prisma.$CustomTourRequestPayload<ExtArgs>
        fields: Prisma.CustomTourRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomTourRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomTourRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          findFirst: {
            args: Prisma.CustomTourRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomTourRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          findMany: {
            args: Prisma.CustomTourRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>[]
          }
          create: {
            args: Prisma.CustomTourRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          createMany: {
            args: Prisma.CustomTourRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomTourRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>[]
          }
          delete: {
            args: Prisma.CustomTourRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          update: {
            args: Prisma.CustomTourRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          deleteMany: {
            args: Prisma.CustomTourRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomTourRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomTourRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourRequestPayload>
          }
          aggregate: {
            args: Prisma.CustomTourRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomTourRequest>
          }
          groupBy: {
            args: Prisma.CustomTourRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomTourRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomTourRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CustomTourRequestCountAggregateOutputType> | number
          }
        }
      }
      TourOperator: {
        payload: Prisma.$TourOperatorPayload<ExtArgs>
        fields: Prisma.TourOperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourOperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourOperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          findFirst: {
            args: Prisma.TourOperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourOperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          findMany: {
            args: Prisma.TourOperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>[]
          }
          create: {
            args: Prisma.TourOperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          createMany: {
            args: Prisma.TourOperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourOperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>[]
          }
          delete: {
            args: Prisma.TourOperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          update: {
            args: Prisma.TourOperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          deleteMany: {
            args: Prisma.TourOperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourOperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourOperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourOperatorPayload>
          }
          aggregate: {
            args: Prisma.TourOperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourOperator>
          }
          groupBy: {
            args: Prisma.TourOperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourOperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourOperatorCountArgs<ExtArgs>
            result: $Utils.Optional<TourOperatorCountAggregateOutputType> | number
          }
        }
      }
      Festival: {
        payload: Prisma.$FestivalPayload<ExtArgs>
        fields: Prisma.FestivalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FestivalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FestivalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          findFirst: {
            args: Prisma.FestivalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FestivalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          findMany: {
            args: Prisma.FestivalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>[]
          }
          create: {
            args: Prisma.FestivalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          createMany: {
            args: Prisma.FestivalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FestivalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>[]
          }
          delete: {
            args: Prisma.FestivalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          update: {
            args: Prisma.FestivalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          deleteMany: {
            args: Prisma.FestivalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FestivalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FestivalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalPayload>
          }
          aggregate: {
            args: Prisma.FestivalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFestival>
          }
          groupBy: {
            args: Prisma.FestivalGroupByArgs<ExtArgs>
            result: $Utils.Optional<FestivalGroupByOutputType>[]
          }
          count: {
            args: Prisma.FestivalCountArgs<ExtArgs>
            result: $Utils.Optional<FestivalCountAggregateOutputType> | number
          }
        }
      }
      FestivalBooking: {
        payload: Prisma.$FestivalBookingPayload<ExtArgs>
        fields: Prisma.FestivalBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FestivalBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FestivalBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          findFirst: {
            args: Prisma.FestivalBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FestivalBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          findMany: {
            args: Prisma.FestivalBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>[]
          }
          create: {
            args: Prisma.FestivalBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          createMany: {
            args: Prisma.FestivalBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FestivalBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>[]
          }
          delete: {
            args: Prisma.FestivalBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          update: {
            args: Prisma.FestivalBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          deleteMany: {
            args: Prisma.FestivalBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FestivalBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FestivalBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FestivalBookingPayload>
          }
          aggregate: {
            args: Prisma.FestivalBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFestivalBooking>
          }
          groupBy: {
            args: Prisma.FestivalBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FestivalBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FestivalBookingCountArgs<ExtArgs>
            result: $Utils.Optional<FestivalBookingCountAggregateOutputType> | number
          }
        }
      }
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      HotelRoom: {
        payload: Prisma.$HotelRoomPayload<ExtArgs>
        fields: Prisma.HotelRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          findFirst: {
            args: Prisma.HotelRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          findMany: {
            args: Prisma.HotelRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>[]
          }
          create: {
            args: Prisma.HotelRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          createMany: {
            args: Prisma.HotelRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>[]
          }
          delete: {
            args: Prisma.HotelRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          update: {
            args: Prisma.HotelRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          deleteMany: {
            args: Prisma.HotelRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelRoomPayload>
          }
          aggregate: {
            args: Prisma.HotelRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelRoom>
          }
          groupBy: {
            args: Prisma.HotelRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelRoomCountArgs<ExtArgs>
            result: $Utils.Optional<HotelRoomCountAggregateOutputType> | number
          }
        }
      }
      HotelBooking: {
        payload: Prisma.$HotelBookingPayload<ExtArgs>
        fields: Prisma.HotelBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findFirst: {
            args: Prisma.HotelBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          findMany: {
            args: Prisma.HotelBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          create: {
            args: Prisma.HotelBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          createMany: {
            args: Prisma.HotelBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>[]
          }
          delete: {
            args: Prisma.HotelBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          update: {
            args: Prisma.HotelBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          deleteMany: {
            args: Prisma.HotelBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelBookingPayload>
          }
          aggregate: {
            args: Prisma.HotelBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelBooking>
          }
          groupBy: {
            args: Prisma.HotelBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelBookingCountArgs<ExtArgs>
            result: $Utils.Optional<HotelBookingCountAggregateOutputType> | number
          }
        }
      }
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      UserFeedback: {
        payload: Prisma.$UserFeedbackPayload<ExtArgs>
        fields: Prisma.UserFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findFirst: {
            args: Prisma.UserFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          findMany: {
            args: Prisma.UserFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          create: {
            args: Prisma.UserFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          createMany: {
            args: Prisma.UserFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>[]
          }
          delete: {
            args: Prisma.UserFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          update: {
            args: Prisma.UserFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.UserFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeedbackPayload>
          }
          aggregate: {
            args: Prisma.UserFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeedback>
          }
          groupBy: {
            args: Prisma.UserFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeedbackCountAggregateOutputType> | number
          }
        }
      }
      TourCategory: {
        payload: Prisma.$TourCategoryPayload<ExtArgs>
        fields: Prisma.TourCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          findFirst: {
            args: Prisma.TourCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          findMany: {
            args: Prisma.TourCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>[]
          }
          create: {
            args: Prisma.TourCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          createMany: {
            args: Prisma.TourCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>[]
          }
          delete: {
            args: Prisma.TourCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          update: {
            args: Prisma.TourCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TourCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourCategoryPayload>
          }
          aggregate: {
            args: Prisma.TourCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourCategory>
          }
          groupBy: {
            args: Prisma.TourCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TourCategoryCountAggregateOutputType> | number
          }
        }
      }
      HotelCategory: {
        payload: Prisma.$HotelCategoryPayload<ExtArgs>
        fields: Prisma.HotelCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          findFirst: {
            args: Prisma.HotelCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          findMany: {
            args: Prisma.HotelCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>[]
          }
          create: {
            args: Prisma.HotelCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          createMany: {
            args: Prisma.HotelCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>[]
          }
          delete: {
            args: Prisma.HotelCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          update: {
            args: Prisma.HotelCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          deleteMany: {
            args: Prisma.HotelCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelCategoryPayload>
          }
          aggregate: {
            args: Prisma.HotelCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelCategory>
          }
          groupBy: {
            args: Prisma.HotelCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCategoryCountAggregateOutputType> | number
          }
        }
      }
      TravelActivity: {
        payload: Prisma.$TravelActivityPayload<ExtArgs>
        fields: Prisma.TravelActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TravelActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TravelActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          findFirst: {
            args: Prisma.TravelActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TravelActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          findMany: {
            args: Prisma.TravelActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>[]
          }
          create: {
            args: Prisma.TravelActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          createMany: {
            args: Prisma.TravelActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TravelActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>[]
          }
          delete: {
            args: Prisma.TravelActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          update: {
            args: Prisma.TravelActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          deleteMany: {
            args: Prisma.TravelActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TravelActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TravelActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelActivityPayload>
          }
          aggregate: {
            args: Prisma.TravelActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTravelActivity>
          }
          groupBy: {
            args: Prisma.TravelActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<TravelActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.TravelActivityCountArgs<ExtArgs>
            result: $Utils.Optional<TravelActivityCountAggregateOutputType> | number
          }
        }
      }
      TravelInterest: {
        payload: Prisma.$TravelInterestPayload<ExtArgs>
        fields: Prisma.TravelInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TravelInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TravelInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          findFirst: {
            args: Prisma.TravelInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TravelInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          findMany: {
            args: Prisma.TravelInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>[]
          }
          create: {
            args: Prisma.TravelInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          createMany: {
            args: Prisma.TravelInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TravelInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>[]
          }
          delete: {
            args: Prisma.TravelInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          update: {
            args: Prisma.TravelInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          deleteMany: {
            args: Prisma.TravelInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TravelInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TravelInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelInterestPayload>
          }
          aggregate: {
            args: Prisma.TravelInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTravelInterest>
          }
          groupBy: {
            args: Prisma.TravelInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TravelInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TravelInterestCountArgs<ExtArgs>
            result: $Utils.Optional<TravelInterestCountAggregateOutputType> | number
          }
        }
      }
      FlightRoute: {
        payload: Prisma.$FlightRoutePayload<ExtArgs>
        fields: Prisma.FlightRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          findFirst: {
            args: Prisma.FlightRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          findMany: {
            args: Prisma.FlightRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>[]
          }
          create: {
            args: Prisma.FlightRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          createMany: {
            args: Prisma.FlightRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>[]
          }
          delete: {
            args: Prisma.FlightRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          update: {
            args: Prisma.FlightRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          deleteMany: {
            args: Prisma.FlightRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlightRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRoutePayload>
          }
          aggregate: {
            args: Prisma.FlightRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlightRoute>
          }
          groupBy: {
            args: Prisma.FlightRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightRouteCountArgs<ExtArgs>
            result: $Utils.Optional<FlightRouteCountAggregateOutputType> | number
          }
        }
      }
      AccommodationType: {
        payload: Prisma.$AccommodationTypePayload<ExtArgs>
        fields: Prisma.AccommodationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          findFirst: {
            args: Prisma.AccommodationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          findMany: {
            args: Prisma.AccommodationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>[]
          }
          create: {
            args: Prisma.AccommodationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          createMany: {
            args: Prisma.AccommodationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>[]
          }
          delete: {
            args: Prisma.AccommodationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          update: {
            args: Prisma.AccommodationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          deleteMany: {
            args: Prisma.AccommodationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccommodationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationTypePayload>
          }
          aggregate: {
            args: Prisma.AccommodationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodationType>
          }
          groupBy: {
            args: Prisma.AccommodationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationTypeCountAggregateOutputType> | number
          }
        }
      }
      DifficultyLevel: {
        payload: Prisma.$DifficultyLevelPayload<ExtArgs>
        fields: Prisma.DifficultyLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DifficultyLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DifficultyLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          findFirst: {
            args: Prisma.DifficultyLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DifficultyLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          findMany: {
            args: Prisma.DifficultyLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>[]
          }
          create: {
            args: Prisma.DifficultyLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          createMany: {
            args: Prisma.DifficultyLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DifficultyLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>[]
          }
          delete: {
            args: Prisma.DifficultyLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          update: {
            args: Prisma.DifficultyLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          deleteMany: {
            args: Prisma.DifficultyLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DifficultyLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DifficultyLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifficultyLevelPayload>
          }
          aggregate: {
            args: Prisma.DifficultyLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDifficultyLevel>
          }
          groupBy: {
            args: Prisma.DifficultyLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<DifficultyLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.DifficultyLevelCountArgs<ExtArgs>
            result: $Utils.Optional<DifficultyLevelCountAggregateOutputType> | number
          }
        }
      }
      SeasonalPeriod: {
        payload: Prisma.$SeasonalPeriodPayload<ExtArgs>
        fields: Prisma.SeasonalPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonalPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonalPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          findFirst: {
            args: Prisma.SeasonalPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonalPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          findMany: {
            args: Prisma.SeasonalPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>[]
          }
          create: {
            args: Prisma.SeasonalPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          createMany: {
            args: Prisma.SeasonalPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonalPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>[]
          }
          delete: {
            args: Prisma.SeasonalPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          update: {
            args: Prisma.SeasonalPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          deleteMany: {
            args: Prisma.SeasonalPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonalPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeasonalPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonalPeriodPayload>
          }
          aggregate: {
            args: Prisma.SeasonalPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeasonalPeriod>
          }
          groupBy: {
            args: Prisma.SeasonalPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonalPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonalPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonalPeriodCountAggregateOutputType> | number
          }
        }
      }
      BookingActivity: {
        payload: Prisma.$BookingActivityPayload<ExtArgs>
        fields: Prisma.BookingActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          findFirst: {
            args: Prisma.BookingActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          findMany: {
            args: Prisma.BookingActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>[]
          }
          create: {
            args: Prisma.BookingActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          createMany: {
            args: Prisma.BookingActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>[]
          }
          delete: {
            args: Prisma.BookingActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          update: {
            args: Prisma.BookingActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          deleteMany: {
            args: Prisma.BookingActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingActivityPayload>
          }
          aggregate: {
            args: Prisma.BookingActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingActivity>
          }
          groupBy: {
            args: Prisma.BookingActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingActivityCountArgs<ExtArgs>
            result: $Utils.Optional<BookingActivityCountAggregateOutputType> | number
          }
        }
      }
      UserInterest: {
        payload: Prisma.$UserInterestPayload<ExtArgs>
        fields: Prisma.UserInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          findFirst: {
            args: Prisma.UserInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          findMany: {
            args: Prisma.UserInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>[]
          }
          create: {
            args: Prisma.UserInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          createMany: {
            args: Prisma.UserInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>[]
          }
          delete: {
            args: Prisma.UserInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          update: {
            args: Prisma.UserInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          deleteMany: {
            args: Prisma.UserInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInterestPayload>
          }
          aggregate: {
            args: Prisma.UserInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInterest>
          }
          groupBy: {
            args: Prisma.UserInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInterestCountArgs<ExtArgs>
            result: $Utils.Optional<UserInterestCountAggregateOutputType> | number
          }
        }
      }
      CustomTourInterest: {
        payload: Prisma.$CustomTourInterestPayload<ExtArgs>
        fields: Prisma.CustomTourInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomTourInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomTourInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          findFirst: {
            args: Prisma.CustomTourInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomTourInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          findMany: {
            args: Prisma.CustomTourInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>[]
          }
          create: {
            args: Prisma.CustomTourInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          createMany: {
            args: Prisma.CustomTourInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomTourInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>[]
          }
          delete: {
            args: Prisma.CustomTourInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          update: {
            args: Prisma.CustomTourInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          deleteMany: {
            args: Prisma.CustomTourInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomTourInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomTourInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomTourInterestPayload>
          }
          aggregate: {
            args: Prisma.CustomTourInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomTourInterest>
          }
          groupBy: {
            args: Prisma.CustomTourInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomTourInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomTourInterestCountArgs<ExtArgs>
            result: $Utils.Optional<CustomTourInterestCountAggregateOutputType> | number
          }
        }
      }
      FlightBooking: {
        payload: Prisma.$FlightBookingPayload<ExtArgs>
        fields: Prisma.FlightBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          findFirst: {
            args: Prisma.FlightBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          findMany: {
            args: Prisma.FlightBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>[]
          }
          create: {
            args: Prisma.FlightBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          createMany: {
            args: Prisma.FlightBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>[]
          }
          delete: {
            args: Prisma.FlightBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          update: {
            args: Prisma.FlightBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          deleteMany: {
            args: Prisma.FlightBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlightBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightBookingPayload>
          }
          aggregate: {
            args: Prisma.FlightBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlightBooking>
          }
          groupBy: {
            args: Prisma.FlightBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightBookingCountArgs<ExtArgs>
            result: $Utils.Optional<FlightBookingCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      TourActivityJunction: {
        payload: Prisma.$TourActivityJunctionPayload<ExtArgs>
        fields: Prisma.TourActivityJunctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourActivityJunctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourActivityJunctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          findFirst: {
            args: Prisma.TourActivityJunctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourActivityJunctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          findMany: {
            args: Prisma.TourActivityJunctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>[]
          }
          create: {
            args: Prisma.TourActivityJunctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          createMany: {
            args: Prisma.TourActivityJunctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourActivityJunctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>[]
          }
          delete: {
            args: Prisma.TourActivityJunctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          update: {
            args: Prisma.TourActivityJunctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          deleteMany: {
            args: Prisma.TourActivityJunctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourActivityJunctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourActivityJunctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourActivityJunctionPayload>
          }
          aggregate: {
            args: Prisma.TourActivityJunctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourActivityJunction>
          }
          groupBy: {
            args: Prisma.TourActivityJunctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourActivityJunctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourActivityJunctionCountArgs<ExtArgs>
            result: $Utils.Optional<TourActivityJunctionCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      Flight: {
        payload: Prisma.$FlightPayload<ExtArgs>
        fields: Prisma.FlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          findFirst: {
            args: Prisma.FlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          findMany: {
            args: Prisma.FlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>[]
          }
          create: {
            args: Prisma.FlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          createMany: {
            args: Prisma.FlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>[]
          }
          delete: {
            args: Prisma.FlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          update: {
            args: Prisma.FlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          deleteMany: {
            args: Prisma.FlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightPayload>
          }
          aggregate: {
            args: Prisma.FlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlight>
          }
          groupBy: {
            args: Prisma.FlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightCountArgs<ExtArgs>
            result: $Utils.Optional<FlightCountAggregateOutputType> | number
          }
        }
      }
      TourFestival: {
        payload: Prisma.$TourFestivalPayload<ExtArgs>
        fields: Prisma.TourFestivalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFestivalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFestivalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          findFirst: {
            args: Prisma.TourFestivalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFestivalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          findMany: {
            args: Prisma.TourFestivalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>[]
          }
          create: {
            args: Prisma.TourFestivalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          createMany: {
            args: Prisma.TourFestivalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourFestivalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>[]
          }
          delete: {
            args: Prisma.TourFestivalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          update: {
            args: Prisma.TourFestivalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          deleteMany: {
            args: Prisma.TourFestivalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourFestivalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourFestivalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourFestivalPayload>
          }
          aggregate: {
            args: Prisma.TourFestivalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourFestival>
          }
          groupBy: {
            args: Prisma.TourFestivalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourFestivalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourFestivalCountArgs<ExtArgs>
            result: $Utils.Optional<TourFestivalCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TourCountOutputType
   */

  export type TourCountOutputType = {
    bookings: number
    itineraries: number
    userFeedback: number
    tourFestivals: number
    tourActivities: number
  }

  export type TourCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | TourCountOutputTypeCountBookingsArgs
    itineraries?: boolean | TourCountOutputTypeCountItinerariesArgs
    userFeedback?: boolean | TourCountOutputTypeCountUserFeedbackArgs
    tourFestivals?: boolean | TourCountOutputTypeCountTourFestivalsArgs
    tourActivities?: boolean | TourCountOutputTypeCountTourActivitiesArgs
  }

  // Custom InputTypes
  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountUserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountTourFestivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourFestivalWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountTourActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourActivityJunctionWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    activities: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | BookingCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingActivityWhereInput
  }


  /**
   * Count Type GuideCountOutputType
   */

  export type GuideCountOutputType = {
    guidedItineraries: number
    drivenItineraries: number
  }

  export type GuideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guidedItineraries?: boolean | GuideCountOutputTypeCountGuidedItinerariesArgs
    drivenItineraries?: boolean | GuideCountOutputTypeCountDrivenItinerariesArgs
  }

  // Custom InputTypes
  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuideCountOutputType
     */
    select?: GuideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeCountGuidedItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }

  /**
   * GuideCountOutputType without action
   */
  export type GuideCountOutputTypeCountDrivenItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * Count Type ItineraryCountOutputType
   */

  export type ItineraryCountOutputType = {
    days: number
    assignedCustomTourRequests: number
    UserFeedback: number
  }

  export type ItineraryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    days?: boolean | ItineraryCountOutputTypeCountDaysArgs
    assignedCustomTourRequests?: boolean | ItineraryCountOutputTypeCountAssignedCustomTourRequestsArgs
    UserFeedback?: boolean | ItineraryCountOutputTypeCountUserFeedbackArgs
  }

  // Custom InputTypes
  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryCountOutputType
     */
    select?: ItineraryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountAssignedCustomTourRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourRequestWhereInput
  }

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountUserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }


  /**
   * Count Type CustomTourRequestCountOutputType
   */

  export type CustomTourRequestCountOutputType = {
    interests: number
  }

  export type CustomTourRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | CustomTourRequestCountOutputTypeCountInterestsArgs
  }

  // Custom InputTypes
  /**
   * CustomTourRequestCountOutputType without action
   */
  export type CustomTourRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequestCountOutputType
     */
    select?: CustomTourRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomTourRequestCountOutputType without action
   */
  export type CustomTourRequestCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourInterestWhereInput
  }


  /**
   * Count Type TourOperatorCountOutputType
   */

  export type TourOperatorCountOutputType = {
    tours: number
  }

  export type TourOperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | TourOperatorCountOutputTypeCountToursArgs
  }

  // Custom InputTypes
  /**
   * TourOperatorCountOutputType without action
   */
  export type TourOperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperatorCountOutputType
     */
    select?: TourOperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourOperatorCountOutputType without action
   */
  export type TourOperatorCountOutputTypeCountToursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }


  /**
   * Count Type FestivalCountOutputType
   */

  export type FestivalCountOutputType = {
    tourFestivals: number
    festivalBookings: number
  }

  export type FestivalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourFestivals?: boolean | FestivalCountOutputTypeCountTourFestivalsArgs
    festivalBookings?: boolean | FestivalCountOutputTypeCountFestivalBookingsArgs
  }

  // Custom InputTypes
  /**
   * FestivalCountOutputType without action
   */
  export type FestivalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalCountOutputType
     */
    select?: FestivalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FestivalCountOutputType without action
   */
  export type FestivalCountOutputTypeCountTourFestivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourFestivalWhereInput
  }

  /**
   * FestivalCountOutputType without action
   */
  export type FestivalCountOutputTypeCountFestivalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalBookingWhereInput
  }


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    rooms: number
    bookings: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | HotelCountOutputTypeCountRoomsArgs
    bookings?: boolean | HotelCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRoomWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type HotelRoomCountOutputType
   */

  export type HotelRoomCountOutputType = {
    bookings: number
  }

  export type HotelRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | HotelRoomCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * HotelRoomCountOutputType without action
   */
  export type HotelRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoomCountOutputType
     */
    select?: HotelRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelRoomCountOutputType without action
   */
  export type HotelRoomCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
  }


  /**
   * Count Type UserAccountCountOutputType
   */

  export type UserAccountCountOutputType = {
    feedbacks: number
    interests: number
  }

  export type UserAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | UserAccountCountOutputTypeCountFeedbacksArgs
    interests?: boolean | UserAccountCountOutputTypeCountInterestsArgs
  }

  // Custom InputTypes
  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccountCountOutputType
     */
    select?: UserAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
  }

  /**
   * UserAccountCountOutputType without action
   */
  export type UserAccountCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInterestWhereInput
  }


  /**
   * Count Type HotelCategoryCountOutputType
   */

  export type HotelCategoryCountOutputType = {
    hotels: number
  }

  export type HotelCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | HotelCategoryCountOutputTypeCountHotelsArgs
  }

  // Custom InputTypes
  /**
   * HotelCategoryCountOutputType without action
   */
  export type HotelCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategoryCountOutputType
     */
    select?: HotelCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCategoryCountOutputType without action
   */
  export type HotelCategoryCountOutputTypeCountHotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
  }


  /**
   * Count Type TravelInterestCountOutputType
   */

  export type TravelInterestCountOutputType = {
    userInterests: number
    customTourInterests: number
  }

  export type TravelInterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userInterests?: boolean | TravelInterestCountOutputTypeCountUserInterestsArgs
    customTourInterests?: boolean | TravelInterestCountOutputTypeCountCustomTourInterestsArgs
  }

  // Custom InputTypes
  /**
   * TravelInterestCountOutputType without action
   */
  export type TravelInterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterestCountOutputType
     */
    select?: TravelInterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TravelInterestCountOutputType without action
   */
  export type TravelInterestCountOutputTypeCountUserInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInterestWhereInput
  }

  /**
   * TravelInterestCountOutputType without action
   */
  export type TravelInterestCountOutputTypeCountCustomTourInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourInterestWhereInput
  }


  /**
   * Count Type FlightRouteCountOutputType
   */

  export type FlightRouteCountOutputType = {
    flightBookings: number
  }

  export type FlightRouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightBookings?: boolean | FlightRouteCountOutputTypeCountFlightBookingsArgs
  }

  // Custom InputTypes
  /**
   * FlightRouteCountOutputType without action
   */
  export type FlightRouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRouteCountOutputType
     */
    select?: FlightRouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightRouteCountOutputType without action
   */
  export type FlightRouteCountOutputTypeCountFlightBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightBookingWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    tourActivities: number
    bookingActivities: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourActivities?: boolean | ActivityCountOutputTypeCountTourActivitiesArgs
    bookingActivities?: boolean | ActivityCountOutputTypeCountBookingActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountTourActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourActivityJunctionWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountBookingActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingActivityWhereInput
  }


  /**
   * Count Type ChatSessionCountOutputType
   */

  export type ChatSessionCountOutputType = {
    messages: number
  }

  export type ChatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    id: number | null
    price: number | null
    maxPrice: number | null
    rating: number | null
    tourOperatorId: number | null
  }

  export type TourSumAggregateOutputType = {
    id: number | null
    price: number | null
    maxPrice: number | null
    rating: number | null
    tourOperatorId: number | null
  }

  export type TourMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    duration: string | null
    price: number | null
    maxPrice: number | null
    categoryName: string | null
    difficulty: string | null
    groupSize: string | null
    imageUrl: string | null
    itinerary: string | null
    physicalRating: string | null
    culturalLevel: string | null
    luxuryLevel: string | null
    spiritualLevel: string | null
    rating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    tourOperatorId: number | null
  }

  export type TourMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    duration: string | null
    price: number | null
    maxPrice: number | null
    categoryName: string | null
    difficulty: string | null
    groupSize: string | null
    imageUrl: string | null
    itinerary: string | null
    physicalRating: string | null
    culturalLevel: string | null
    luxuryLevel: string | null
    spiritualLevel: string | null
    rating: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    tourOperatorId: number | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    name: number
    description: number
    duration: number
    price: number
    maxPrice: number
    categoryName: number
    difficulty: number
    groupSize: number
    imageUrl: number
    highlights: number
    includes: number
    excludes: number
    itinerary: number
    bestTime: number
    physicalRating: number
    culturalLevel: number
    luxuryLevel: number
    spiritualLevel: number
    rating: number
    isActive: number
    createdAt: number
    updatedAt: number
    tourOperatorId: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    id?: true
    price?: true
    maxPrice?: true
    rating?: true
    tourOperatorId?: true
  }

  export type TourSumAggregateInputType = {
    id?: true
    price?: true
    maxPrice?: true
    rating?: true
    tourOperatorId?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    maxPrice?: true
    categoryName?: true
    difficulty?: true
    groupSize?: true
    imageUrl?: true
    itinerary?: true
    physicalRating?: true
    culturalLevel?: true
    luxuryLevel?: true
    spiritualLevel?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    tourOperatorId?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    maxPrice?: true
    categoryName?: true
    difficulty?: true
    groupSize?: true
    imageUrl?: true
    itinerary?: true
    physicalRating?: true
    culturalLevel?: true
    luxuryLevel?: true
    spiritualLevel?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    tourOperatorId?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    maxPrice?: true
    categoryName?: true
    difficulty?: true
    groupSize?: true
    imageUrl?: true
    highlights?: true
    includes?: true
    excludes?: true
    itinerary?: true
    bestTime?: true
    physicalRating?: true
    culturalLevel?: true
    luxuryLevel?: true
    spiritualLevel?: true
    rating?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    tourOperatorId?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
    orderBy?: TourOrderByWithAggregationInput | TourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    id: number
    name: string
    description: string | null
    duration: string
    price: number
    maxPrice: number | null
    categoryName: string
    difficulty: string | null
    groupSize: string | null
    imageUrl: string | null
    highlights: string[]
    includes: string[]
    excludes: string[]
    itinerary: string | null
    bestTime: string[]
    physicalRating: string | null
    culturalLevel: string | null
    luxuryLevel: string | null
    spiritualLevel: string | null
    rating: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    tourOperatorId: number | null
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    maxPrice?: boolean
    categoryName?: boolean
    difficulty?: boolean
    groupSize?: boolean
    imageUrl?: boolean
    highlights?: boolean
    includes?: boolean
    excludes?: boolean
    itinerary?: boolean
    bestTime?: boolean
    physicalRating?: boolean
    culturalLevel?: boolean
    luxuryLevel?: boolean
    spiritualLevel?: boolean
    rating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourOperatorId?: boolean
    bookings?: boolean | Tour$bookingsArgs<ExtArgs>
    itineraries?: boolean | Tour$itinerariesArgs<ExtArgs>
    tourOperator?: boolean | Tour$tourOperatorArgs<ExtArgs>
    userFeedback?: boolean | Tour$userFeedbackArgs<ExtArgs>
    tourFestivals?: boolean | Tour$tourFestivalsArgs<ExtArgs>
    tourActivities?: boolean | Tour$tourActivitiesArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    maxPrice?: boolean
    categoryName?: boolean
    difficulty?: boolean
    groupSize?: boolean
    imageUrl?: boolean
    highlights?: boolean
    includes?: boolean
    excludes?: boolean
    itinerary?: boolean
    bestTime?: boolean
    physicalRating?: boolean
    culturalLevel?: boolean
    luxuryLevel?: boolean
    spiritualLevel?: boolean
    rating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourOperatorId?: boolean
    tourOperator?: boolean | Tour$tourOperatorArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    maxPrice?: boolean
    categoryName?: boolean
    difficulty?: boolean
    groupSize?: boolean
    imageUrl?: boolean
    highlights?: boolean
    includes?: boolean
    excludes?: boolean
    itinerary?: boolean
    bestTime?: boolean
    physicalRating?: boolean
    culturalLevel?: boolean
    luxuryLevel?: boolean
    spiritualLevel?: boolean
    rating?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourOperatorId?: boolean
  }

  export type TourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Tour$bookingsArgs<ExtArgs>
    itineraries?: boolean | Tour$itinerariesArgs<ExtArgs>
    tourOperator?: boolean | Tour$tourOperatorArgs<ExtArgs>
    userFeedback?: boolean | Tour$userFeedbackArgs<ExtArgs>
    tourFestivals?: boolean | Tour$tourFestivalsArgs<ExtArgs>
    tourActivities?: boolean | Tour$tourActivitiesArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourOperator?: boolean | Tour$tourOperatorArgs<ExtArgs>
  }

  export type $TourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tour"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      itineraries: Prisma.$ItineraryPayload<ExtArgs>[]
      tourOperator: Prisma.$TourOperatorPayload<ExtArgs> | null
      userFeedback: Prisma.$UserFeedbackPayload<ExtArgs>[]
      tourFestivals: Prisma.$TourFestivalPayload<ExtArgs>[]
      tourActivities: Prisma.$TourActivityJunctionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      duration: string
      price: number
      maxPrice: number | null
      categoryName: string
      difficulty: string | null
      groupSize: string | null
      imageUrl: string | null
      highlights: string[]
      includes: string[]
      excludes: string[]
      itinerary: string | null
      bestTime: string[]
      physicalRating: string | null
      culturalLevel: string | null
      luxuryLevel: string | null
      spiritualLevel: string | null
      rating: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      tourOperatorId: number | null
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type TourGetPayload<S extends boolean | null | undefined | TourDefaultArgs> = $Result.GetResult<Prisma.$TourPayload, S>

  type TourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tour'], meta: { name: 'Tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFindUniqueArgs>(args: SelectSubset<T, TourFindUniqueArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFindFirstArgs>(args?: SelectSubset<T, TourFindFirstArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFindManyArgs>(args?: SelectSubset<T, TourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends TourCreateArgs>(args: SelectSubset<T, TourCreateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tours.
     * @param {TourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCreateManyArgs>(args?: SelectSubset<T, TourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tours and returns the data saved in the database.
     * @param {TourCreateManyAndReturnArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tours and only return the `id`
     * const tourWithIdOnly = await prisma.tour.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourCreateManyAndReturnArgs>(args?: SelectSubset<T, TourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends TourDeleteArgs>(args: SelectSubset<T, TourDeleteArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourUpdateArgs>(args: SelectSubset<T, TourUpdateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourDeleteManyArgs>(args?: SelectSubset<T, TourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourUpdateManyArgs>(args: SelectSubset<T, TourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends TourUpsertArgs>(args: SelectSubset<T, TourUpsertArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tour model
   */
  readonly fields: TourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Tour$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tour$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    itineraries<T extends Tour$itinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Tour$itinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    tourOperator<T extends Tour$tourOperatorArgs<ExtArgs> = {}>(args?: Subset<T, Tour$tourOperatorArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userFeedback<T extends Tour$userFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Tour$userFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    tourFestivals<T extends Tour$tourFestivalsArgs<ExtArgs> = {}>(args?: Subset<T, Tour$tourFestivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findMany"> | Null>
    tourActivities<T extends Tour$tourActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tour$tourActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tour model
   */ 
  interface TourFieldRefs {
    readonly id: FieldRef<"Tour", 'Int'>
    readonly name: FieldRef<"Tour", 'String'>
    readonly description: FieldRef<"Tour", 'String'>
    readonly duration: FieldRef<"Tour", 'String'>
    readonly price: FieldRef<"Tour", 'Float'>
    readonly maxPrice: FieldRef<"Tour", 'Float'>
    readonly categoryName: FieldRef<"Tour", 'String'>
    readonly difficulty: FieldRef<"Tour", 'String'>
    readonly groupSize: FieldRef<"Tour", 'String'>
    readonly imageUrl: FieldRef<"Tour", 'String'>
    readonly highlights: FieldRef<"Tour", 'String[]'>
    readonly includes: FieldRef<"Tour", 'String[]'>
    readonly excludes: FieldRef<"Tour", 'String[]'>
    readonly itinerary: FieldRef<"Tour", 'String'>
    readonly bestTime: FieldRef<"Tour", 'String[]'>
    readonly physicalRating: FieldRef<"Tour", 'String'>
    readonly culturalLevel: FieldRef<"Tour", 'String'>
    readonly luxuryLevel: FieldRef<"Tour", 'String'>
    readonly spiritualLevel: FieldRef<"Tour", 'String'>
    readonly rating: FieldRef<"Tour", 'Float'>
    readonly isActive: FieldRef<"Tour", 'Boolean'>
    readonly createdAt: FieldRef<"Tour", 'DateTime'>
    readonly updatedAt: FieldRef<"Tour", 'DateTime'>
    readonly tourOperatorId: FieldRef<"Tour", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tour findUnique
   */
  export type TourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findFirst
   */
  export type TourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findMany
   */
  export type TourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour create
   */
  export type TourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
  }

  /**
   * Tour createMany
   */
  export type TourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tour createManyAndReturn
   */
  export type TourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tour update
   */
  export type TourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
  }

  /**
   * Tour upsert
   */
  export type TourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
  }

  /**
   * Tour delete
   */
  export type TourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
  }

  /**
   * Tour.bookings
   */
  export type Tour$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tour.itineraries
   */
  export type Tour$itinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Tour.tourOperator
   */
  export type Tour$tourOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    where?: TourOperatorWhereInput
  }

  /**
   * Tour.userFeedback
   */
  export type Tour$userFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * Tour.tourFestivals
   */
  export type Tour$tourFestivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    where?: TourFestivalWhereInput
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    cursor?: TourFestivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourFestivalScalarFieldEnum | TourFestivalScalarFieldEnum[]
  }

  /**
   * Tour.tourActivities
   */
  export type Tour$tourActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    where?: TourActivityJunctionWhereInput
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    cursor?: TourActivityJunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourActivityJunctionScalarFieldEnum | TourActivityJunctionScalarFieldEnum[]
  }

  /**
   * Tour without action
   */
  export type TourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    tourId: number | null
    groupSize: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    tourId: number | null
    groupSize: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    tourId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    travelDate: string | null
    groupSize: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    tourId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    travelDate: string | null
    groupSize: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tourId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    travelDate: number
    groupSize: number
    specialRequests: number
    status: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    tourId?: true
    groupSize?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    tourId?: true
    groupSize?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tourId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    travelDate?: true
    groupSize?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    travelDate: string
    groupSize: number
    specialRequests: string | null
    status: string
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activities?: boolean | Booking$activitiesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tourId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    travelDate?: boolean
    groupSize?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activities?: boolean | Booking$activitiesArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      activities: Prisma.$BookingActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tourId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      travelDate: string
      groupSize: number
      specialRequests: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Booking$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly tourId: FieldRef<"Booking", 'Int'>
    readonly firstName: FieldRef<"Booking", 'String'>
    readonly lastName: FieldRef<"Booking", 'String'>
    readonly email: FieldRef<"Booking", 'String'>
    readonly phone: FieldRef<"Booking", 'String'>
    readonly travelDate: FieldRef<"Booking", 'String'>
    readonly groupSize: FieldRef<"Booking", 'Int'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.activities
   */
  export type Booking$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    where?: BookingActivityWhereInput
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    cursor?: BookingActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingActivityScalarFieldEnum | BookingActivityScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    id: number | null
  }

  export type InquirySumAggregateOutputType = {
    id: number | null
  }

  export type InquiryMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    tourInterest: number
    preferredDates: number
    groupSize: number
    message: number
    status: number
    createdAt: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    id?: true
  }

  export type InquirySumAggregateInputType = {
    id?: true
  }

  export type InquiryMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    tourInterest?: true
    preferredDates?: true
    groupSize?: true
    message?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    tourInterest: string | null
    preferredDates: string | null
    groupSize: string | null
    message: string | null
    status: string
    createdAt: Date
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    tourInterest?: boolean
    preferredDates?: boolean
    groupSize?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }


  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      tourInterest: string | null
      preferredDates: string | null
      groupSize: string | null
      message: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inquiries and returns the data saved in the database.
     * @param {InquiryCreateManyAndReturnArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */ 
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'Int'>
    readonly firstName: FieldRef<"Inquiry", 'String'>
    readonly lastName: FieldRef<"Inquiry", 'String'>
    readonly email: FieldRef<"Inquiry", 'String'>
    readonly phone: FieldRef<"Inquiry", 'String'>
    readonly tourInterest: FieldRef<"Inquiry", 'String'>
    readonly preferredDates: FieldRef<"Inquiry", 'String'>
    readonly groupSize: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'String'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry createManyAndReturn
   */
  export type InquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    id: number | null
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: number | null
    name: string | null
    country: string | null
    imageUrl: string | null
    text: string | null
    rating: number | null
    tripName: string | null
    duration: string | null
    isActive: boolean | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: number | null
    name: string | null
    country: string | null
    imageUrl: string | null
    text: string | null
    rating: number | null
    tripName: string | null
    duration: string | null
    isActive: boolean | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    name: number
    country: number
    imageUrl: number
    text: number
    rating: number
    tripName: number
    duration: number
    isActive: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    id?: true
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    id?: true
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    name?: true
    country?: true
    imageUrl?: true
    text?: true
    rating?: true
    tripName?: true
    duration?: true
    isActive?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive: boolean
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    name?: boolean
    country?: boolean
    imageUrl?: boolean
    text?: boolean
    rating?: boolean
    tripName?: boolean
    duration?: boolean
    isActive?: boolean
  }


  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      country: string
      imageUrl: string
      text: string
      rating: number
      tripName: string
      duration: string
      isActive: boolean
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */ 
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'Int'>
    readonly name: FieldRef<"Testimonial", 'String'>
    readonly country: FieldRef<"Testimonial", 'String'>
    readonly imageUrl: FieldRef<"Testimonial", 'String'>
    readonly text: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly tripName: FieldRef<"Testimonial", 'String'>
    readonly duration: FieldRef<"Testimonial", 'String'>
    readonly isActive: FieldRef<"Testimonial", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    id: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    id: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: number | null
    title: string | null
    excerpt: string | null
    content: string | null
    imageUrl: string | null
    category: string | null
    author: string | null
    authorImage: string | null
    readTime: string | null
    publishedAt: Date | null
    isPublished: boolean | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: number | null
    title: string | null
    excerpt: string | null
    content: string | null
    imageUrl: string | null
    category: string | null
    author: string | null
    authorImage: string | null
    readTime: string | null
    publishedAt: Date | null
    isPublished: boolean | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    excerpt: number
    content: number
    imageUrl: number
    category: number
    author: number
    authorImage: number
    readTime: number
    publishedAt: number
    isPublished: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    id?: true
  }

  export type BlogPostSumAggregateInputType = {
    id?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    excerpt?: true
    content?: true
    imageUrl?: true
    category?: true
    author?: true
    authorImage?: true
    readTime?: true
    publishedAt?: true
    isPublished?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt: Date
    isPublished: boolean
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    imageUrl?: boolean
    category?: boolean
    author?: boolean
    authorImage?: boolean
    readTime?: boolean
    publishedAt?: boolean
    isPublished?: boolean
  }


  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      excerpt: string
      content: string
      imageUrl: string
      category: string
      author: string
      authorImage: string
      readTime: string
      publishedAt: Date
      isPublished: boolean
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'Int'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly imageUrl: FieldRef<"BlogPost", 'String'>
    readonly category: FieldRef<"BlogPost", 'String'>
    readonly author: FieldRef<"BlogPost", 'String'>
    readonly authorImage: FieldRef<"BlogPost", 'String'>
    readonly readTime: FieldRef<"BlogPost", 'String'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly isPublished: FieldRef<"BlogPost", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
  }


  /**
   * Model Guide
   */

  export type AggregateGuide = {
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  export type GuideAvgAggregateOutputType = {
    id: number | null
  }

  export type GuideSumAggregateOutputType = {
    id: number | null
  }

  export type GuideMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    licenseImageUrl: string | null
    registrationType: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GuideMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    licenseImageUrl: string | null
    registrationType: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GuideCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    licenseImageUrl: number
    registrationType: number
    specializations: number
    status: number
    createdAt: number
    _all: number
  }


  export type GuideAvgAggregateInputType = {
    id?: true
  }

  export type GuideSumAggregateInputType = {
    id?: true
  }

  export type GuideMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    status?: true
    createdAt?: true
  }

  export type GuideMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    status?: true
    createdAt?: true
  }

  export type GuideCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    licenseImageUrl?: true
    registrationType?: true
    specializations?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type GuideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guide to aggregate.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guides
    **/
    _count?: true | GuideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideMaxAggregateInputType
  }

  export type GetGuideAggregateType<T extends GuideAggregateArgs> = {
        [P in keyof T & keyof AggregateGuide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuide[P]>
      : GetScalarType<T[P], AggregateGuide[P]>
  }




  export type GuideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideWhereInput
    orderBy?: GuideOrderByWithAggregationInput | GuideOrderByWithAggregationInput[]
    by: GuideScalarFieldEnum[] | GuideScalarFieldEnum
    having?: GuideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideCountAggregateInputType | true
    _avg?: GuideAvgAggregateInputType
    _sum?: GuideSumAggregateInputType
    _min?: GuideMinAggregateInputType
    _max?: GuideMaxAggregateInputType
  }

  export type GuideGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations: string[]
    status: string
    createdAt: Date
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  type GetGuideGroupByPayload<T extends GuideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideGroupByOutputType[P]>
            : GetScalarType<T[P], GuideGroupByOutputType[P]>
        }
      >
    >


  export type GuideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
    guidedItineraries?: boolean | Guide$guidedItinerariesArgs<ExtArgs>
    drivenItineraries?: boolean | Guide$drivenItinerariesArgs<ExtArgs>
    _count?: boolean | GuideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    licenseImageUrl?: boolean
    registrationType?: boolean
    specializations?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type GuideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guidedItineraries?: boolean | Guide$guidedItinerariesArgs<ExtArgs>
    drivenItineraries?: boolean | Guide$drivenItinerariesArgs<ExtArgs>
    _count?: boolean | GuideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guide"
    objects: {
      guidedItineraries: Prisma.$ItineraryPayload<ExtArgs>[]
      drivenItineraries: Prisma.$ItineraryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      licenseImageUrl: string
      registrationType: string
      specializations: string[]
      status: string
      createdAt: Date
    }, ExtArgs["result"]["guide"]>
    composites: {}
  }

  type GuideGetPayload<S extends boolean | null | undefined | GuideDefaultArgs> = $Result.GetResult<Prisma.$GuidePayload, S>

  type GuideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuideCountAggregateInputType | true
    }

  export interface GuideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guide'], meta: { name: 'Guide' } }
    /**
     * Find zero or one Guide that matches the filter.
     * @param {GuideFindUniqueArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideFindUniqueArgs>(args: SelectSubset<T, GuideFindUniqueArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guide that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuideFindUniqueOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideFindFirstArgs>(args?: SelectSubset<T, GuideFindFirstArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guides
     * const guides = await prisma.guide.findMany()
     * 
     * // Get first 10 Guides
     * const guides = await prisma.guide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideWithIdOnly = await prisma.guide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideFindManyArgs>(args?: SelectSubset<T, GuideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guide.
     * @param {GuideCreateArgs} args - Arguments to create a Guide.
     * @example
     * // Create one Guide
     * const Guide = await prisma.guide.create({
     *   data: {
     *     // ... data to create a Guide
     *   }
     * })
     * 
     */
    create<T extends GuideCreateArgs>(args: SelectSubset<T, GuideCreateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guides.
     * @param {GuideCreateManyArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideCreateManyArgs>(args?: SelectSubset<T, GuideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guides and returns the data saved in the database.
     * @param {GuideCreateManyAndReturnArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guides and only return the `id`
     * const guideWithIdOnly = await prisma.guide.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Guide.
     * @param {GuideDeleteArgs} args - Arguments to delete one Guide.
     * @example
     * // Delete one Guide
     * const Guide = await prisma.guide.delete({
     *   where: {
     *     // ... filter to delete one Guide
     *   }
     * })
     * 
     */
    delete<T extends GuideDeleteArgs>(args: SelectSubset<T, GuideDeleteArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guide.
     * @param {GuideUpdateArgs} args - Arguments to update one Guide.
     * @example
     * // Update one Guide
     * const guide = await prisma.guide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideUpdateArgs>(args: SelectSubset<T, GuideUpdateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guides.
     * @param {GuideDeleteManyArgs} args - Arguments to filter Guides to delete.
     * @example
     * // Delete a few Guides
     * const { count } = await prisma.guide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideDeleteManyArgs>(args?: SelectSubset<T, GuideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guides
     * const guide = await prisma.guide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideUpdateManyArgs>(args: SelectSubset<T, GuideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guide.
     * @param {GuideUpsertArgs} args - Arguments to update or create a Guide.
     * @example
     * // Update or create a Guide
     * const guide = await prisma.guide.upsert({
     *   create: {
     *     // ... data to create a Guide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guide we want to update
     *   }
     * })
     */
    upsert<T extends GuideUpsertArgs>(args: SelectSubset<T, GuideUpsertArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideCountArgs} args - Arguments to filter Guides to count.
     * @example
     * // Count the number of Guides
     * const count = await prisma.guide.count({
     *   where: {
     *     // ... the filter for the Guides we want to count
     *   }
     * })
    **/
    count<T extends GuideCountArgs>(
      args?: Subset<T, GuideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideAggregateArgs>(args: Subset<T, GuideAggregateArgs>): Prisma.PrismaPromise<GetGuideAggregateType<T>>

    /**
     * Group by Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideGroupByArgs['orderBy'] }
        : { orderBy?: GuideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guide model
   */
  readonly fields: GuideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guidedItineraries<T extends Guide$guidedItinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Guide$guidedItinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    drivenItineraries<T extends Guide$drivenItinerariesArgs<ExtArgs> = {}>(args?: Subset<T, Guide$drivenItinerariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guide model
   */ 
  interface GuideFieldRefs {
    readonly id: FieldRef<"Guide", 'Int'>
    readonly name: FieldRef<"Guide", 'String'>
    readonly email: FieldRef<"Guide", 'String'>
    readonly phone: FieldRef<"Guide", 'String'>
    readonly licenseImageUrl: FieldRef<"Guide", 'String'>
    readonly registrationType: FieldRef<"Guide", 'String'>
    readonly specializations: FieldRef<"Guide", 'String[]'>
    readonly status: FieldRef<"Guide", 'String'>
    readonly createdAt: FieldRef<"Guide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guide findUnique
   */
  export type GuideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findUniqueOrThrow
   */
  export type GuideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findFirst
   */
  export type GuideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findFirstOrThrow
   */
  export type GuideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findMany
   */
  export type GuideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter, which Guides to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide create
   */
  export type GuideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The data needed to create a Guide.
     */
    data: XOR<GuideCreateInput, GuideUncheckedCreateInput>
  }

  /**
   * Guide createMany
   */
  export type GuideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide createManyAndReturn
   */
  export type GuideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guide update
   */
  export type GuideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The data needed to update a Guide.
     */
    data: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
    /**
     * Choose, which Guide to update.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide updateMany
   */
  export type GuideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guides.
     */
    data: XOR<GuideUpdateManyMutationInput, GuideUncheckedUpdateManyInput>
    /**
     * Filter which Guides to update
     */
    where?: GuideWhereInput
  }

  /**
   * Guide upsert
   */
  export type GuideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * The filter to search for the Guide to update in case it exists.
     */
    where: GuideWhereUniqueInput
    /**
     * In case the Guide found by the `where` argument doesn't exist, create a new Guide with this data.
     */
    create: XOR<GuideCreateInput, GuideUncheckedCreateInput>
    /**
     * In case the Guide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
  }

  /**
   * Guide delete
   */
  export type GuideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    /**
     * Filter which Guide to delete.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide deleteMany
   */
  export type GuideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guides to delete
     */
    where?: GuideWhereInput
  }

  /**
   * Guide.guidedItineraries
   */
  export type Guide$guidedItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Guide.drivenItineraries
   */
  export type Guide$drivenItinerariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Guide without action
   */
  export type GuideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
  }


  /**
   * Model Itinerary
   */

  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryAvgAggregateOutputType = {
    id: number | null
    tourId: number | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
  }

  export type ItinerarySumAggregateOutputType = {
    id: number | null
    tourId: number | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
  }

  export type ItineraryMinAggregateOutputType = {
    id: number | null
    tourId: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ItineraryMaxAggregateOutputType = {
    id: number | null
    tourId: number | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    guideId: number | null
    driverId: number | null
    maxParticipants: number | null
    currentParticipants: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ItineraryCountAggregateOutputType = {
    id: number
    tourId: number
    name: number
    description: number
    startDate: number
    endDate: number
    guideId: number
    driverId: number
    maxParticipants: number
    currentParticipants: number
    status: number
    createdAt: number
    _all: number
  }


  export type ItineraryAvgAggregateInputType = {
    id?: true
    tourId?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
  }

  export type ItinerarySumAggregateInputType = {
    id?: true
    tourId?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
  }

  export type ItineraryMinAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
  }

  export type ItineraryMaxAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
  }

  export type ItineraryCountAggregateInputType = {
    id?: true
    tourId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    guideId?: true
    driverId?: true
    maxParticipants?: true
    currentParticipants?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithAggregationInput | ItineraryOrderByWithAggregationInput[]
    by: ItineraryScalarFieldEnum[] | ItineraryScalarFieldEnum
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _avg?: ItineraryAvgAggregateInputType
    _sum?: ItinerarySumAggregateInputType
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }

  export type ItineraryGroupByOutputType = {
    id: number
    tourId: number
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    guideId: number | null
    driverId: number | null
    maxParticipants: number
    currentParticipants: number
    status: string
    createdAt: Date
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
    days?: boolean | Itinerary$daysArgs<ExtArgs>
    assignedCustomTourRequests?: boolean | Itinerary$assignedCustomTourRequestsArgs<ExtArgs>
    UserFeedback?: boolean | Itinerary$UserFeedbackArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    id?: boolean
    tourId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    guideId?: boolean
    driverId?: boolean
    maxParticipants?: boolean
    currentParticipants?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ItineraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
    days?: boolean | Itinerary$daysArgs<ExtArgs>
    assignedCustomTourRequests?: boolean | Itinerary$assignedCustomTourRequestsArgs<ExtArgs>
    UserFeedback?: boolean | Itinerary$UserFeedbackArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItineraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    guide?: boolean | Itinerary$guideArgs<ExtArgs>
    driver?: boolean | Itinerary$driverArgs<ExtArgs>
  }

  export type $ItineraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Itinerary"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      guide: Prisma.$GuidePayload<ExtArgs> | null
      driver: Prisma.$GuidePayload<ExtArgs> | null
      days: Prisma.$ItineraryDayPayload<ExtArgs>[]
      assignedCustomTourRequests: Prisma.$CustomTourRequestPayload<ExtArgs>[]
      UserFeedback: Prisma.$UserFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tourId: number
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      guideId: number | null
      driverId: number | null
      maxParticipants: number
      currentParticipants: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["itinerary"]>
    composites: {}
  }

  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryDefaultArgs> = $Result.GetResult<Prisma.$ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryFindUniqueArgs>(args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Itinerary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryFindFirstArgs>(args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryFindManyArgs>(args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
     */
    create<T extends ItineraryCreateArgs>(args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Itineraries.
     * @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryCreateManyArgs>(args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itineraries and returns the data saved in the database.
     * @param {ItineraryCreateManyAndReturnArgs} args - Arguments to create many Itineraries.
     * @example
     * // Create many Itineraries
     * const itinerary = await prisma.itinerary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itineraries and only return the `id`
     * const itineraryWithIdOnly = await prisma.itinerary.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDeleteArgs>(args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryUpdateArgs>(args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDeleteManyArgs>(args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryUpdateManyArgs>(args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryUpsertArgs>(args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Itinerary model
   */
  readonly fields: ItineraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    guide<T extends Itinerary$guideArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$guideArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends Itinerary$driverArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$driverArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    days<T extends Itinerary$daysArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$daysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findMany"> | Null>
    assignedCustomTourRequests<T extends Itinerary$assignedCustomTourRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$assignedCustomTourRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findMany"> | Null>
    UserFeedback<T extends Itinerary$UserFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$UserFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Itinerary model
   */ 
  interface ItineraryFieldRefs {
    readonly id: FieldRef<"Itinerary", 'Int'>
    readonly tourId: FieldRef<"Itinerary", 'Int'>
    readonly name: FieldRef<"Itinerary", 'String'>
    readonly description: FieldRef<"Itinerary", 'String'>
    readonly startDate: FieldRef<"Itinerary", 'DateTime'>
    readonly endDate: FieldRef<"Itinerary", 'DateTime'>
    readonly guideId: FieldRef<"Itinerary", 'Int'>
    readonly driverId: FieldRef<"Itinerary", 'Int'>
    readonly maxParticipants: FieldRef<"Itinerary", 'Int'>
    readonly currentParticipants: FieldRef<"Itinerary", 'Int'>
    readonly status: FieldRef<"Itinerary", 'String'>
    readonly createdAt: FieldRef<"Itinerary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Itinerary findUnique
   */
  export type ItineraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary findFirst
   */
  export type ItineraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }

  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }

  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Itinerary createManyAndReturn
   */
  export type ItineraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }

  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }

  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
  }

  /**
   * Itinerary.guide
   */
  export type Itinerary$guideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    where?: GuideWhereInput
  }

  /**
   * Itinerary.driver
   */
  export type Itinerary$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuideInclude<ExtArgs> | null
    where?: GuideWhereInput
  }

  /**
   * Itinerary.days
   */
  export type Itinerary$daysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    where?: ItineraryDayWhereInput
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    cursor?: ItineraryDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * Itinerary.assignedCustomTourRequests
   */
  export type Itinerary$assignedCustomTourRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    where?: CustomTourRequestWhereInput
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    cursor?: CustomTourRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * Itinerary.UserFeedback
   */
  export type Itinerary$UserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * Itinerary without action
   */
  export type ItineraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
  }


  /**
   * Model ItineraryDay
   */

  export type AggregateItineraryDay = {
    _count: ItineraryDayCountAggregateOutputType | null
    _avg: ItineraryDayAvgAggregateOutputType | null
    _sum: ItineraryDaySumAggregateOutputType | null
    _min: ItineraryDayMinAggregateOutputType | null
    _max: ItineraryDayMaxAggregateOutputType | null
  }

  export type ItineraryDayAvgAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
  }

  export type ItineraryDaySumAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
  }

  export type ItineraryDayMinAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
    title: string | null
    description: string | null
    accommodation: string | null
    transportation: string | null
    notes: string | null
  }

  export type ItineraryDayMaxAggregateOutputType = {
    id: number | null
    itineraryId: number | null
    dayNumber: number | null
    title: string | null
    description: string | null
    accommodation: string | null
    transportation: string | null
    notes: string | null
  }

  export type ItineraryDayCountAggregateOutputType = {
    id: number
    itineraryId: number
    dayNumber: number
    title: number
    description: number
    activities: number
    accommodation: number
    meals: number
    transportation: number
    notes: number
    _all: number
  }


  export type ItineraryDayAvgAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
  }

  export type ItineraryDaySumAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
  }

  export type ItineraryDayMinAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    accommodation?: true
    transportation?: true
    notes?: true
  }

  export type ItineraryDayMaxAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    accommodation?: true
    transportation?: true
    notes?: true
  }

  export type ItineraryDayCountAggregateInputType = {
    id?: true
    itineraryId?: true
    dayNumber?: true
    title?: true
    description?: true
    activities?: true
    accommodation?: true
    meals?: true
    transportation?: true
    notes?: true
    _all?: true
  }

  export type ItineraryDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItineraryDay to aggregate.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItineraryDays
    **/
    _count?: true | ItineraryDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItineraryDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryDayMaxAggregateInputType
  }

  export type GetItineraryDayAggregateType<T extends ItineraryDayAggregateArgs> = {
        [P in keyof T & keyof AggregateItineraryDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItineraryDay[P]>
      : GetScalarType<T[P], AggregateItineraryDay[P]>
  }




  export type ItineraryDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryDayWhereInput
    orderBy?: ItineraryDayOrderByWithAggregationInput | ItineraryDayOrderByWithAggregationInput[]
    by: ItineraryDayScalarFieldEnum[] | ItineraryDayScalarFieldEnum
    having?: ItineraryDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryDayCountAggregateInputType | true
    _avg?: ItineraryDayAvgAggregateInputType
    _sum?: ItineraryDaySumAggregateInputType
    _min?: ItineraryDayMinAggregateInputType
    _max?: ItineraryDayMaxAggregateInputType
  }

  export type ItineraryDayGroupByOutputType = {
    id: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities: string[]
    accommodation: string | null
    meals: string[]
    transportation: string | null
    notes: string | null
    _count: ItineraryDayCountAggregateOutputType | null
    _avg: ItineraryDayAvgAggregateOutputType | null
    _sum: ItineraryDaySumAggregateOutputType | null
    _min: ItineraryDayMinAggregateOutputType | null
    _max: ItineraryDayMaxAggregateOutputType | null
  }

  type GetItineraryDayGroupByPayload<T extends ItineraryDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryDayGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryDayGroupByOutputType[P]>
        }
      >
    >


  export type ItineraryDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itineraryDay"]>

  export type ItineraryDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itineraryDay"]>

  export type ItineraryDaySelectScalar = {
    id?: boolean
    itineraryId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    activities?: boolean
    accommodation?: boolean
    meals?: boolean
    transportation?: boolean
    notes?: boolean
  }

  export type ItineraryDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }
  export type ItineraryDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
  }

  export type $ItineraryDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItineraryDay"
    objects: {
      itinerary: Prisma.$ItineraryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itineraryId: number
      dayNumber: number
      title: string
      description: string
      activities: string[]
      accommodation: string | null
      meals: string[]
      transportation: string | null
      notes: string | null
    }, ExtArgs["result"]["itineraryDay"]>
    composites: {}
  }

  type ItineraryDayGetPayload<S extends boolean | null | undefined | ItineraryDayDefaultArgs> = $Result.GetResult<Prisma.$ItineraryDayPayload, S>

  type ItineraryDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryDayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryDayCountAggregateInputType | true
    }

  export interface ItineraryDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItineraryDay'], meta: { name: 'ItineraryDay' } }
    /**
     * Find zero or one ItineraryDay that matches the filter.
     * @param {ItineraryDayFindUniqueArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItineraryDayFindUniqueArgs>(args: SelectSubset<T, ItineraryDayFindUniqueArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ItineraryDay that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItineraryDayFindUniqueOrThrowArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItineraryDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ItineraryDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ItineraryDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindFirstArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItineraryDayFindFirstArgs>(args?: SelectSubset<T, ItineraryDayFindFirstArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ItineraryDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindFirstOrThrowArgs} args - Arguments to find a ItineraryDay
     * @example
     * // Get one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItineraryDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ItineraryDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ItineraryDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItineraryDays
     * const itineraryDays = await prisma.itineraryDay.findMany()
     * 
     * // Get first 10 ItineraryDays
     * const itineraryDays = await prisma.itineraryDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itineraryDayWithIdOnly = await prisma.itineraryDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItineraryDayFindManyArgs>(args?: SelectSubset<T, ItineraryDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ItineraryDay.
     * @param {ItineraryDayCreateArgs} args - Arguments to create a ItineraryDay.
     * @example
     * // Create one ItineraryDay
     * const ItineraryDay = await prisma.itineraryDay.create({
     *   data: {
     *     // ... data to create a ItineraryDay
     *   }
     * })
     * 
     */
    create<T extends ItineraryDayCreateArgs>(args: SelectSubset<T, ItineraryDayCreateArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ItineraryDays.
     * @param {ItineraryDayCreateManyArgs} args - Arguments to create many ItineraryDays.
     * @example
     * // Create many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItineraryDayCreateManyArgs>(args?: SelectSubset<T, ItineraryDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItineraryDays and returns the data saved in the database.
     * @param {ItineraryDayCreateManyAndReturnArgs} args - Arguments to create many ItineraryDays.
     * @example
     * // Create many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItineraryDays and only return the `id`
     * const itineraryDayWithIdOnly = await prisma.itineraryDay.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItineraryDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ItineraryDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ItineraryDay.
     * @param {ItineraryDayDeleteArgs} args - Arguments to delete one ItineraryDay.
     * @example
     * // Delete one ItineraryDay
     * const ItineraryDay = await prisma.itineraryDay.delete({
     *   where: {
     *     // ... filter to delete one ItineraryDay
     *   }
     * })
     * 
     */
    delete<T extends ItineraryDayDeleteArgs>(args: SelectSubset<T, ItineraryDayDeleteArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ItineraryDay.
     * @param {ItineraryDayUpdateArgs} args - Arguments to update one ItineraryDay.
     * @example
     * // Update one ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItineraryDayUpdateArgs>(args: SelectSubset<T, ItineraryDayUpdateArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ItineraryDays.
     * @param {ItineraryDayDeleteManyArgs} args - Arguments to filter ItineraryDays to delete.
     * @example
     * // Delete a few ItineraryDays
     * const { count } = await prisma.itineraryDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItineraryDayDeleteManyArgs>(args?: SelectSubset<T, ItineraryDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItineraryDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItineraryDays
     * const itineraryDay = await prisma.itineraryDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItineraryDayUpdateManyArgs>(args: SelectSubset<T, ItineraryDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItineraryDay.
     * @param {ItineraryDayUpsertArgs} args - Arguments to update or create a ItineraryDay.
     * @example
     * // Update or create a ItineraryDay
     * const itineraryDay = await prisma.itineraryDay.upsert({
     *   create: {
     *     // ... data to create a ItineraryDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItineraryDay we want to update
     *   }
     * })
     */
    upsert<T extends ItineraryDayUpsertArgs>(args: SelectSubset<T, ItineraryDayUpsertArgs<ExtArgs>>): Prisma__ItineraryDayClient<$Result.GetResult<Prisma.$ItineraryDayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ItineraryDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayCountArgs} args - Arguments to filter ItineraryDays to count.
     * @example
     * // Count the number of ItineraryDays
     * const count = await prisma.itineraryDay.count({
     *   where: {
     *     // ... the filter for the ItineraryDays we want to count
     *   }
     * })
    **/
    count<T extends ItineraryDayCountArgs>(
      args?: Subset<T, ItineraryDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItineraryDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryDayAggregateArgs>(args: Subset<T, ItineraryDayAggregateArgs>): Prisma.PrismaPromise<GetItineraryDayAggregateType<T>>

    /**
     * Group by ItineraryDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryDayGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItineraryDay model
   */
  readonly fields: ItineraryDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItineraryDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerary<T extends ItineraryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItineraryDefaultArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItineraryDay model
   */ 
  interface ItineraryDayFieldRefs {
    readonly id: FieldRef<"ItineraryDay", 'Int'>
    readonly itineraryId: FieldRef<"ItineraryDay", 'Int'>
    readonly dayNumber: FieldRef<"ItineraryDay", 'Int'>
    readonly title: FieldRef<"ItineraryDay", 'String'>
    readonly description: FieldRef<"ItineraryDay", 'String'>
    readonly activities: FieldRef<"ItineraryDay", 'String[]'>
    readonly accommodation: FieldRef<"ItineraryDay", 'String'>
    readonly meals: FieldRef<"ItineraryDay", 'String[]'>
    readonly transportation: FieldRef<"ItineraryDay", 'String'>
    readonly notes: FieldRef<"ItineraryDay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItineraryDay findUnique
   */
  export type ItineraryDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay findUniqueOrThrow
   */
  export type ItineraryDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay findFirst
   */
  export type ItineraryDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItineraryDays.
     */
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay findFirstOrThrow
   */
  export type ItineraryDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDay to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItineraryDays.
     */
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay findMany
   */
  export type ItineraryDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter, which ItineraryDays to fetch.
     */
    where?: ItineraryDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItineraryDays to fetch.
     */
    orderBy?: ItineraryDayOrderByWithRelationInput | ItineraryDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItineraryDays.
     */
    cursor?: ItineraryDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItineraryDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItineraryDays.
     */
    skip?: number
    distinct?: ItineraryDayScalarFieldEnum | ItineraryDayScalarFieldEnum[]
  }

  /**
   * ItineraryDay create
   */
  export type ItineraryDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ItineraryDay.
     */
    data: XOR<ItineraryDayCreateInput, ItineraryDayUncheckedCreateInput>
  }

  /**
   * ItineraryDay createMany
   */
  export type ItineraryDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItineraryDays.
     */
    data: ItineraryDayCreateManyInput | ItineraryDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItineraryDay createManyAndReturn
   */
  export type ItineraryDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ItineraryDays.
     */
    data: ItineraryDayCreateManyInput | ItineraryDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItineraryDay update
   */
  export type ItineraryDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ItineraryDay.
     */
    data: XOR<ItineraryDayUpdateInput, ItineraryDayUncheckedUpdateInput>
    /**
     * Choose, which ItineraryDay to update.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay updateMany
   */
  export type ItineraryDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItineraryDays.
     */
    data: XOR<ItineraryDayUpdateManyMutationInput, ItineraryDayUncheckedUpdateManyInput>
    /**
     * Filter which ItineraryDays to update
     */
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryDay upsert
   */
  export type ItineraryDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ItineraryDay to update in case it exists.
     */
    where: ItineraryDayWhereUniqueInput
    /**
     * In case the ItineraryDay found by the `where` argument doesn't exist, create a new ItineraryDay with this data.
     */
    create: XOR<ItineraryDayCreateInput, ItineraryDayUncheckedCreateInput>
    /**
     * In case the ItineraryDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryDayUpdateInput, ItineraryDayUncheckedUpdateInput>
  }

  /**
   * ItineraryDay delete
   */
  export type ItineraryDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
    /**
     * Filter which ItineraryDay to delete.
     */
    where: ItineraryDayWhereUniqueInput
  }

  /**
   * ItineraryDay deleteMany
   */
  export type ItineraryDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItineraryDays to delete
     */
    where?: ItineraryDayWhereInput
  }

  /**
   * ItineraryDay without action
   */
  export type ItineraryDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryDay
     */
    select?: ItineraryDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryDayInclude<ExtArgs> | null
  }


  /**
   * Model CustomTourRequest
   */

  export type AggregateCustomTourRequest = {
    _count: CustomTourRequestCountAggregateOutputType | null
    _avg: CustomTourRequestAvgAggregateOutputType | null
    _sum: CustomTourRequestSumAggregateOutputType | null
    _min: CustomTourRequestMinAggregateOutputType | null
    _max: CustomTourRequestMaxAggregateOutputType | null
  }

  export type CustomTourRequestAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
  }

  export type CustomTourRequestSumAggregateOutputType = {
    id: number | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
  }

  export type CustomTourRequestMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    preferredDates: string | null
    specialRequirements: string | null
    accommodationType: string | null
    transportPreference: string | null
    status: string | null
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date | null
  }

  export type CustomTourRequestMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    duration: number | null
    groupSize: number | null
    budget: number | null
    preferredDates: string | null
    specialRequirements: string | null
    accommodationType: string | null
    transportPreference: string | null
    status: string | null
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date | null
  }

  export type CustomTourRequestCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    duration: number
    groupSize: number
    budget: number
    preferredDates: number
    specialRequirements: number
    destinations: number
    accommodationType: number
    transportPreference: number
    status: number
    adminNotes: number
    estimatedPrice: number
    assignedItineraryId: number
    createdAt: number
    _all: number
  }


  export type CustomTourRequestAvgAggregateInputType = {
    id?: true
    duration?: true
    groupSize?: true
    budget?: true
    estimatedPrice?: true
    assignedItineraryId?: true
  }

  export type CustomTourRequestSumAggregateInputType = {
    id?: true
    duration?: true
    groupSize?: true
    budget?: true
    estimatedPrice?: true
    assignedItineraryId?: true
  }

  export type CustomTourRequestMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    preferredDates?: true
    specialRequirements?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
  }

  export type CustomTourRequestMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    preferredDates?: true
    specialRequirements?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
  }

  export type CustomTourRequestCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    duration?: true
    groupSize?: true
    budget?: true
    preferredDates?: true
    specialRequirements?: true
    destinations?: true
    accommodationType?: true
    transportPreference?: true
    status?: true
    adminNotes?: true
    estimatedPrice?: true
    assignedItineraryId?: true
    createdAt?: true
    _all?: true
  }

  export type CustomTourRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourRequest to aggregate.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomTourRequests
    **/
    _count?: true | CustomTourRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomTourRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomTourRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomTourRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomTourRequestMaxAggregateInputType
  }

  export type GetCustomTourRequestAggregateType<T extends CustomTourRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomTourRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomTourRequest[P]>
      : GetScalarType<T[P], AggregateCustomTourRequest[P]>
  }




  export type CustomTourRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourRequestWhereInput
    orderBy?: CustomTourRequestOrderByWithAggregationInput | CustomTourRequestOrderByWithAggregationInput[]
    by: CustomTourRequestScalarFieldEnum[] | CustomTourRequestScalarFieldEnum
    having?: CustomTourRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomTourRequestCountAggregateInputType | true
    _avg?: CustomTourRequestAvgAggregateInputType
    _sum?: CustomTourRequestSumAggregateInputType
    _min?: CustomTourRequestMinAggregateInputType
    _max?: CustomTourRequestMaxAggregateInputType
  }

  export type CustomTourRequestGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    duration: number
    groupSize: number
    budget: number | null
    preferredDates: string | null
    specialRequirements: string | null
    destinations: string[]
    accommodationType: string | null
    transportPreference: string | null
    status: string
    adminNotes: string | null
    estimatedPrice: number | null
    assignedItineraryId: number | null
    createdAt: Date
    _count: CustomTourRequestCountAggregateOutputType | null
    _avg: CustomTourRequestAvgAggregateOutputType | null
    _sum: CustomTourRequestSumAggregateOutputType | null
    _min: CustomTourRequestMinAggregateOutputType | null
    _max: CustomTourRequestMaxAggregateOutputType | null
  }

  type GetCustomTourRequestGroupByPayload<T extends CustomTourRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomTourRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomTourRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomTourRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CustomTourRequestGroupByOutputType[P]>
        }
      >
    >


  export type CustomTourRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
    interests?: boolean | CustomTourRequest$interestsArgs<ExtArgs>
    _count?: boolean | CustomTourRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customTourRequest"]>

  export type CustomTourRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }, ExtArgs["result"]["customTourRequest"]>

  export type CustomTourRequestSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    duration?: boolean
    groupSize?: boolean
    budget?: boolean
    preferredDates?: boolean
    specialRequirements?: boolean
    destinations?: boolean
    accommodationType?: boolean
    transportPreference?: boolean
    status?: boolean
    adminNotes?: boolean
    estimatedPrice?: boolean
    assignedItineraryId?: boolean
    createdAt?: boolean
  }

  export type CustomTourRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
    interests?: boolean | CustomTourRequest$interestsArgs<ExtArgs>
    _count?: boolean | CustomTourRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomTourRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedItinerary?: boolean | CustomTourRequest$assignedItineraryArgs<ExtArgs>
  }

  export type $CustomTourRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomTourRequest"
    objects: {
      assignedItinerary: Prisma.$ItineraryPayload<ExtArgs> | null
      interests: Prisma.$CustomTourInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      duration: number
      groupSize: number
      budget: number | null
      preferredDates: string | null
      specialRequirements: string | null
      destinations: string[]
      accommodationType: string | null
      transportPreference: string | null
      status: string
      adminNotes: string | null
      estimatedPrice: number | null
      assignedItineraryId: number | null
      createdAt: Date
    }, ExtArgs["result"]["customTourRequest"]>
    composites: {}
  }

  type CustomTourRequestGetPayload<S extends boolean | null | undefined | CustomTourRequestDefaultArgs> = $Result.GetResult<Prisma.$CustomTourRequestPayload, S>

  type CustomTourRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomTourRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomTourRequestCountAggregateInputType | true
    }

  export interface CustomTourRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomTourRequest'], meta: { name: 'CustomTourRequest' } }
    /**
     * Find zero or one CustomTourRequest that matches the filter.
     * @param {CustomTourRequestFindUniqueArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomTourRequestFindUniqueArgs>(args: SelectSubset<T, CustomTourRequestFindUniqueArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomTourRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomTourRequestFindUniqueOrThrowArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomTourRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomTourRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomTourRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindFirstArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomTourRequestFindFirstArgs>(args?: SelectSubset<T, CustomTourRequestFindFirstArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomTourRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindFirstOrThrowArgs} args - Arguments to find a CustomTourRequest
     * @example
     * // Get one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomTourRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomTourRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomTourRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomTourRequests
     * const customTourRequests = await prisma.customTourRequest.findMany()
     * 
     * // Get first 10 CustomTourRequests
     * const customTourRequests = await prisma.customTourRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customTourRequestWithIdOnly = await prisma.customTourRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomTourRequestFindManyArgs>(args?: SelectSubset<T, CustomTourRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomTourRequest.
     * @param {CustomTourRequestCreateArgs} args - Arguments to create a CustomTourRequest.
     * @example
     * // Create one CustomTourRequest
     * const CustomTourRequest = await prisma.customTourRequest.create({
     *   data: {
     *     // ... data to create a CustomTourRequest
     *   }
     * })
     * 
     */
    create<T extends CustomTourRequestCreateArgs>(args: SelectSubset<T, CustomTourRequestCreateArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomTourRequests.
     * @param {CustomTourRequestCreateManyArgs} args - Arguments to create many CustomTourRequests.
     * @example
     * // Create many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomTourRequestCreateManyArgs>(args?: SelectSubset<T, CustomTourRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomTourRequests and returns the data saved in the database.
     * @param {CustomTourRequestCreateManyAndReturnArgs} args - Arguments to create many CustomTourRequests.
     * @example
     * // Create many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomTourRequests and only return the `id`
     * const customTourRequestWithIdOnly = await prisma.customTourRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomTourRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomTourRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomTourRequest.
     * @param {CustomTourRequestDeleteArgs} args - Arguments to delete one CustomTourRequest.
     * @example
     * // Delete one CustomTourRequest
     * const CustomTourRequest = await prisma.customTourRequest.delete({
     *   where: {
     *     // ... filter to delete one CustomTourRequest
     *   }
     * })
     * 
     */
    delete<T extends CustomTourRequestDeleteArgs>(args: SelectSubset<T, CustomTourRequestDeleteArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomTourRequest.
     * @param {CustomTourRequestUpdateArgs} args - Arguments to update one CustomTourRequest.
     * @example
     * // Update one CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomTourRequestUpdateArgs>(args: SelectSubset<T, CustomTourRequestUpdateArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomTourRequests.
     * @param {CustomTourRequestDeleteManyArgs} args - Arguments to filter CustomTourRequests to delete.
     * @example
     * // Delete a few CustomTourRequests
     * const { count } = await prisma.customTourRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomTourRequestDeleteManyArgs>(args?: SelectSubset<T, CustomTourRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomTourRequests
     * const customTourRequest = await prisma.customTourRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomTourRequestUpdateManyArgs>(args: SelectSubset<T, CustomTourRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomTourRequest.
     * @param {CustomTourRequestUpsertArgs} args - Arguments to update or create a CustomTourRequest.
     * @example
     * // Update or create a CustomTourRequest
     * const customTourRequest = await prisma.customTourRequest.upsert({
     *   create: {
     *     // ... data to create a CustomTourRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomTourRequest we want to update
     *   }
     * })
     */
    upsert<T extends CustomTourRequestUpsertArgs>(args: SelectSubset<T, CustomTourRequestUpsertArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestCountArgs} args - Arguments to filter CustomTourRequests to count.
     * @example
     * // Count the number of CustomTourRequests
     * const count = await prisma.customTourRequest.count({
     *   where: {
     *     // ... the filter for the CustomTourRequests we want to count
     *   }
     * })
    **/
    count<T extends CustomTourRequestCountArgs>(
      args?: Subset<T, CustomTourRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomTourRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomTourRequestAggregateArgs>(args: Subset<T, CustomTourRequestAggregateArgs>): Prisma.PrismaPromise<GetCustomTourRequestAggregateType<T>>

    /**
     * Group by CustomTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomTourRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomTourRequestGroupByArgs['orderBy'] }
        : { orderBy?: CustomTourRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomTourRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomTourRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomTourRequest model
   */
  readonly fields: CustomTourRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomTourRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomTourRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedItinerary<T extends CustomTourRequest$assignedItineraryArgs<ExtArgs> = {}>(args?: Subset<T, CustomTourRequest$assignedItineraryArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    interests<T extends CustomTourRequest$interestsArgs<ExtArgs> = {}>(args?: Subset<T, CustomTourRequest$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomTourRequest model
   */ 
  interface CustomTourRequestFieldRefs {
    readonly id: FieldRef<"CustomTourRequest", 'Int'>
    readonly firstName: FieldRef<"CustomTourRequest", 'String'>
    readonly lastName: FieldRef<"CustomTourRequest", 'String'>
    readonly email: FieldRef<"CustomTourRequest", 'String'>
    readonly phone: FieldRef<"CustomTourRequest", 'String'>
    readonly duration: FieldRef<"CustomTourRequest", 'Int'>
    readonly groupSize: FieldRef<"CustomTourRequest", 'Int'>
    readonly budget: FieldRef<"CustomTourRequest", 'Int'>
    readonly preferredDates: FieldRef<"CustomTourRequest", 'String'>
    readonly specialRequirements: FieldRef<"CustomTourRequest", 'String'>
    readonly destinations: FieldRef<"CustomTourRequest", 'String[]'>
    readonly accommodationType: FieldRef<"CustomTourRequest", 'String'>
    readonly transportPreference: FieldRef<"CustomTourRequest", 'String'>
    readonly status: FieldRef<"CustomTourRequest", 'String'>
    readonly adminNotes: FieldRef<"CustomTourRequest", 'String'>
    readonly estimatedPrice: FieldRef<"CustomTourRequest", 'Int'>
    readonly assignedItineraryId: FieldRef<"CustomTourRequest", 'Int'>
    readonly createdAt: FieldRef<"CustomTourRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomTourRequest findUnique
   */
  export type CustomTourRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest findUniqueOrThrow
   */
  export type CustomTourRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest findFirst
   */
  export type CustomTourRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourRequests.
     */
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest findFirstOrThrow
   */
  export type CustomTourRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequest to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourRequests.
     */
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest findMany
   */
  export type CustomTourRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourRequests to fetch.
     */
    where?: CustomTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourRequests to fetch.
     */
    orderBy?: CustomTourRequestOrderByWithRelationInput | CustomTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomTourRequests.
     */
    cursor?: CustomTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourRequests.
     */
    skip?: number
    distinct?: CustomTourRequestScalarFieldEnum | CustomTourRequestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest create
   */
  export type CustomTourRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomTourRequest.
     */
    data: XOR<CustomTourRequestCreateInput, CustomTourRequestUncheckedCreateInput>
  }

  /**
   * CustomTourRequest createMany
   */
  export type CustomTourRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomTourRequests.
     */
    data: CustomTourRequestCreateManyInput | CustomTourRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomTourRequest createManyAndReturn
   */
  export type CustomTourRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomTourRequests.
     */
    data: CustomTourRequestCreateManyInput | CustomTourRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomTourRequest update
   */
  export type CustomTourRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomTourRequest.
     */
    data: XOR<CustomTourRequestUpdateInput, CustomTourRequestUncheckedUpdateInput>
    /**
     * Choose, which CustomTourRequest to update.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest updateMany
   */
  export type CustomTourRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomTourRequests.
     */
    data: XOR<CustomTourRequestUpdateManyMutationInput, CustomTourRequestUncheckedUpdateManyInput>
    /**
     * Filter which CustomTourRequests to update
     */
    where?: CustomTourRequestWhereInput
  }

  /**
   * CustomTourRequest upsert
   */
  export type CustomTourRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomTourRequest to update in case it exists.
     */
    where: CustomTourRequestWhereUniqueInput
    /**
     * In case the CustomTourRequest found by the `where` argument doesn't exist, create a new CustomTourRequest with this data.
     */
    create: XOR<CustomTourRequestCreateInput, CustomTourRequestUncheckedCreateInput>
    /**
     * In case the CustomTourRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomTourRequestUpdateInput, CustomTourRequestUncheckedUpdateInput>
  }

  /**
   * CustomTourRequest delete
   */
  export type CustomTourRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
    /**
     * Filter which CustomTourRequest to delete.
     */
    where: CustomTourRequestWhereUniqueInput
  }

  /**
   * CustomTourRequest deleteMany
   */
  export type CustomTourRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourRequests to delete
     */
    where?: CustomTourRequestWhereInput
  }

  /**
   * CustomTourRequest.assignedItinerary
   */
  export type CustomTourRequest$assignedItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
  }

  /**
   * CustomTourRequest.interests
   */
  export type CustomTourRequest$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    where?: CustomTourInterestWhereInput
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    cursor?: CustomTourInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomTourInterestScalarFieldEnum | CustomTourInterestScalarFieldEnum[]
  }

  /**
   * CustomTourRequest without action
   */
  export type CustomTourRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourRequest
     */
    select?: CustomTourRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourRequestInclude<ExtArgs> | null
  }


  /**
   * Model TourOperator
   */

  export type AggregateTourOperator = {
    _count: TourOperatorCountAggregateOutputType | null
    _avg: TourOperatorAvgAggregateOutputType | null
    _sum: TourOperatorSumAggregateOutputType | null
    _min: TourOperatorMinAggregateOutputType | null
    _max: TourOperatorMaxAggregateOutputType | null
  }

  export type TourOperatorAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    reviewCount: number | null
    establishedYear: number | null
  }

  export type TourOperatorSumAggregateOutputType = {
    id: number | null
    rating: number | null
    reviewCount: number | null
    establishedYear: number | null
  }

  export type TourOperatorMinAggregateOutputType = {
    id: number | null
    name: string | null
    website: string | null
    description: string | null
    bestFeature: string | null
    rating: number | null
    reviewCount: number | null
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    establishedYear: number | null
    createdAt: Date | null
  }

  export type TourOperatorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    website: string | null
    description: string | null
    bestFeature: string | null
    rating: number | null
    reviewCount: number | null
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    establishedYear: number | null
    createdAt: Date | null
  }

  export type TourOperatorCountAggregateOutputType = {
    id: number
    name: number
    website: number
    description: number
    bestFeature: number
    specialties: number
    rating: number
    reviewCount: number
    logoUrl: number
    contactEmail: number
    contactPhone: number
    isActive: number
    establishedYear: number
    certifications: number
    awards: number
    createdAt: number
    _all: number
  }


  export type TourOperatorAvgAggregateInputType = {
    id?: true
    rating?: true
    reviewCount?: true
    establishedYear?: true
  }

  export type TourOperatorSumAggregateInputType = {
    id?: true
    rating?: true
    reviewCount?: true
    establishedYear?: true
  }

  export type TourOperatorMinAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    createdAt?: true
  }

  export type TourOperatorMaxAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    createdAt?: true
  }

  export type TourOperatorCountAggregateInputType = {
    id?: true
    name?: true
    website?: true
    description?: true
    bestFeature?: true
    specialties?: true
    rating?: true
    reviewCount?: true
    logoUrl?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    establishedYear?: true
    certifications?: true
    awards?: true
    createdAt?: true
    _all?: true
  }

  export type TourOperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourOperator to aggregate.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourOperators
    **/
    _count?: true | TourOperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourOperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourOperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourOperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourOperatorMaxAggregateInputType
  }

  export type GetTourOperatorAggregateType<T extends TourOperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateTourOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourOperator[P]>
      : GetScalarType<T[P], AggregateTourOperator[P]>
  }




  export type TourOperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourOperatorWhereInput
    orderBy?: TourOperatorOrderByWithAggregationInput | TourOperatorOrderByWithAggregationInput[]
    by: TourOperatorScalarFieldEnum[] | TourOperatorScalarFieldEnum
    having?: TourOperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourOperatorCountAggregateInputType | true
    _avg?: TourOperatorAvgAggregateInputType
    _sum?: TourOperatorSumAggregateInputType
    _min?: TourOperatorMinAggregateInputType
    _max?: TourOperatorMaxAggregateInputType
  }

  export type TourOperatorGroupByOutputType = {
    id: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties: string[]
    rating: number
    reviewCount: number
    logoUrl: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean
    establishedYear: number | null
    certifications: string[]
    awards: string[]
    createdAt: Date
    _count: TourOperatorCountAggregateOutputType | null
    _avg: TourOperatorAvgAggregateOutputType | null
    _sum: TourOperatorSumAggregateOutputType | null
    _min: TourOperatorMinAggregateOutputType | null
    _max: TourOperatorMaxAggregateOutputType | null
  }

  type GetTourOperatorGroupByPayload<T extends TourOperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourOperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourOperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourOperatorGroupByOutputType[P]>
            : GetScalarType<T[P], TourOperatorGroupByOutputType[P]>
        }
      >
    >


  export type TourOperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
    tours?: boolean | TourOperator$toursArgs<ExtArgs>
    _count?: boolean | TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourOperator"]>

  export type TourOperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tourOperator"]>

  export type TourOperatorSelectScalar = {
    id?: boolean
    name?: boolean
    website?: boolean
    description?: boolean
    bestFeature?: boolean
    specialties?: boolean
    rating?: boolean
    reviewCount?: boolean
    logoUrl?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    isActive?: boolean
    establishedYear?: boolean
    certifications?: boolean
    awards?: boolean
    createdAt?: boolean
  }

  export type TourOperatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | TourOperator$toursArgs<ExtArgs>
    _count?: boolean | TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TourOperatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TourOperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourOperator"
    objects: {
      tours: Prisma.$TourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      website: string
      description: string
      bestFeature: string
      specialties: string[]
      rating: number
      reviewCount: number
      logoUrl: string | null
      contactEmail: string | null
      contactPhone: string | null
      isActive: boolean
      establishedYear: number | null
      certifications: string[]
      awards: string[]
      createdAt: Date
    }, ExtArgs["result"]["tourOperator"]>
    composites: {}
  }

  type TourOperatorGetPayload<S extends boolean | null | undefined | TourOperatorDefaultArgs> = $Result.GetResult<Prisma.$TourOperatorPayload, S>

  type TourOperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourOperatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourOperatorCountAggregateInputType | true
    }

  export interface TourOperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourOperator'], meta: { name: 'TourOperator' } }
    /**
     * Find zero or one TourOperator that matches the filter.
     * @param {TourOperatorFindUniqueArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourOperatorFindUniqueArgs>(args: SelectSubset<T, TourOperatorFindUniqueArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourOperator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourOperatorFindUniqueOrThrowArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourOperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, TourOperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourOperator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindFirstArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourOperatorFindFirstArgs>(args?: SelectSubset<T, TourOperatorFindFirstArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourOperator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindFirstOrThrowArgs} args - Arguments to find a TourOperator
     * @example
     * // Get one TourOperator
     * const tourOperator = await prisma.tourOperator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourOperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, TourOperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourOperators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourOperators
     * const tourOperators = await prisma.tourOperator.findMany()
     * 
     * // Get first 10 TourOperators
     * const tourOperators = await prisma.tourOperator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourOperatorWithIdOnly = await prisma.tourOperator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourOperatorFindManyArgs>(args?: SelectSubset<T, TourOperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourOperator.
     * @param {TourOperatorCreateArgs} args - Arguments to create a TourOperator.
     * @example
     * // Create one TourOperator
     * const TourOperator = await prisma.tourOperator.create({
     *   data: {
     *     // ... data to create a TourOperator
     *   }
     * })
     * 
     */
    create<T extends TourOperatorCreateArgs>(args: SelectSubset<T, TourOperatorCreateArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourOperators.
     * @param {TourOperatorCreateManyArgs} args - Arguments to create many TourOperators.
     * @example
     * // Create many TourOperators
     * const tourOperator = await prisma.tourOperator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourOperatorCreateManyArgs>(args?: SelectSubset<T, TourOperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourOperators and returns the data saved in the database.
     * @param {TourOperatorCreateManyAndReturnArgs} args - Arguments to create many TourOperators.
     * @example
     * // Create many TourOperators
     * const tourOperator = await prisma.tourOperator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourOperators and only return the `id`
     * const tourOperatorWithIdOnly = await prisma.tourOperator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourOperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, TourOperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TourOperator.
     * @param {TourOperatorDeleteArgs} args - Arguments to delete one TourOperator.
     * @example
     * // Delete one TourOperator
     * const TourOperator = await prisma.tourOperator.delete({
     *   where: {
     *     // ... filter to delete one TourOperator
     *   }
     * })
     * 
     */
    delete<T extends TourOperatorDeleteArgs>(args: SelectSubset<T, TourOperatorDeleteArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourOperator.
     * @param {TourOperatorUpdateArgs} args - Arguments to update one TourOperator.
     * @example
     * // Update one TourOperator
     * const tourOperator = await prisma.tourOperator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourOperatorUpdateArgs>(args: SelectSubset<T, TourOperatorUpdateArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourOperators.
     * @param {TourOperatorDeleteManyArgs} args - Arguments to filter TourOperators to delete.
     * @example
     * // Delete a few TourOperators
     * const { count } = await prisma.tourOperator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourOperatorDeleteManyArgs>(args?: SelectSubset<T, TourOperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourOperators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourOperators
     * const tourOperator = await prisma.tourOperator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourOperatorUpdateManyArgs>(args: SelectSubset<T, TourOperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourOperator.
     * @param {TourOperatorUpsertArgs} args - Arguments to update or create a TourOperator.
     * @example
     * // Update or create a TourOperator
     * const tourOperator = await prisma.tourOperator.upsert({
     *   create: {
     *     // ... data to create a TourOperator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourOperator we want to update
     *   }
     * })
     */
    upsert<T extends TourOperatorUpsertArgs>(args: SelectSubset<T, TourOperatorUpsertArgs<ExtArgs>>): Prisma__TourOperatorClient<$Result.GetResult<Prisma.$TourOperatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TourOperators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorCountArgs} args - Arguments to filter TourOperators to count.
     * @example
     * // Count the number of TourOperators
     * const count = await prisma.tourOperator.count({
     *   where: {
     *     // ... the filter for the TourOperators we want to count
     *   }
     * })
    **/
    count<T extends TourOperatorCountArgs>(
      args?: Subset<T, TourOperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourOperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourOperator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourOperatorAggregateArgs>(args: Subset<T, TourOperatorAggregateArgs>): Prisma.PrismaPromise<GetTourOperatorAggregateType<T>>

    /**
     * Group by TourOperator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourOperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourOperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourOperatorGroupByArgs['orderBy'] }
        : { orderBy?: TourOperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourOperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourOperator model
   */
  readonly fields: TourOperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourOperator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourOperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tours<T extends TourOperator$toursArgs<ExtArgs> = {}>(args?: Subset<T, TourOperator$toursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourOperator model
   */ 
  interface TourOperatorFieldRefs {
    readonly id: FieldRef<"TourOperator", 'Int'>
    readonly name: FieldRef<"TourOperator", 'String'>
    readonly website: FieldRef<"TourOperator", 'String'>
    readonly description: FieldRef<"TourOperator", 'String'>
    readonly bestFeature: FieldRef<"TourOperator", 'String'>
    readonly specialties: FieldRef<"TourOperator", 'String[]'>
    readonly rating: FieldRef<"TourOperator", 'Float'>
    readonly reviewCount: FieldRef<"TourOperator", 'Int'>
    readonly logoUrl: FieldRef<"TourOperator", 'String'>
    readonly contactEmail: FieldRef<"TourOperator", 'String'>
    readonly contactPhone: FieldRef<"TourOperator", 'String'>
    readonly isActive: FieldRef<"TourOperator", 'Boolean'>
    readonly establishedYear: FieldRef<"TourOperator", 'Int'>
    readonly certifications: FieldRef<"TourOperator", 'String[]'>
    readonly awards: FieldRef<"TourOperator", 'String[]'>
    readonly createdAt: FieldRef<"TourOperator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TourOperator findUnique
   */
  export type TourOperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator findUniqueOrThrow
   */
  export type TourOperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator findFirst
   */
  export type TourOperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourOperators.
     */
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator findFirstOrThrow
   */
  export type TourOperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperator to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourOperators.
     */
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator findMany
   */
  export type TourOperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter, which TourOperators to fetch.
     */
    where?: TourOperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourOperators to fetch.
     */
    orderBy?: TourOperatorOrderByWithRelationInput | TourOperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourOperators.
     */
    cursor?: TourOperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourOperators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourOperators.
     */
    skip?: number
    distinct?: TourOperatorScalarFieldEnum | TourOperatorScalarFieldEnum[]
  }

  /**
   * TourOperator create
   */
  export type TourOperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The data needed to create a TourOperator.
     */
    data: XOR<TourOperatorCreateInput, TourOperatorUncheckedCreateInput>
  }

  /**
   * TourOperator createMany
   */
  export type TourOperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourOperators.
     */
    data: TourOperatorCreateManyInput | TourOperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourOperator createManyAndReturn
   */
  export type TourOperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TourOperators.
     */
    data: TourOperatorCreateManyInput | TourOperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourOperator update
   */
  export type TourOperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The data needed to update a TourOperator.
     */
    data: XOR<TourOperatorUpdateInput, TourOperatorUncheckedUpdateInput>
    /**
     * Choose, which TourOperator to update.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator updateMany
   */
  export type TourOperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourOperators.
     */
    data: XOR<TourOperatorUpdateManyMutationInput, TourOperatorUncheckedUpdateManyInput>
    /**
     * Filter which TourOperators to update
     */
    where?: TourOperatorWhereInput
  }

  /**
   * TourOperator upsert
   */
  export type TourOperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * The filter to search for the TourOperator to update in case it exists.
     */
    where: TourOperatorWhereUniqueInput
    /**
     * In case the TourOperator found by the `where` argument doesn't exist, create a new TourOperator with this data.
     */
    create: XOR<TourOperatorCreateInput, TourOperatorUncheckedCreateInput>
    /**
     * In case the TourOperator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourOperatorUpdateInput, TourOperatorUncheckedUpdateInput>
  }

  /**
   * TourOperator delete
   */
  export type TourOperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
    /**
     * Filter which TourOperator to delete.
     */
    where: TourOperatorWhereUniqueInput
  }

  /**
   * TourOperator deleteMany
   */
  export type TourOperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourOperators to delete
     */
    where?: TourOperatorWhereInput
  }

  /**
   * TourOperator.tours
   */
  export type TourOperator$toursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * TourOperator without action
   */
  export type TourOperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourOperator
     */
    select?: TourOperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourOperatorInclude<ExtArgs> | null
  }


  /**
   * Model Festival
   */

  export type AggregateFestival = {
    _count: FestivalCountAggregateOutputType | null
    _avg: FestivalAvgAggregateOutputType | null
    _sum: FestivalSumAggregateOutputType | null
    _min: FestivalMinAggregateOutputType | null
    _max: FestivalMaxAggregateOutputType | null
  }

  export type FestivalAvgAggregateOutputType = {
    id: number | null
  }

  export type FestivalSumAggregateOutputType = {
    id: number | null
  }

  export type FestivalMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    dates: string | null
    duration: string | null
    significance: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FestivalMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    dates: string | null
    duration: string | null
    significance: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FestivalCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    dates: number
    duration: number
    significance: number
    activities: number
    imageUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FestivalAvgAggregateInputType = {
    id?: true
  }

  export type FestivalSumAggregateInputType = {
    id?: true
  }

  export type FestivalMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    dates?: true
    duration?: true
    significance?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FestivalMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    dates?: true
    duration?: true
    significance?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FestivalCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    dates?: true
    duration?: true
    significance?: true
    activities?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FestivalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Festival to aggregate.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Festivals
    **/
    _count?: true | FestivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FestivalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FestivalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FestivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FestivalMaxAggregateInputType
  }

  export type GetFestivalAggregateType<T extends FestivalAggregateArgs> = {
        [P in keyof T & keyof AggregateFestival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFestival[P]>
      : GetScalarType<T[P], AggregateFestival[P]>
  }




  export type FestivalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalWhereInput
    orderBy?: FestivalOrderByWithAggregationInput | FestivalOrderByWithAggregationInput[]
    by: FestivalScalarFieldEnum[] | FestivalScalarFieldEnum
    having?: FestivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FestivalCountAggregateInputType | true
    _avg?: FestivalAvgAggregateInputType
    _sum?: FestivalSumAggregateInputType
    _min?: FestivalMinAggregateInputType
    _max?: FestivalMaxAggregateInputType
  }

  export type FestivalGroupByOutputType = {
    id: number
    name: string
    description: string | null
    location: string | null
    dates: string | null
    duration: string | null
    significance: string | null
    activities: string[]
    imageUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FestivalCountAggregateOutputType | null
    _avg: FestivalAvgAggregateOutputType | null
    _sum: FestivalSumAggregateOutputType | null
    _min: FestivalMinAggregateOutputType | null
    _max: FestivalMaxAggregateOutputType | null
  }

  type GetFestivalGroupByPayload<T extends FestivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FestivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FestivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FestivalGroupByOutputType[P]>
            : GetScalarType<T[P], FestivalGroupByOutputType[P]>
        }
      >
    >


  export type FestivalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    dates?: boolean
    duration?: boolean
    significance?: boolean
    activities?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourFestivals?: boolean | Festival$tourFestivalsArgs<ExtArgs>
    festivalBookings?: boolean | Festival$festivalBookingsArgs<ExtArgs>
    _count?: boolean | FestivalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festival"]>

  export type FestivalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    dates?: boolean
    duration?: boolean
    significance?: boolean
    activities?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["festival"]>

  export type FestivalSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    dates?: boolean
    duration?: boolean
    significance?: boolean
    activities?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FestivalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourFestivals?: boolean | Festival$tourFestivalsArgs<ExtArgs>
    festivalBookings?: boolean | Festival$festivalBookingsArgs<ExtArgs>
    _count?: boolean | FestivalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FestivalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FestivalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Festival"
    objects: {
      tourFestivals: Prisma.$TourFestivalPayload<ExtArgs>[]
      festivalBookings: Prisma.$FestivalBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      location: string | null
      dates: string | null
      duration: string | null
      significance: string | null
      activities: string[]
      imageUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["festival"]>
    composites: {}
  }

  type FestivalGetPayload<S extends boolean | null | undefined | FestivalDefaultArgs> = $Result.GetResult<Prisma.$FestivalPayload, S>

  type FestivalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FestivalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FestivalCountAggregateInputType | true
    }

  export interface FestivalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Festival'], meta: { name: 'Festival' } }
    /**
     * Find zero or one Festival that matches the filter.
     * @param {FestivalFindUniqueArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FestivalFindUniqueArgs>(args: SelectSubset<T, FestivalFindUniqueArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Festival that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FestivalFindUniqueOrThrowArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FestivalFindUniqueOrThrowArgs>(args: SelectSubset<T, FestivalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Festival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindFirstArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FestivalFindFirstArgs>(args?: SelectSubset<T, FestivalFindFirstArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Festival that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindFirstOrThrowArgs} args - Arguments to find a Festival
     * @example
     * // Get one Festival
     * const festival = await prisma.festival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FestivalFindFirstOrThrowArgs>(args?: SelectSubset<T, FestivalFindFirstOrThrowArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Festivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Festivals
     * const festivals = await prisma.festival.findMany()
     * 
     * // Get first 10 Festivals
     * const festivals = await prisma.festival.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const festivalWithIdOnly = await prisma.festival.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FestivalFindManyArgs>(args?: SelectSubset<T, FestivalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Festival.
     * @param {FestivalCreateArgs} args - Arguments to create a Festival.
     * @example
     * // Create one Festival
     * const Festival = await prisma.festival.create({
     *   data: {
     *     // ... data to create a Festival
     *   }
     * })
     * 
     */
    create<T extends FestivalCreateArgs>(args: SelectSubset<T, FestivalCreateArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Festivals.
     * @param {FestivalCreateManyArgs} args - Arguments to create many Festivals.
     * @example
     * // Create many Festivals
     * const festival = await prisma.festival.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FestivalCreateManyArgs>(args?: SelectSubset<T, FestivalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Festivals and returns the data saved in the database.
     * @param {FestivalCreateManyAndReturnArgs} args - Arguments to create many Festivals.
     * @example
     * // Create many Festivals
     * const festival = await prisma.festival.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Festivals and only return the `id`
     * const festivalWithIdOnly = await prisma.festival.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FestivalCreateManyAndReturnArgs>(args?: SelectSubset<T, FestivalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Festival.
     * @param {FestivalDeleteArgs} args - Arguments to delete one Festival.
     * @example
     * // Delete one Festival
     * const Festival = await prisma.festival.delete({
     *   where: {
     *     // ... filter to delete one Festival
     *   }
     * })
     * 
     */
    delete<T extends FestivalDeleteArgs>(args: SelectSubset<T, FestivalDeleteArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Festival.
     * @param {FestivalUpdateArgs} args - Arguments to update one Festival.
     * @example
     * // Update one Festival
     * const festival = await prisma.festival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FestivalUpdateArgs>(args: SelectSubset<T, FestivalUpdateArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Festivals.
     * @param {FestivalDeleteManyArgs} args - Arguments to filter Festivals to delete.
     * @example
     * // Delete a few Festivals
     * const { count } = await prisma.festival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FestivalDeleteManyArgs>(args?: SelectSubset<T, FestivalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Festivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Festivals
     * const festival = await prisma.festival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FestivalUpdateManyArgs>(args: SelectSubset<T, FestivalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Festival.
     * @param {FestivalUpsertArgs} args - Arguments to update or create a Festival.
     * @example
     * // Update or create a Festival
     * const festival = await prisma.festival.upsert({
     *   create: {
     *     // ... data to create a Festival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Festival we want to update
     *   }
     * })
     */
    upsert<T extends FestivalUpsertArgs>(args: SelectSubset<T, FestivalUpsertArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Festivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalCountArgs} args - Arguments to filter Festivals to count.
     * @example
     * // Count the number of Festivals
     * const count = await prisma.festival.count({
     *   where: {
     *     // ... the filter for the Festivals we want to count
     *   }
     * })
    **/
    count<T extends FestivalCountArgs>(
      args?: Subset<T, FestivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FestivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Festival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FestivalAggregateArgs>(args: Subset<T, FestivalAggregateArgs>): Prisma.PrismaPromise<GetFestivalAggregateType<T>>

    /**
     * Group by Festival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FestivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FestivalGroupByArgs['orderBy'] }
        : { orderBy?: FestivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FestivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFestivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Festival model
   */
  readonly fields: FestivalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Festival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FestivalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tourFestivals<T extends Festival$tourFestivalsArgs<ExtArgs> = {}>(args?: Subset<T, Festival$tourFestivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findMany"> | Null>
    festivalBookings<T extends Festival$festivalBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Festival$festivalBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Festival model
   */ 
  interface FestivalFieldRefs {
    readonly id: FieldRef<"Festival", 'Int'>
    readonly name: FieldRef<"Festival", 'String'>
    readonly description: FieldRef<"Festival", 'String'>
    readonly location: FieldRef<"Festival", 'String'>
    readonly dates: FieldRef<"Festival", 'String'>
    readonly duration: FieldRef<"Festival", 'String'>
    readonly significance: FieldRef<"Festival", 'String'>
    readonly activities: FieldRef<"Festival", 'String[]'>
    readonly imageUrl: FieldRef<"Festival", 'String'>
    readonly isActive: FieldRef<"Festival", 'Boolean'>
    readonly createdAt: FieldRef<"Festival", 'DateTime'>
    readonly updatedAt: FieldRef<"Festival", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Festival findUnique
   */
  export type FestivalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival findUniqueOrThrow
   */
  export type FestivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival findFirst
   */
  export type FestivalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Festivals.
     */
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival findFirstOrThrow
   */
  export type FestivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festival to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Festivals.
     */
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival findMany
   */
  export type FestivalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter, which Festivals to fetch.
     */
    where?: FestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Festivals to fetch.
     */
    orderBy?: FestivalOrderByWithRelationInput | FestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Festivals.
     */
    cursor?: FestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Festivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Festivals.
     */
    skip?: number
    distinct?: FestivalScalarFieldEnum | FestivalScalarFieldEnum[]
  }

  /**
   * Festival create
   */
  export type FestivalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The data needed to create a Festival.
     */
    data: XOR<FestivalCreateInput, FestivalUncheckedCreateInput>
  }

  /**
   * Festival createMany
   */
  export type FestivalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Festivals.
     */
    data: FestivalCreateManyInput | FestivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Festival createManyAndReturn
   */
  export type FestivalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Festivals.
     */
    data: FestivalCreateManyInput | FestivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Festival update
   */
  export type FestivalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The data needed to update a Festival.
     */
    data: XOR<FestivalUpdateInput, FestivalUncheckedUpdateInput>
    /**
     * Choose, which Festival to update.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival updateMany
   */
  export type FestivalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Festivals.
     */
    data: XOR<FestivalUpdateManyMutationInput, FestivalUncheckedUpdateManyInput>
    /**
     * Filter which Festivals to update
     */
    where?: FestivalWhereInput
  }

  /**
   * Festival upsert
   */
  export type FestivalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * The filter to search for the Festival to update in case it exists.
     */
    where: FestivalWhereUniqueInput
    /**
     * In case the Festival found by the `where` argument doesn't exist, create a new Festival with this data.
     */
    create: XOR<FestivalCreateInput, FestivalUncheckedCreateInput>
    /**
     * In case the Festival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FestivalUpdateInput, FestivalUncheckedUpdateInput>
  }

  /**
   * Festival delete
   */
  export type FestivalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
    /**
     * Filter which Festival to delete.
     */
    where: FestivalWhereUniqueInput
  }

  /**
   * Festival deleteMany
   */
  export type FestivalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Festivals to delete
     */
    where?: FestivalWhereInput
  }

  /**
   * Festival.tourFestivals
   */
  export type Festival$tourFestivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    where?: TourFestivalWhereInput
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    cursor?: TourFestivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourFestivalScalarFieldEnum | TourFestivalScalarFieldEnum[]
  }

  /**
   * Festival.festivalBookings
   */
  export type Festival$festivalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    where?: FestivalBookingWhereInput
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    cursor?: FestivalBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * Festival without action
   */
  export type FestivalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Festival
     */
    select?: FestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalInclude<ExtArgs> | null
  }


  /**
   * Model FestivalBooking
   */

  export type AggregateFestivalBooking = {
    _count: FestivalBookingCountAggregateOutputType | null
    _avg: FestivalBookingAvgAggregateOutputType | null
    _sum: FestivalBookingSumAggregateOutputType | null
    _min: FestivalBookingMinAggregateOutputType | null
    _max: FestivalBookingMaxAggregateOutputType | null
  }

  export type FestivalBookingAvgAggregateOutputType = {
    id: number | null
    festivalId: number | null
    numberOfTickets: number | null
    totalAmount: number | null
  }

  export type FestivalBookingSumAggregateOutputType = {
    id: number | null
    festivalId: number | null
    numberOfTickets: number | null
    totalAmount: number | null
  }

  export type FestivalBookingMinAggregateOutputType = {
    id: number | null
    festivalId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    numberOfTickets: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FestivalBookingMaxAggregateOutputType = {
    id: number | null
    festivalId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    numberOfTickets: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FestivalBookingCountAggregateOutputType = {
    id: number
    festivalId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    numberOfTickets: number
    totalAmount: number
    specialRequests: number
    status: number
    createdAt: number
    _all: number
  }


  export type FestivalBookingAvgAggregateInputType = {
    id?: true
    festivalId?: true
    numberOfTickets?: true
    totalAmount?: true
  }

  export type FestivalBookingSumAggregateInputType = {
    id?: true
    festivalId?: true
    numberOfTickets?: true
    totalAmount?: true
  }

  export type FestivalBookingMinAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type FestivalBookingMaxAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
  }

  export type FestivalBookingCountAggregateInputType = {
    id?: true
    festivalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    numberOfTickets?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FestivalBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FestivalBooking to aggregate.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FestivalBookings
    **/
    _count?: true | FestivalBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FestivalBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FestivalBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FestivalBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FestivalBookingMaxAggregateInputType
  }

  export type GetFestivalBookingAggregateType<T extends FestivalBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateFestivalBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFestivalBooking[P]>
      : GetScalarType<T[P], AggregateFestivalBooking[P]>
  }




  export type FestivalBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FestivalBookingWhereInput
    orderBy?: FestivalBookingOrderByWithAggregationInput | FestivalBookingOrderByWithAggregationInput[]
    by: FestivalBookingScalarFieldEnum[] | FestivalBookingScalarFieldEnum
    having?: FestivalBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FestivalBookingCountAggregateInputType | true
    _avg?: FestivalBookingAvgAggregateInputType
    _sum?: FestivalBookingSumAggregateInputType
    _min?: FestivalBookingMinAggregateInputType
    _max?: FestivalBookingMaxAggregateInputType
  }

  export type FestivalBookingGroupByOutputType = {
    id: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests: string | null
    status: string
    createdAt: Date
    _count: FestivalBookingCountAggregateOutputType | null
    _avg: FestivalBookingAvgAggregateOutputType | null
    _sum: FestivalBookingSumAggregateOutputType | null
    _min: FestivalBookingMinAggregateOutputType | null
    _max: FestivalBookingMaxAggregateOutputType | null
  }

  type GetFestivalBookingGroupByPayload<T extends FestivalBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FestivalBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FestivalBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FestivalBookingGroupByOutputType[P]>
            : GetScalarType<T[P], FestivalBookingGroupByOutputType[P]>
        }
      >
    >


  export type FestivalBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festivalBooking"]>

  export type FestivalBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["festivalBooking"]>

  export type FestivalBookingSelectScalar = {
    id?: boolean
    festivalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    numberOfTickets?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FestivalBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }
  export type FestivalBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }

  export type $FestivalBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FestivalBooking"
    objects: {
      festival: Prisma.$FestivalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      festivalId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      numberOfTickets: number
      totalAmount: number
      specialRequests: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["festivalBooking"]>
    composites: {}
  }

  type FestivalBookingGetPayload<S extends boolean | null | undefined | FestivalBookingDefaultArgs> = $Result.GetResult<Prisma.$FestivalBookingPayload, S>

  type FestivalBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FestivalBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FestivalBookingCountAggregateInputType | true
    }

  export interface FestivalBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FestivalBooking'], meta: { name: 'FestivalBooking' } }
    /**
     * Find zero or one FestivalBooking that matches the filter.
     * @param {FestivalBookingFindUniqueArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FestivalBookingFindUniqueArgs>(args: SelectSubset<T, FestivalBookingFindUniqueArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FestivalBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FestivalBookingFindUniqueOrThrowArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FestivalBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, FestivalBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FestivalBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindFirstArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FestivalBookingFindFirstArgs>(args?: SelectSubset<T, FestivalBookingFindFirstArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FestivalBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindFirstOrThrowArgs} args - Arguments to find a FestivalBooking
     * @example
     * // Get one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FestivalBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, FestivalBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FestivalBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FestivalBookings
     * const festivalBookings = await prisma.festivalBooking.findMany()
     * 
     * // Get first 10 FestivalBookings
     * const festivalBookings = await prisma.festivalBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const festivalBookingWithIdOnly = await prisma.festivalBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FestivalBookingFindManyArgs>(args?: SelectSubset<T, FestivalBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FestivalBooking.
     * @param {FestivalBookingCreateArgs} args - Arguments to create a FestivalBooking.
     * @example
     * // Create one FestivalBooking
     * const FestivalBooking = await prisma.festivalBooking.create({
     *   data: {
     *     // ... data to create a FestivalBooking
     *   }
     * })
     * 
     */
    create<T extends FestivalBookingCreateArgs>(args: SelectSubset<T, FestivalBookingCreateArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FestivalBookings.
     * @param {FestivalBookingCreateManyArgs} args - Arguments to create many FestivalBookings.
     * @example
     * // Create many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FestivalBookingCreateManyArgs>(args?: SelectSubset<T, FestivalBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FestivalBookings and returns the data saved in the database.
     * @param {FestivalBookingCreateManyAndReturnArgs} args - Arguments to create many FestivalBookings.
     * @example
     * // Create many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FestivalBookings and only return the `id`
     * const festivalBookingWithIdOnly = await prisma.festivalBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FestivalBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, FestivalBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FestivalBooking.
     * @param {FestivalBookingDeleteArgs} args - Arguments to delete one FestivalBooking.
     * @example
     * // Delete one FestivalBooking
     * const FestivalBooking = await prisma.festivalBooking.delete({
     *   where: {
     *     // ... filter to delete one FestivalBooking
     *   }
     * })
     * 
     */
    delete<T extends FestivalBookingDeleteArgs>(args: SelectSubset<T, FestivalBookingDeleteArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FestivalBooking.
     * @param {FestivalBookingUpdateArgs} args - Arguments to update one FestivalBooking.
     * @example
     * // Update one FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FestivalBookingUpdateArgs>(args: SelectSubset<T, FestivalBookingUpdateArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FestivalBookings.
     * @param {FestivalBookingDeleteManyArgs} args - Arguments to filter FestivalBookings to delete.
     * @example
     * // Delete a few FestivalBookings
     * const { count } = await prisma.festivalBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FestivalBookingDeleteManyArgs>(args?: SelectSubset<T, FestivalBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FestivalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FestivalBookings
     * const festivalBooking = await prisma.festivalBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FestivalBookingUpdateManyArgs>(args: SelectSubset<T, FestivalBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FestivalBooking.
     * @param {FestivalBookingUpsertArgs} args - Arguments to update or create a FestivalBooking.
     * @example
     * // Update or create a FestivalBooking
     * const festivalBooking = await prisma.festivalBooking.upsert({
     *   create: {
     *     // ... data to create a FestivalBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FestivalBooking we want to update
     *   }
     * })
     */
    upsert<T extends FestivalBookingUpsertArgs>(args: SelectSubset<T, FestivalBookingUpsertArgs<ExtArgs>>): Prisma__FestivalBookingClient<$Result.GetResult<Prisma.$FestivalBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FestivalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingCountArgs} args - Arguments to filter FestivalBookings to count.
     * @example
     * // Count the number of FestivalBookings
     * const count = await prisma.festivalBooking.count({
     *   where: {
     *     // ... the filter for the FestivalBookings we want to count
     *   }
     * })
    **/
    count<T extends FestivalBookingCountArgs>(
      args?: Subset<T, FestivalBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FestivalBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FestivalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FestivalBookingAggregateArgs>(args: Subset<T, FestivalBookingAggregateArgs>): Prisma.PrismaPromise<GetFestivalBookingAggregateType<T>>

    /**
     * Group by FestivalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FestivalBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FestivalBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FestivalBookingGroupByArgs['orderBy'] }
        : { orderBy?: FestivalBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FestivalBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFestivalBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FestivalBooking model
   */
  readonly fields: FestivalBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FestivalBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FestivalBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    festival<T extends FestivalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FestivalDefaultArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FestivalBooking model
   */ 
  interface FestivalBookingFieldRefs {
    readonly id: FieldRef<"FestivalBooking", 'Int'>
    readonly festivalId: FieldRef<"FestivalBooking", 'Int'>
    readonly firstName: FieldRef<"FestivalBooking", 'String'>
    readonly lastName: FieldRef<"FestivalBooking", 'String'>
    readonly email: FieldRef<"FestivalBooking", 'String'>
    readonly phone: FieldRef<"FestivalBooking", 'String'>
    readonly numberOfTickets: FieldRef<"FestivalBooking", 'Int'>
    readonly totalAmount: FieldRef<"FestivalBooking", 'Int'>
    readonly specialRequests: FieldRef<"FestivalBooking", 'String'>
    readonly status: FieldRef<"FestivalBooking", 'String'>
    readonly createdAt: FieldRef<"FestivalBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FestivalBooking findUnique
   */
  export type FestivalBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking findUniqueOrThrow
   */
  export type FestivalBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking findFirst
   */
  export type FestivalBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FestivalBookings.
     */
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking findFirstOrThrow
   */
  export type FestivalBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBooking to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FestivalBookings.
     */
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking findMany
   */
  export type FestivalBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter, which FestivalBookings to fetch.
     */
    where?: FestivalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FestivalBookings to fetch.
     */
    orderBy?: FestivalBookingOrderByWithRelationInput | FestivalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FestivalBookings.
     */
    cursor?: FestivalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FestivalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FestivalBookings.
     */
    skip?: number
    distinct?: FestivalBookingScalarFieldEnum | FestivalBookingScalarFieldEnum[]
  }

  /**
   * FestivalBooking create
   */
  export type FestivalBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a FestivalBooking.
     */
    data: XOR<FestivalBookingCreateInput, FestivalBookingUncheckedCreateInput>
  }

  /**
   * FestivalBooking createMany
   */
  export type FestivalBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FestivalBookings.
     */
    data: FestivalBookingCreateManyInput | FestivalBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FestivalBooking createManyAndReturn
   */
  export type FestivalBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FestivalBookings.
     */
    data: FestivalBookingCreateManyInput | FestivalBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FestivalBooking update
   */
  export type FestivalBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a FestivalBooking.
     */
    data: XOR<FestivalBookingUpdateInput, FestivalBookingUncheckedUpdateInput>
    /**
     * Choose, which FestivalBooking to update.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking updateMany
   */
  export type FestivalBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FestivalBookings.
     */
    data: XOR<FestivalBookingUpdateManyMutationInput, FestivalBookingUncheckedUpdateManyInput>
    /**
     * Filter which FestivalBookings to update
     */
    where?: FestivalBookingWhereInput
  }

  /**
   * FestivalBooking upsert
   */
  export type FestivalBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the FestivalBooking to update in case it exists.
     */
    where: FestivalBookingWhereUniqueInput
    /**
     * In case the FestivalBooking found by the `where` argument doesn't exist, create a new FestivalBooking with this data.
     */
    create: XOR<FestivalBookingCreateInput, FestivalBookingUncheckedCreateInput>
    /**
     * In case the FestivalBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FestivalBookingUpdateInput, FestivalBookingUncheckedUpdateInput>
  }

  /**
   * FestivalBooking delete
   */
  export type FestivalBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
    /**
     * Filter which FestivalBooking to delete.
     */
    where: FestivalBookingWhereUniqueInput
  }

  /**
   * FestivalBooking deleteMany
   */
  export type FestivalBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FestivalBookings to delete
     */
    where?: FestivalBookingWhereInput
  }

  /**
   * FestivalBooking without action
   */
  export type FestivalBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FestivalBooking
     */
    select?: FestivalBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FestivalBookingInclude<ExtArgs> | null
  }


  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    id: number | null
    starRating: number | null
    pricePerNight: number | null
  }

  export type HotelSumAggregateOutputType = {
    id: number | null
    starRating: number | null
    pricePerNight: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    address: string | null
    imageUrl: string | null
    categoryId: string | null
    starRating: number | null
    pricePerNight: number | null
    isActive: boolean | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    location: string | null
    address: string | null
    imageUrl: string | null
    categoryId: string | null
    starRating: number | null
    pricePerNight: number | null
    isActive: boolean | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: string | null
    createdAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    address: number
    imageUrl: number
    images: number
    categoryId: number
    starRating: number
    amenities: number
    features: number
    pricePerNight: number
    isActive: number
    contactEmail: number
    contactPhone: number
    website: number
    checkInTime: number
    checkOutTime: number
    cancellationPolicy: number
    createdAt: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    id?: true
    starRating?: true
    pricePerNight?: true
  }

  export type HotelSumAggregateInputType = {
    id?: true
    starRating?: true
    pricePerNight?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    categoryId?: true
    starRating?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    categoryId?: true
    starRating?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    address?: true
    imageUrl?: true
    images?: true
    categoryId?: true
    starRating?: true
    amenities?: true
    features?: true
    pricePerNight?: true
    isActive?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    createdAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images: string[]
    categoryId: string
    starRating: number
    amenities: string[]
    features: string[]
    pricePerNight: number
    isActive: boolean
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    checkInTime: string
    checkOutTime: string
    cancellationPolicy: string | null
    createdAt: Date
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    category?: boolean | HotelCategoryDefaultArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
    category?: boolean | HotelCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    address?: boolean
    imageUrl?: boolean
    images?: boolean
    categoryId?: boolean
    starRating?: boolean
    amenities?: boolean
    features?: boolean
    pricePerNight?: boolean
    isActive?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    createdAt?: boolean
  }

  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | HotelCategoryDefaultArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | HotelCategoryDefaultArgs<ExtArgs>
  }

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      category: Prisma.$HotelCategoryPayload<ExtArgs>
      rooms: Prisma.$HotelRoomPayload<ExtArgs>[]
      bookings: Prisma.$HotelBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      location: string
      address: string
      imageUrl: string
      images: string[]
      categoryId: string
      starRating: number
      amenities: string[]
      features: string[]
      pricePerNight: number
      isActive: boolean
      contactEmail: string | null
      contactPhone: string | null
      website: string | null
      checkInTime: string
      checkOutTime: string
      cancellationPolicy: string | null
      createdAt: Date
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends HotelCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelCategoryDefaultArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rooms<T extends Hotel$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Hotel$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */ 
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'Int'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly description: FieldRef<"Hotel", 'String'>
    readonly location: FieldRef<"Hotel", 'String'>
    readonly address: FieldRef<"Hotel", 'String'>
    readonly imageUrl: FieldRef<"Hotel", 'String'>
    readonly images: FieldRef<"Hotel", 'String[]'>
    readonly categoryId: FieldRef<"Hotel", 'String'>
    readonly starRating: FieldRef<"Hotel", 'Int'>
    readonly amenities: FieldRef<"Hotel", 'String[]'>
    readonly features: FieldRef<"Hotel", 'String[]'>
    readonly pricePerNight: FieldRef<"Hotel", 'Int'>
    readonly isActive: FieldRef<"Hotel", 'Boolean'>
    readonly contactEmail: FieldRef<"Hotel", 'String'>
    readonly contactPhone: FieldRef<"Hotel", 'String'>
    readonly website: FieldRef<"Hotel", 'String'>
    readonly checkInTime: FieldRef<"Hotel", 'String'>
    readonly checkOutTime: FieldRef<"Hotel", 'String'>
    readonly cancellationPolicy: FieldRef<"Hotel", 'String'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel.rooms
   */
  export type Hotel$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    where?: HotelRoomWhereInput
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    cursor?: HotelRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * Hotel.bookings
   */
  export type Hotel$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model HotelRoom
   */

  export type AggregateHotelRoom = {
    _count: HotelRoomCountAggregateOutputType | null
    _avg: HotelRoomAvgAggregateOutputType | null
    _sum: HotelRoomSumAggregateOutputType | null
    _min: HotelRoomMinAggregateOutputType | null
    _max: HotelRoomMaxAggregateOutputType | null
  }

  export type HotelRoomAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxOccupancy: number | null
    pricePerNight: number | null
    totalRooms: number | null
  }

  export type HotelRoomSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxOccupancy: number | null
    pricePerNight: number | null
    totalRooms: number | null
  }

  export type HotelRoomMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomType: string | null
    roomName: string | null
    description: string | null
    imageUrl: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    pricePerNight: number | null
    totalRooms: number | null
    isActive: boolean | null
  }

  export type HotelRoomMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomType: string | null
    roomName: string | null
    description: string | null
    imageUrl: string | null
    maxOccupancy: number | null
    bedType: string | null
    roomSize: string | null
    pricePerNight: number | null
    totalRooms: number | null
    isActive: boolean | null
  }

  export type HotelRoomCountAggregateOutputType = {
    id: number
    hotelId: number
    roomType: number
    roomName: number
    description: number
    imageUrl: number
    images: number
    maxOccupancy: number
    bedType: number
    roomSize: number
    amenities: number
    pricePerNight: number
    totalRooms: number
    isActive: number
    _all: number
  }


  export type HotelRoomAvgAggregateInputType = {
    id?: true
    hotelId?: true
    maxOccupancy?: true
    pricePerNight?: true
    totalRooms?: true
  }

  export type HotelRoomSumAggregateInputType = {
    id?: true
    hotelId?: true
    maxOccupancy?: true
    pricePerNight?: true
    totalRooms?: true
  }

  export type HotelRoomMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
  }

  export type HotelRoomMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
  }

  export type HotelRoomCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomType?: true
    roomName?: true
    description?: true
    imageUrl?: true
    images?: true
    maxOccupancy?: true
    bedType?: true
    roomSize?: true
    amenities?: true
    pricePerNight?: true
    totalRooms?: true
    isActive?: true
    _all?: true
  }

  export type HotelRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRoom to aggregate.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelRooms
    **/
    _count?: true | HotelRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelRoomMaxAggregateInputType
  }

  export type GetHotelRoomAggregateType<T extends HotelRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelRoom[P]>
      : GetScalarType<T[P], AggregateHotelRoom[P]>
  }




  export type HotelRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelRoomWhereInput
    orderBy?: HotelRoomOrderByWithAggregationInput | HotelRoomOrderByWithAggregationInput[]
    by: HotelRoomScalarFieldEnum[] | HotelRoomScalarFieldEnum
    having?: HotelRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelRoomCountAggregateInputType | true
    _avg?: HotelRoomAvgAggregateInputType
    _sum?: HotelRoomSumAggregateInputType
    _min?: HotelRoomMinAggregateInputType
    _max?: HotelRoomMaxAggregateInputType
  }

  export type HotelRoomGroupByOutputType = {
    id: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images: string[]
    maxOccupancy: number
    bedType: string
    roomSize: string | null
    amenities: string[]
    pricePerNight: number
    totalRooms: number
    isActive: boolean
    _count: HotelRoomCountAggregateOutputType | null
    _avg: HotelRoomAvgAggregateOutputType | null
    _sum: HotelRoomSumAggregateOutputType | null
    _min: HotelRoomMinAggregateOutputType | null
    _max: HotelRoomMaxAggregateOutputType | null
  }

  type GetHotelRoomGroupByPayload<T extends HotelRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelRoomGroupByOutputType[P]>
            : GetScalarType<T[P], HotelRoomGroupByOutputType[P]>
        }
      >
    >


  export type HotelRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    bookings?: boolean | HotelRoom$bookingsArgs<ExtArgs>
    _count?: boolean | HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRoom"]>

  export type HotelRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelRoom"]>

  export type HotelRoomSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomType?: boolean
    roomName?: boolean
    description?: boolean
    imageUrl?: boolean
    images?: boolean
    maxOccupancy?: boolean
    bedType?: boolean
    roomSize?: boolean
    amenities?: boolean
    pricePerNight?: boolean
    totalRooms?: boolean
    isActive?: boolean
  }

  export type HotelRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    bookings?: boolean | HotelRoom$bookingsArgs<ExtArgs>
    _count?: boolean | HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $HotelRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelRoom"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      bookings: Prisma.$HotelBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      roomType: string
      roomName: string
      description: string
      imageUrl: string
      images: string[]
      maxOccupancy: number
      bedType: string
      roomSize: string | null
      amenities: string[]
      pricePerNight: number
      totalRooms: number
      isActive: boolean
    }, ExtArgs["result"]["hotelRoom"]>
    composites: {}
  }

  type HotelRoomGetPayload<S extends boolean | null | undefined | HotelRoomDefaultArgs> = $Result.GetResult<Prisma.$HotelRoomPayload, S>

  type HotelRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelRoomCountAggregateInputType | true
    }

  export interface HotelRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelRoom'], meta: { name: 'HotelRoom' } }
    /**
     * Find zero or one HotelRoom that matches the filter.
     * @param {HotelRoomFindUniqueArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelRoomFindUniqueArgs>(args: SelectSubset<T, HotelRoomFindUniqueArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelRoomFindUniqueOrThrowArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindFirstArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelRoomFindFirstArgs>(args?: SelectSubset<T, HotelRoomFindFirstArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindFirstOrThrowArgs} args - Arguments to find a HotelRoom
     * @example
     * // Get one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelRooms
     * const hotelRooms = await prisma.hotelRoom.findMany()
     * 
     * // Get first 10 HotelRooms
     * const hotelRooms = await prisma.hotelRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelRoomWithIdOnly = await prisma.hotelRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelRoomFindManyArgs>(args?: SelectSubset<T, HotelRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelRoom.
     * @param {HotelRoomCreateArgs} args - Arguments to create a HotelRoom.
     * @example
     * // Create one HotelRoom
     * const HotelRoom = await prisma.hotelRoom.create({
     *   data: {
     *     // ... data to create a HotelRoom
     *   }
     * })
     * 
     */
    create<T extends HotelRoomCreateArgs>(args: SelectSubset<T, HotelRoomCreateArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelRooms.
     * @param {HotelRoomCreateManyArgs} args - Arguments to create many HotelRooms.
     * @example
     * // Create many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelRoomCreateManyArgs>(args?: SelectSubset<T, HotelRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelRooms and returns the data saved in the database.
     * @param {HotelRoomCreateManyAndReturnArgs} args - Arguments to create many HotelRooms.
     * @example
     * // Create many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelRooms and only return the `id`
     * const hotelRoomWithIdOnly = await prisma.hotelRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelRoom.
     * @param {HotelRoomDeleteArgs} args - Arguments to delete one HotelRoom.
     * @example
     * // Delete one HotelRoom
     * const HotelRoom = await prisma.hotelRoom.delete({
     *   where: {
     *     // ... filter to delete one HotelRoom
     *   }
     * })
     * 
     */
    delete<T extends HotelRoomDeleteArgs>(args: SelectSubset<T, HotelRoomDeleteArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelRoom.
     * @param {HotelRoomUpdateArgs} args - Arguments to update one HotelRoom.
     * @example
     * // Update one HotelRoom
     * const hotelRoom = await prisma.hotelRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelRoomUpdateArgs>(args: SelectSubset<T, HotelRoomUpdateArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelRooms.
     * @param {HotelRoomDeleteManyArgs} args - Arguments to filter HotelRooms to delete.
     * @example
     * // Delete a few HotelRooms
     * const { count } = await prisma.hotelRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelRoomDeleteManyArgs>(args?: SelectSubset<T, HotelRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelRooms
     * const hotelRoom = await prisma.hotelRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelRoomUpdateManyArgs>(args: SelectSubset<T, HotelRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelRoom.
     * @param {HotelRoomUpsertArgs} args - Arguments to update or create a HotelRoom.
     * @example
     * // Update or create a HotelRoom
     * const hotelRoom = await prisma.hotelRoom.upsert({
     *   create: {
     *     // ... data to create a HotelRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelRoom we want to update
     *   }
     * })
     */
    upsert<T extends HotelRoomUpsertArgs>(args: SelectSubset<T, HotelRoomUpsertArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomCountArgs} args - Arguments to filter HotelRooms to count.
     * @example
     * // Count the number of HotelRooms
     * const count = await prisma.hotelRoom.count({
     *   where: {
     *     // ... the filter for the HotelRooms we want to count
     *   }
     * })
    **/
    count<T extends HotelRoomCountArgs>(
      args?: Subset<T, HotelRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelRoomAggregateArgs>(args: Subset<T, HotelRoomAggregateArgs>): Prisma.PrismaPromise<GetHotelRoomAggregateType<T>>

    /**
     * Group by HotelRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelRoomGroupByArgs['orderBy'] }
        : { orderBy?: HotelRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelRoom model
   */
  readonly fields: HotelRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends HotelRoom$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, HotelRoom$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelRoom model
   */ 
  interface HotelRoomFieldRefs {
    readonly id: FieldRef<"HotelRoom", 'Int'>
    readonly hotelId: FieldRef<"HotelRoom", 'Int'>
    readonly roomType: FieldRef<"HotelRoom", 'String'>
    readonly roomName: FieldRef<"HotelRoom", 'String'>
    readonly description: FieldRef<"HotelRoom", 'String'>
    readonly imageUrl: FieldRef<"HotelRoom", 'String'>
    readonly images: FieldRef<"HotelRoom", 'String[]'>
    readonly maxOccupancy: FieldRef<"HotelRoom", 'Int'>
    readonly bedType: FieldRef<"HotelRoom", 'String'>
    readonly roomSize: FieldRef<"HotelRoom", 'String'>
    readonly amenities: FieldRef<"HotelRoom", 'String[]'>
    readonly pricePerNight: FieldRef<"HotelRoom", 'Int'>
    readonly totalRooms: FieldRef<"HotelRoom", 'Int'>
    readonly isActive: FieldRef<"HotelRoom", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HotelRoom findUnique
   */
  export type HotelRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom findUniqueOrThrow
   */
  export type HotelRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom findFirst
   */
  export type HotelRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRooms.
     */
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom findFirstOrThrow
   */
  export type HotelRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRoom to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelRooms.
     */
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom findMany
   */
  export type HotelRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter, which HotelRooms to fetch.
     */
    where?: HotelRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelRooms to fetch.
     */
    orderBy?: HotelRoomOrderByWithRelationInput | HotelRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelRooms.
     */
    cursor?: HotelRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelRooms.
     */
    skip?: number
    distinct?: HotelRoomScalarFieldEnum | HotelRoomScalarFieldEnum[]
  }

  /**
   * HotelRoom create
   */
  export type HotelRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelRoom.
     */
    data: XOR<HotelRoomCreateInput, HotelRoomUncheckedCreateInput>
  }

  /**
   * HotelRoom createMany
   */
  export type HotelRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelRooms.
     */
    data: HotelRoomCreateManyInput | HotelRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelRoom createManyAndReturn
   */
  export type HotelRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelRooms.
     */
    data: HotelRoomCreateManyInput | HotelRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelRoom update
   */
  export type HotelRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelRoom.
     */
    data: XOR<HotelRoomUpdateInput, HotelRoomUncheckedUpdateInput>
    /**
     * Choose, which HotelRoom to update.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom updateMany
   */
  export type HotelRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelRooms.
     */
    data: XOR<HotelRoomUpdateManyMutationInput, HotelRoomUncheckedUpdateManyInput>
    /**
     * Filter which HotelRooms to update
     */
    where?: HotelRoomWhereInput
  }

  /**
   * HotelRoom upsert
   */
  export type HotelRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelRoom to update in case it exists.
     */
    where: HotelRoomWhereUniqueInput
    /**
     * In case the HotelRoom found by the `where` argument doesn't exist, create a new HotelRoom with this data.
     */
    create: XOR<HotelRoomCreateInput, HotelRoomUncheckedCreateInput>
    /**
     * In case the HotelRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelRoomUpdateInput, HotelRoomUncheckedUpdateInput>
  }

  /**
   * HotelRoom delete
   */
  export type HotelRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
    /**
     * Filter which HotelRoom to delete.
     */
    where: HotelRoomWhereUniqueInput
  }

  /**
   * HotelRoom deleteMany
   */
  export type HotelRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelRooms to delete
     */
    where?: HotelRoomWhereInput
  }

  /**
   * HotelRoom.bookings
   */
  export type HotelRoom$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    cursor?: HotelBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelRoom without action
   */
  export type HotelRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelRoom
     */
    select?: HotelRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelRoomInclude<ExtArgs> | null
  }


  /**
   * Model HotelBooking
   */

  export type AggregateHotelBooking = {
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  export type HotelBookingAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
  }

  export type HotelBookingSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
  }

  export type HotelBookingMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type HotelBookingMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    roomId: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    numberOfRooms: number | null
    numberOfGuests: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type HotelBookingCountAggregateOutputType = {
    id: number
    hotelId: number
    roomId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    checkInDate: number
    checkOutDate: number
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests: number
    status: number
    paymentStatus: number
    createdAt: number
    _all: number
  }


  export type HotelBookingAvgAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
  }

  export type HotelBookingSumAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
  }

  export type HotelBookingMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type HotelBookingMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type HotelBookingCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    checkInDate?: true
    checkOutDate?: true
    numberOfRooms?: true
    numberOfGuests?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    _all?: true
  }

  export type HotelBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBooking to aggregate.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelBookings
    **/
    _count?: true | HotelBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelBookingMaxAggregateInputType
  }

  export type GetHotelBookingAggregateType<T extends HotelBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelBooking[P]>
      : GetScalarType<T[P], AggregateHotelBooking[P]>
  }




  export type HotelBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelBookingWhereInput
    orderBy?: HotelBookingOrderByWithAggregationInput | HotelBookingOrderByWithAggregationInput[]
    by: HotelBookingScalarFieldEnum[] | HotelBookingScalarFieldEnum
    having?: HotelBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelBookingCountAggregateInputType | true
    _avg?: HotelBookingAvgAggregateInputType
    _sum?: HotelBookingSumAggregateInputType
    _min?: HotelBookingMinAggregateInputType
    _max?: HotelBookingMaxAggregateInputType
  }

  export type HotelBookingGroupByOutputType = {
    id: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone: string | null
    checkInDate: Date
    checkOutDate: Date
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests: string | null
    status: string
    paymentStatus: string
    createdAt: Date
    _count: HotelBookingCountAggregateOutputType | null
    _avg: HotelBookingAvgAggregateOutputType | null
    _sum: HotelBookingSumAggregateOutputType | null
    _min: HotelBookingMinAggregateOutputType | null
    _max: HotelBookingMaxAggregateOutputType | null
  }

  type GetHotelBookingGroupByPayload<T extends HotelBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
            : GetScalarType<T[P], HotelBookingGroupByOutputType[P]>
        }
      >
    >


  export type HotelBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelBooking"]>

  export type HotelBookingSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    numberOfRooms?: boolean
    numberOfGuests?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
  }

  export type HotelBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }
  export type HotelBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    room?: boolean | HotelRoomDefaultArgs<ExtArgs>
  }

  export type $HotelBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelBooking"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      room: Prisma.$HotelRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      roomId: number
      firstName: string
      lastName: string
      email: string
      phone: string | null
      checkInDate: Date
      checkOutDate: Date
      numberOfRooms: number
      numberOfGuests: number
      totalAmount: number
      specialRequests: string | null
      status: string
      paymentStatus: string
      createdAt: Date
    }, ExtArgs["result"]["hotelBooking"]>
    composites: {}
  }

  type HotelBookingGetPayload<S extends boolean | null | undefined | HotelBookingDefaultArgs> = $Result.GetResult<Prisma.$HotelBookingPayload, S>

  type HotelBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelBookingCountAggregateInputType | true
    }

  export interface HotelBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelBooking'], meta: { name: 'HotelBooking' } }
    /**
     * Find zero or one HotelBooking that matches the filter.
     * @param {HotelBookingFindUniqueArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelBookingFindUniqueArgs>(args: SelectSubset<T, HotelBookingFindUniqueArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelBookingFindUniqueOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelBookingFindFirstArgs>(args?: SelectSubset<T, HotelBookingFindFirstArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindFirstOrThrowArgs} args - Arguments to find a HotelBooking
     * @example
     * // Get one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany()
     * 
     * // Get first 10 HotelBookings
     * const hotelBookings = await prisma.hotelBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelBookingFindManyArgs>(args?: SelectSubset<T, HotelBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelBooking.
     * @param {HotelBookingCreateArgs} args - Arguments to create a HotelBooking.
     * @example
     * // Create one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.create({
     *   data: {
     *     // ... data to create a HotelBooking
     *   }
     * })
     * 
     */
    create<T extends HotelBookingCreateArgs>(args: SelectSubset<T, HotelBookingCreateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelBookings.
     * @param {HotelBookingCreateManyArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelBookingCreateManyArgs>(args?: SelectSubset<T, HotelBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelBookings and returns the data saved in the database.
     * @param {HotelBookingCreateManyAndReturnArgs} args - Arguments to create many HotelBookings.
     * @example
     * // Create many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelBookings and only return the `id`
     * const hotelBookingWithIdOnly = await prisma.hotelBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelBooking.
     * @param {HotelBookingDeleteArgs} args - Arguments to delete one HotelBooking.
     * @example
     * // Delete one HotelBooking
     * const HotelBooking = await prisma.hotelBooking.delete({
     *   where: {
     *     // ... filter to delete one HotelBooking
     *   }
     * })
     * 
     */
    delete<T extends HotelBookingDeleteArgs>(args: SelectSubset<T, HotelBookingDeleteArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelBooking.
     * @param {HotelBookingUpdateArgs} args - Arguments to update one HotelBooking.
     * @example
     * // Update one HotelBooking
     * const hotelBooking = await prisma.hotelBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelBookingUpdateArgs>(args: SelectSubset<T, HotelBookingUpdateArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelBookings.
     * @param {HotelBookingDeleteManyArgs} args - Arguments to filter HotelBookings to delete.
     * @example
     * // Delete a few HotelBookings
     * const { count } = await prisma.hotelBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelBookingDeleteManyArgs>(args?: SelectSubset<T, HotelBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelBookings
     * const hotelBooking = await prisma.hotelBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelBookingUpdateManyArgs>(args: SelectSubset<T, HotelBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelBooking.
     * @param {HotelBookingUpsertArgs} args - Arguments to update or create a HotelBooking.
     * @example
     * // Update or create a HotelBooking
     * const hotelBooking = await prisma.hotelBooking.upsert({
     *   create: {
     *     // ... data to create a HotelBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelBooking we want to update
     *   }
     * })
     */
    upsert<T extends HotelBookingUpsertArgs>(args: SelectSubset<T, HotelBookingUpsertArgs<ExtArgs>>): Prisma__HotelBookingClient<$Result.GetResult<Prisma.$HotelBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingCountArgs} args - Arguments to filter HotelBookings to count.
     * @example
     * // Count the number of HotelBookings
     * const count = await prisma.hotelBooking.count({
     *   where: {
     *     // ... the filter for the HotelBookings we want to count
     *   }
     * })
    **/
    count<T extends HotelBookingCountArgs>(
      args?: Subset<T, HotelBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelBookingAggregateArgs>(args: Subset<T, HotelBookingAggregateArgs>): Prisma.PrismaPromise<GetHotelBookingAggregateType<T>>

    /**
     * Group by HotelBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelBookingGroupByArgs['orderBy'] }
        : { orderBy?: HotelBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelBooking model
   */
  readonly fields: HotelBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends HotelRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelRoomDefaultArgs<ExtArgs>>): Prisma__HotelRoomClient<$Result.GetResult<Prisma.$HotelRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelBooking model
   */ 
  interface HotelBookingFieldRefs {
    readonly id: FieldRef<"HotelBooking", 'Int'>
    readonly hotelId: FieldRef<"HotelBooking", 'Int'>
    readonly roomId: FieldRef<"HotelBooking", 'Int'>
    readonly firstName: FieldRef<"HotelBooking", 'String'>
    readonly lastName: FieldRef<"HotelBooking", 'String'>
    readonly email: FieldRef<"HotelBooking", 'String'>
    readonly phone: FieldRef<"HotelBooking", 'String'>
    readonly checkInDate: FieldRef<"HotelBooking", 'DateTime'>
    readonly checkOutDate: FieldRef<"HotelBooking", 'DateTime'>
    readonly numberOfRooms: FieldRef<"HotelBooking", 'Int'>
    readonly numberOfGuests: FieldRef<"HotelBooking", 'Int'>
    readonly totalAmount: FieldRef<"HotelBooking", 'Int'>
    readonly specialRequests: FieldRef<"HotelBooking", 'String'>
    readonly status: FieldRef<"HotelBooking", 'String'>
    readonly paymentStatus: FieldRef<"HotelBooking", 'String'>
    readonly createdAt: FieldRef<"HotelBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelBooking findUnique
   */
  export type HotelBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findUniqueOrThrow
   */
  export type HotelBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking findFirst
   */
  export type HotelBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findFirstOrThrow
   */
  export type HotelBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBooking to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelBookings.
     */
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking findMany
   */
  export type HotelBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter, which HotelBookings to fetch.
     */
    where?: HotelBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelBookings to fetch.
     */
    orderBy?: HotelBookingOrderByWithRelationInput | HotelBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelBookings.
     */
    cursor?: HotelBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelBookings.
     */
    skip?: number
    distinct?: HotelBookingScalarFieldEnum | HotelBookingScalarFieldEnum[]
  }

  /**
   * HotelBooking create
   */
  export type HotelBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelBooking.
     */
    data: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
  }

  /**
   * HotelBooking createMany
   */
  export type HotelBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelBooking createManyAndReturn
   */
  export type HotelBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelBookings.
     */
    data: HotelBookingCreateManyInput | HotelBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelBooking update
   */
  export type HotelBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelBooking.
     */
    data: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
    /**
     * Choose, which HotelBooking to update.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking updateMany
   */
  export type HotelBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelBookings.
     */
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyInput>
    /**
     * Filter which HotelBookings to update
     */
    where?: HotelBookingWhereInput
  }

  /**
   * HotelBooking upsert
   */
  export type HotelBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelBooking to update in case it exists.
     */
    where: HotelBookingWhereUniqueInput
    /**
     * In case the HotelBooking found by the `where` argument doesn't exist, create a new HotelBooking with this data.
     */
    create: XOR<HotelBookingCreateInput, HotelBookingUncheckedCreateInput>
    /**
     * In case the HotelBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelBookingUpdateInput, HotelBookingUncheckedUpdateInput>
  }

  /**
   * HotelBooking delete
   */
  export type HotelBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
    /**
     * Filter which HotelBooking to delete.
     */
    where: HotelBookingWhereUniqueInput
  }

  /**
   * HotelBooking deleteMany
   */
  export type HotelBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelBookings to delete
     */
    where?: HotelBookingWhereInput
  }

  /**
   * HotelBooking without action
   */
  export type HotelBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelBooking
     */
    select?: HotelBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelBookingInclude<ExtArgs> | null
  }


  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountAvgAggregateOutputType = {
    id: number | null
  }

  export type UserAccountSumAggregateOutputType = {
    id: number | null
  }

  export type UserAccountMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    profileImage: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserAccountMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    profileImage: string | null
    createdAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserAccountCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    phone: number
    role: number
    isActive: number
    profileImage: number
    createdAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAccountAvgAggregateInputType = {
    id?: true
  }

  export type UserAccountSumAggregateInputType = {
    id?: true
  }

  export type UserAccountMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserAccountMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
  }

  export type UserAccountCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    role?: true
    isActive?: true
    profileImage?: true
    createdAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _avg?: UserAccountAvgAggregateInputType
    _sum?: UserAccountSumAggregateInputType
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone: string | null
    role: string
    isActive: boolean
    profileImage: string | null
    createdAt: Date
    lastLoginAt: Date | null
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
    feedbacks?: boolean | UserAccount$feedbacksArgs<ExtArgs>
    interests?: boolean | UserAccount$interestsArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    profileImage?: boolean
    createdAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | UserAccount$feedbacksArgs<ExtArgs>
    interests?: boolean | UserAccount$interestsArgs<ExtArgs>
    _count?: boolean | UserAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      feedbacks: Prisma.$UserFeedbackPayload<ExtArgs>[]
      interests: Prisma.$UserInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      phone: string | null
      role: string
      isActive: boolean
      profileImage: string | null
      createdAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }

  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccountFindUniqueArgs>(args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccountFindFirstArgs>(args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAccountFindManyArgs>(args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
     */
    create<T extends UserAccountCreateArgs>(args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAccounts.
     * @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccountCreateManyArgs>(args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAccounts and returns the data saved in the database.
     * @param {UserAccountCreateManyAndReturnArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAccounts and only return the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
     */
    delete<T extends UserAccountDeleteArgs>(args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccountUpdateArgs>(args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccountDeleteManyArgs>(args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccountUpdateManyArgs>(args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserAccountUpsertArgs>(args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedbacks<T extends UserAccount$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    interests<T extends UserAccount$interestsArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccount model
   */ 
  interface UserAccountFieldRefs {
    readonly id: FieldRef<"UserAccount", 'Int'>
    readonly email: FieldRef<"UserAccount", 'String'>
    readonly password: FieldRef<"UserAccount", 'String'>
    readonly firstName: FieldRef<"UserAccount", 'String'>
    readonly lastName: FieldRef<"UserAccount", 'String'>
    readonly phone: FieldRef<"UserAccount", 'String'>
    readonly role: FieldRef<"UserAccount", 'String'>
    readonly isActive: FieldRef<"UserAccount", 'Boolean'>
    readonly profileImage: FieldRef<"UserAccount", 'String'>
    readonly createdAt: FieldRef<"UserAccount", 'DateTime'>
    readonly lastLoginAt: FieldRef<"UserAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }

  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount createManyAndReturn
   */
  export type UserAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
  }

  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }

  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
  }

  /**
   * UserAccount.feedbacks
   */
  export type UserAccount$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    cursor?: UserFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserAccount.interests
   */
  export type UserAccount$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    where?: UserInterestWhereInput
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    cursor?: UserInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserFeedback
   */

  export type AggregateUserFeedback = {
    _count: UserFeedbackCountAggregateOutputType | null
    _avg: UserFeedbackAvgAggregateOutputType | null
    _sum: UserFeedbackSumAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  export type UserFeedbackAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
  }

  export type UserFeedbackSumAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
  }

  export type UserFeedbackMinAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
    comment: string | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type UserFeedbackMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    itineraryId: number | null
    tourId: number | null
    rating: number | null
    comment: string | null
    category: string | null
    isPublic: boolean | null
    createdAt: Date | null
  }

  export type UserFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    itineraryId: number
    tourId: number
    rating: number
    comment: number
    category: number
    isPublic: number
    createdAt: number
    _all: number
  }


  export type UserFeedbackAvgAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
  }

  export type UserFeedbackSumAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
  }

  export type UserFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
  }

  export type UserFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
  }

  export type UserFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    itineraryId?: true
    tourId?: true
    rating?: true
    comment?: true
    category?: true
    isPublic?: true
    createdAt?: true
    _all?: true
  }

  export type UserFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedback to aggregate.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeedbacks
    **/
    _count?: true | UserFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type GetUserFeedbackAggregateType<T extends UserFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeedback[P]>
      : GetScalarType<T[P], AggregateUserFeedback[P]>
  }




  export type UserFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeedbackWhereInput
    orderBy?: UserFeedbackOrderByWithAggregationInput | UserFeedbackOrderByWithAggregationInput[]
    by: UserFeedbackScalarFieldEnum[] | UserFeedbackScalarFieldEnum
    having?: UserFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeedbackCountAggregateInputType | true
    _avg?: UserFeedbackAvgAggregateInputType
    _sum?: UserFeedbackSumAggregateInputType
    _min?: UserFeedbackMinAggregateInputType
    _max?: UserFeedbackMaxAggregateInputType
  }

  export type UserFeedbackGroupByOutputType = {
    id: number
    userId: number
    itineraryId: number | null
    tourId: number | null
    rating: number
    comment: string | null
    category: string
    isPublic: boolean
    createdAt: Date
    _count: UserFeedbackCountAggregateOutputType | null
    _avg: UserFeedbackAvgAggregateOutputType | null
    _sum: UserFeedbackSumAggregateOutputType | null
    _min: UserFeedbackMinAggregateOutputType | null
    _max: UserFeedbackMaxAggregateOutputType | null
  }

  type GetUserFeedbackGroupByPayload<T extends UserFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type UserFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }, ExtArgs["result"]["userFeedback"]>

  export type UserFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    itineraryId?: boolean
    tourId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    isPublic?: boolean
    createdAt?: boolean
  }

  export type UserFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }
  export type UserFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    itinerary?: boolean | UserFeedback$itineraryArgs<ExtArgs>
    tour?: boolean | UserFeedback$tourArgs<ExtArgs>
  }

  export type $UserFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeedback"
    objects: {
      user: Prisma.$UserAccountPayload<ExtArgs>
      itinerary: Prisma.$ItineraryPayload<ExtArgs> | null
      tour: Prisma.$TourPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      itineraryId: number | null
      tourId: number | null
      rating: number
      comment: string | null
      category: string
      isPublic: boolean
      createdAt: Date
    }, ExtArgs["result"]["userFeedback"]>
    composites: {}
  }

  type UserFeedbackGetPayload<S extends boolean | null | undefined | UserFeedbackDefaultArgs> = $Result.GetResult<Prisma.$UserFeedbackPayload, S>

  type UserFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFeedbackCountAggregateInputType | true
    }

  export interface UserFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeedback'], meta: { name: 'UserFeedback' } }
    /**
     * Find zero or one UserFeedback that matches the filter.
     * @param {UserFeedbackFindUniqueArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeedbackFindUniqueArgs>(args: SelectSubset<T, UserFeedbackFindUniqueArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFeedbackFindUniqueOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeedbackFindFirstArgs>(args?: SelectSubset<T, UserFeedbackFindFirstArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindFirstOrThrowArgs} args - Arguments to find a UserFeedback
     * @example
     * // Get one UserFeedback
     * const userFeedback = await prisma.userFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany()
     * 
     * // Get first 10 UserFeedbacks
     * const userFeedbacks = await prisma.userFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeedbackFindManyArgs>(args?: SelectSubset<T, UserFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFeedback.
     * @param {UserFeedbackCreateArgs} args - Arguments to create a UserFeedback.
     * @example
     * // Create one UserFeedback
     * const UserFeedback = await prisma.userFeedback.create({
     *   data: {
     *     // ... data to create a UserFeedback
     *   }
     * })
     * 
     */
    create<T extends UserFeedbackCreateArgs>(args: SelectSubset<T, UserFeedbackCreateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFeedbacks.
     * @param {UserFeedbackCreateManyArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeedbackCreateManyArgs>(args?: SelectSubset<T, UserFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeedbacks and returns the data saved in the database.
     * @param {UserFeedbackCreateManyAndReturnArgs} args - Arguments to create many UserFeedbacks.
     * @example
     * // Create many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeedbacks and only return the `id`
     * const userFeedbackWithIdOnly = await prisma.userFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFeedback.
     * @param {UserFeedbackDeleteArgs} args - Arguments to delete one UserFeedback.
     * @example
     * // Delete one UserFeedback
     * const UserFeedback = await prisma.userFeedback.delete({
     *   where: {
     *     // ... filter to delete one UserFeedback
     *   }
     * })
     * 
     */
    delete<T extends UserFeedbackDeleteArgs>(args: SelectSubset<T, UserFeedbackDeleteArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFeedback.
     * @param {UserFeedbackUpdateArgs} args - Arguments to update one UserFeedback.
     * @example
     * // Update one UserFeedback
     * const userFeedback = await prisma.userFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeedbackUpdateArgs>(args: SelectSubset<T, UserFeedbackUpdateArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFeedbacks.
     * @param {UserFeedbackDeleteManyArgs} args - Arguments to filter UserFeedbacks to delete.
     * @example
     * // Delete a few UserFeedbacks
     * const { count } = await prisma.userFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeedbackDeleteManyArgs>(args?: SelectSubset<T, UserFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeedbacks
     * const userFeedback = await prisma.userFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeedbackUpdateManyArgs>(args: SelectSubset<T, UserFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFeedback.
     * @param {UserFeedbackUpsertArgs} args - Arguments to update or create a UserFeedback.
     * @example
     * // Update or create a UserFeedback
     * const userFeedback = await prisma.userFeedback.upsert({
     *   create: {
     *     // ... data to create a UserFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeedback we want to update
     *   }
     * })
     */
    upsert<T extends UserFeedbackUpsertArgs>(args: SelectSubset<T, UserFeedbackUpsertArgs<ExtArgs>>): Prisma__UserFeedbackClient<$Result.GetResult<Prisma.$UserFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackCountArgs} args - Arguments to filter UserFeedbacks to count.
     * @example
     * // Count the number of UserFeedbacks
     * const count = await prisma.userFeedback.count({
     *   where: {
     *     // ... the filter for the UserFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends UserFeedbackCountArgs>(
      args?: Subset<T, UserFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeedbackAggregateArgs>(args: Subset<T, UserFeedbackAggregateArgs>): Prisma.PrismaPromise<GetUserFeedbackAggregateType<T>>

    /**
     * Group by UserFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: UserFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeedback model
   */
  readonly fields: UserFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAccountDefaultArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    itinerary<T extends UserFeedback$itineraryArgs<ExtArgs> = {}>(args?: Subset<T, UserFeedback$itineraryArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tour<T extends UserFeedback$tourArgs<ExtArgs> = {}>(args?: Subset<T, UserFeedback$tourArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeedback model
   */ 
  interface UserFeedbackFieldRefs {
    readonly id: FieldRef<"UserFeedback", 'Int'>
    readonly userId: FieldRef<"UserFeedback", 'Int'>
    readonly itineraryId: FieldRef<"UserFeedback", 'Int'>
    readonly tourId: FieldRef<"UserFeedback", 'Int'>
    readonly rating: FieldRef<"UserFeedback", 'Int'>
    readonly comment: FieldRef<"UserFeedback", 'String'>
    readonly category: FieldRef<"UserFeedback", 'String'>
    readonly isPublic: FieldRef<"UserFeedback", 'Boolean'>
    readonly createdAt: FieldRef<"UserFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeedback findUnique
   */
  export type UserFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findUniqueOrThrow
   */
  export type UserFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback findFirst
   */
  export type UserFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findFirstOrThrow
   */
  export type UserFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedback to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeedbacks.
     */
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback findMany
   */
  export type UserFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which UserFeedbacks to fetch.
     */
    where?: UserFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeedbacks to fetch.
     */
    orderBy?: UserFeedbackOrderByWithRelationInput | UserFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeedbacks.
     */
    cursor?: UserFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeedbacks.
     */
    skip?: number
    distinct?: UserFeedbackScalarFieldEnum | UserFeedbackScalarFieldEnum[]
  }

  /**
   * UserFeedback create
   */
  export type UserFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeedback.
     */
    data: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
  }

  /**
   * UserFeedback createMany
   */
  export type UserFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeedback createManyAndReturn
   */
  export type UserFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFeedbacks.
     */
    data: UserFeedbackCreateManyInput | UserFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeedback update
   */
  export type UserFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeedback.
     */
    data: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
    /**
     * Choose, which UserFeedback to update.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback updateMany
   */
  export type UserFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeedbacks.
     */
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which UserFeedbacks to update
     */
    where?: UserFeedbackWhereInput
  }

  /**
   * UserFeedback upsert
   */
  export type UserFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeedback to update in case it exists.
     */
    where: UserFeedbackWhereUniqueInput
    /**
     * In case the UserFeedback found by the `where` argument doesn't exist, create a new UserFeedback with this data.
     */
    create: XOR<UserFeedbackCreateInput, UserFeedbackUncheckedCreateInput>
    /**
     * In case the UserFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeedbackUpdateInput, UserFeedbackUncheckedUpdateInput>
  }

  /**
   * UserFeedback delete
   */
  export type UserFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
    /**
     * Filter which UserFeedback to delete.
     */
    where: UserFeedbackWhereUniqueInput
  }

  /**
   * UserFeedback deleteMany
   */
  export type UserFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeedbacks to delete
     */
    where?: UserFeedbackWhereInput
  }

  /**
   * UserFeedback.itinerary
   */
  export type UserFeedback$itineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
  }

  /**
   * UserFeedback.tour
   */
  export type UserFeedback$tourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
  }

  /**
   * UserFeedback without action
   */
  export type UserFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeedback
     */
    select?: UserFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model TourCategory
   */

  export type AggregateTourCategory = {
    _count: TourCategoryCountAggregateOutputType | null
    _avg: TourCategoryAvgAggregateOutputType | null
    _sum: TourCategorySumAggregateOutputType | null
    _min: TourCategoryMinAggregateOutputType | null
    _max: TourCategoryMaxAggregateOutputType | null
  }

  export type TourCategoryAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TourCategorySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TourCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TourCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TourCategoryCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    description: number
    isActive: number
    displayOrder: number
    _all: number
  }


  export type TourCategoryAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TourCategorySumAggregateInputType = {
    displayOrder?: true
  }

  export type TourCategoryMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type TourCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type TourCategoryCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
    _all?: true
  }

  export type TourCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourCategory to aggregate.
     */
    where?: TourCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourCategories to fetch.
     */
    orderBy?: TourCategoryOrderByWithRelationInput | TourCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourCategories
    **/
    _count?: true | TourCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourCategoryMaxAggregateInputType
  }

  export type GetTourCategoryAggregateType<T extends TourCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTourCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourCategory[P]>
      : GetScalarType<T[P], AggregateTourCategory[P]>
  }




  export type TourCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourCategoryWhereInput
    orderBy?: TourCategoryOrderByWithAggregationInput | TourCategoryOrderByWithAggregationInput[]
    by: TourCategoryScalarFieldEnum[] | TourCategoryScalarFieldEnum
    having?: TourCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCategoryCountAggregateInputType | true
    _avg?: TourCategoryAvgAggregateInputType
    _sum?: TourCategorySumAggregateInputType
    _min?: TourCategoryMinAggregateInputType
    _max?: TourCategoryMaxAggregateInputType
  }

  export type TourCategoryGroupByOutputType = {
    id: string
    name: string
    icon: string
    description: string
    isActive: boolean
    displayOrder: number | null
    _count: TourCategoryCountAggregateOutputType | null
    _avg: TourCategoryAvgAggregateOutputType | null
    _sum: TourCategorySumAggregateOutputType | null
    _min: TourCategoryMinAggregateOutputType | null
    _max: TourCategoryMaxAggregateOutputType | null
  }

  type GetTourCategoryGroupByPayload<T extends TourCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TourCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TourCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["tourCategory"]>

  export type TourCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["tourCategory"]>

  export type TourCategorySelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }


  export type $TourCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourCategory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      description: string
      isActive: boolean
      displayOrder: number | null
    }, ExtArgs["result"]["tourCategory"]>
    composites: {}
  }

  type TourCategoryGetPayload<S extends boolean | null | undefined | TourCategoryDefaultArgs> = $Result.GetResult<Prisma.$TourCategoryPayload, S>

  type TourCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourCategoryCountAggregateInputType | true
    }

  export interface TourCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourCategory'], meta: { name: 'TourCategory' } }
    /**
     * Find zero or one TourCategory that matches the filter.
     * @param {TourCategoryFindUniqueArgs} args - Arguments to find a TourCategory
     * @example
     * // Get one TourCategory
     * const tourCategory = await prisma.tourCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourCategoryFindUniqueArgs>(args: SelectSubset<T, TourCategoryFindUniqueArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourCategoryFindUniqueOrThrowArgs} args - Arguments to find a TourCategory
     * @example
     * // Get one TourCategory
     * const tourCategory = await prisma.tourCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TourCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryFindFirstArgs} args - Arguments to find a TourCategory
     * @example
     * // Get one TourCategory
     * const tourCategory = await prisma.tourCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourCategoryFindFirstArgs>(args?: SelectSubset<T, TourCategoryFindFirstArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryFindFirstOrThrowArgs} args - Arguments to find a TourCategory
     * @example
     * // Get one TourCategory
     * const tourCategory = await prisma.tourCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TourCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourCategories
     * const tourCategories = await prisma.tourCategory.findMany()
     * 
     * // Get first 10 TourCategories
     * const tourCategories = await prisma.tourCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourCategoryWithIdOnly = await prisma.tourCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourCategoryFindManyArgs>(args?: SelectSubset<T, TourCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourCategory.
     * @param {TourCategoryCreateArgs} args - Arguments to create a TourCategory.
     * @example
     * // Create one TourCategory
     * const TourCategory = await prisma.tourCategory.create({
     *   data: {
     *     // ... data to create a TourCategory
     *   }
     * })
     * 
     */
    create<T extends TourCategoryCreateArgs>(args: SelectSubset<T, TourCategoryCreateArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourCategories.
     * @param {TourCategoryCreateManyArgs} args - Arguments to create many TourCategories.
     * @example
     * // Create many TourCategories
     * const tourCategory = await prisma.tourCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCategoryCreateManyArgs>(args?: SelectSubset<T, TourCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourCategories and returns the data saved in the database.
     * @param {TourCategoryCreateManyAndReturnArgs} args - Arguments to create many TourCategories.
     * @example
     * // Create many TourCategories
     * const tourCategory = await prisma.tourCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourCategories and only return the `id`
     * const tourCategoryWithIdOnly = await prisma.tourCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TourCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TourCategory.
     * @param {TourCategoryDeleteArgs} args - Arguments to delete one TourCategory.
     * @example
     * // Delete one TourCategory
     * const TourCategory = await prisma.tourCategory.delete({
     *   where: {
     *     // ... filter to delete one TourCategory
     *   }
     * })
     * 
     */
    delete<T extends TourCategoryDeleteArgs>(args: SelectSubset<T, TourCategoryDeleteArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourCategory.
     * @param {TourCategoryUpdateArgs} args - Arguments to update one TourCategory.
     * @example
     * // Update one TourCategory
     * const tourCategory = await prisma.tourCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourCategoryUpdateArgs>(args: SelectSubset<T, TourCategoryUpdateArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourCategories.
     * @param {TourCategoryDeleteManyArgs} args - Arguments to filter TourCategories to delete.
     * @example
     * // Delete a few TourCategories
     * const { count } = await prisma.tourCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourCategoryDeleteManyArgs>(args?: SelectSubset<T, TourCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourCategories
     * const tourCategory = await prisma.tourCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourCategoryUpdateManyArgs>(args: SelectSubset<T, TourCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourCategory.
     * @param {TourCategoryUpsertArgs} args - Arguments to update or create a TourCategory.
     * @example
     * // Update or create a TourCategory
     * const tourCategory = await prisma.tourCategory.upsert({
     *   create: {
     *     // ... data to create a TourCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourCategory we want to update
     *   }
     * })
     */
    upsert<T extends TourCategoryUpsertArgs>(args: SelectSubset<T, TourCategoryUpsertArgs<ExtArgs>>): Prisma__TourCategoryClient<$Result.GetResult<Prisma.$TourCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TourCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryCountArgs} args - Arguments to filter TourCategories to count.
     * @example
     * // Count the number of TourCategories
     * const count = await prisma.tourCategory.count({
     *   where: {
     *     // ... the filter for the TourCategories we want to count
     *   }
     * })
    **/
    count<T extends TourCategoryCountArgs>(
      args?: Subset<T, TourCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourCategoryAggregateArgs>(args: Subset<T, TourCategoryAggregateArgs>): Prisma.PrismaPromise<GetTourCategoryAggregateType<T>>

    /**
     * Group by TourCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TourCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourCategory model
   */
  readonly fields: TourCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourCategory model
   */ 
  interface TourCategoryFieldRefs {
    readonly id: FieldRef<"TourCategory", 'String'>
    readonly name: FieldRef<"TourCategory", 'String'>
    readonly icon: FieldRef<"TourCategory", 'String'>
    readonly description: FieldRef<"TourCategory", 'String'>
    readonly isActive: FieldRef<"TourCategory", 'Boolean'>
    readonly displayOrder: FieldRef<"TourCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TourCategory findUnique
   */
  export type TourCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter, which TourCategory to fetch.
     */
    where: TourCategoryWhereUniqueInput
  }

  /**
   * TourCategory findUniqueOrThrow
   */
  export type TourCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter, which TourCategory to fetch.
     */
    where: TourCategoryWhereUniqueInput
  }

  /**
   * TourCategory findFirst
   */
  export type TourCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter, which TourCategory to fetch.
     */
    where?: TourCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourCategories to fetch.
     */
    orderBy?: TourCategoryOrderByWithRelationInput | TourCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourCategories.
     */
    cursor?: TourCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourCategories.
     */
    distinct?: TourCategoryScalarFieldEnum | TourCategoryScalarFieldEnum[]
  }

  /**
   * TourCategory findFirstOrThrow
   */
  export type TourCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter, which TourCategory to fetch.
     */
    where?: TourCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourCategories to fetch.
     */
    orderBy?: TourCategoryOrderByWithRelationInput | TourCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourCategories.
     */
    cursor?: TourCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourCategories.
     */
    distinct?: TourCategoryScalarFieldEnum | TourCategoryScalarFieldEnum[]
  }

  /**
   * TourCategory findMany
   */
  export type TourCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter, which TourCategories to fetch.
     */
    where?: TourCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourCategories to fetch.
     */
    orderBy?: TourCategoryOrderByWithRelationInput | TourCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourCategories.
     */
    cursor?: TourCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourCategories.
     */
    skip?: number
    distinct?: TourCategoryScalarFieldEnum | TourCategoryScalarFieldEnum[]
  }

  /**
   * TourCategory create
   */
  export type TourCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * The data needed to create a TourCategory.
     */
    data: XOR<TourCategoryCreateInput, TourCategoryUncheckedCreateInput>
  }

  /**
   * TourCategory createMany
   */
  export type TourCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourCategories.
     */
    data: TourCategoryCreateManyInput | TourCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourCategory createManyAndReturn
   */
  export type TourCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TourCategories.
     */
    data: TourCategoryCreateManyInput | TourCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourCategory update
   */
  export type TourCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * The data needed to update a TourCategory.
     */
    data: XOR<TourCategoryUpdateInput, TourCategoryUncheckedUpdateInput>
    /**
     * Choose, which TourCategory to update.
     */
    where: TourCategoryWhereUniqueInput
  }

  /**
   * TourCategory updateMany
   */
  export type TourCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourCategories.
     */
    data: XOR<TourCategoryUpdateManyMutationInput, TourCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TourCategories to update
     */
    where?: TourCategoryWhereInput
  }

  /**
   * TourCategory upsert
   */
  export type TourCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * The filter to search for the TourCategory to update in case it exists.
     */
    where: TourCategoryWhereUniqueInput
    /**
     * In case the TourCategory found by the `where` argument doesn't exist, create a new TourCategory with this data.
     */
    create: XOR<TourCategoryCreateInput, TourCategoryUncheckedCreateInput>
    /**
     * In case the TourCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourCategoryUpdateInput, TourCategoryUncheckedUpdateInput>
  }

  /**
   * TourCategory delete
   */
  export type TourCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
    /**
     * Filter which TourCategory to delete.
     */
    where: TourCategoryWhereUniqueInput
  }

  /**
   * TourCategory deleteMany
   */
  export type TourCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourCategories to delete
     */
    where?: TourCategoryWhereInput
  }

  /**
   * TourCategory without action
   */
  export type TourCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCategory
     */
    select?: TourCategorySelect<ExtArgs> | null
  }


  /**
   * Model HotelCategory
   */

  export type AggregateHotelCategory = {
    _count: HotelCategoryCountAggregateOutputType | null
    _avg: HotelCategoryAvgAggregateOutputType | null
    _sum: HotelCategorySumAggregateOutputType | null
    _min: HotelCategoryMinAggregateOutputType | null
    _max: HotelCategoryMaxAggregateOutputType | null
  }

  export type HotelCategoryAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type HotelCategorySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type HotelCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type HotelCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type HotelCategoryCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    description: number
    isActive: number
    displayOrder: number
    _all: number
  }


  export type HotelCategoryAvgAggregateInputType = {
    displayOrder?: true
  }

  export type HotelCategorySumAggregateInputType = {
    displayOrder?: true
  }

  export type HotelCategoryMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type HotelCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type HotelCategoryCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    isActive?: true
    displayOrder?: true
    _all?: true
  }

  export type HotelCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCategory to aggregate.
     */
    where?: HotelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCategories to fetch.
     */
    orderBy?: HotelCategoryOrderByWithRelationInput | HotelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelCategories
    **/
    _count?: true | HotelCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelCategoryMaxAggregateInputType
  }

  export type GetHotelCategoryAggregateType<T extends HotelCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelCategory[P]>
      : GetScalarType<T[P], AggregateHotelCategory[P]>
  }




  export type HotelCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelCategoryWhereInput
    orderBy?: HotelCategoryOrderByWithAggregationInput | HotelCategoryOrderByWithAggregationInput[]
    by: HotelCategoryScalarFieldEnum[] | HotelCategoryScalarFieldEnum
    having?: HotelCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCategoryCountAggregateInputType | true
    _avg?: HotelCategoryAvgAggregateInputType
    _sum?: HotelCategorySumAggregateInputType
    _min?: HotelCategoryMinAggregateInputType
    _max?: HotelCategoryMaxAggregateInputType
  }

  export type HotelCategoryGroupByOutputType = {
    id: string
    name: string
    icon: string
    description: string
    isActive: boolean
    displayOrder: number | null
    _count: HotelCategoryCountAggregateOutputType | null
    _avg: HotelCategoryAvgAggregateOutputType | null
    _sum: HotelCategorySumAggregateOutputType | null
    _min: HotelCategoryMinAggregateOutputType | null
    _max: HotelCategoryMaxAggregateOutputType | null
  }

  type GetHotelCategoryGroupByPayload<T extends HotelCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], HotelCategoryGroupByOutputType[P]>
        }
      >
    >


  export type HotelCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
    hotels?: boolean | HotelCategory$hotelsArgs<ExtArgs>
    _count?: boolean | HotelCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelCategory"]>

  export type HotelCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["hotelCategory"]>

  export type HotelCategorySelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }

  export type HotelCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | HotelCategory$hotelsArgs<ExtArgs>
    _count?: boolean | HotelCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelCategory"
    objects: {
      hotels: Prisma.$HotelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      description: string
      isActive: boolean
      displayOrder: number | null
    }, ExtArgs["result"]["hotelCategory"]>
    composites: {}
  }

  type HotelCategoryGetPayload<S extends boolean | null | undefined | HotelCategoryDefaultArgs> = $Result.GetResult<Prisma.$HotelCategoryPayload, S>

  type HotelCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelCategoryCountAggregateInputType | true
    }

  export interface HotelCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelCategory'], meta: { name: 'HotelCategory' } }
    /**
     * Find zero or one HotelCategory that matches the filter.
     * @param {HotelCategoryFindUniqueArgs} args - Arguments to find a HotelCategory
     * @example
     * // Get one HotelCategory
     * const hotelCategory = await prisma.hotelCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelCategoryFindUniqueArgs>(args: SelectSubset<T, HotelCategoryFindUniqueArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelCategoryFindUniqueOrThrowArgs} args - Arguments to find a HotelCategory
     * @example
     * // Get one HotelCategory
     * const hotelCategory = await prisma.hotelCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryFindFirstArgs} args - Arguments to find a HotelCategory
     * @example
     * // Get one HotelCategory
     * const hotelCategory = await prisma.hotelCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelCategoryFindFirstArgs>(args?: SelectSubset<T, HotelCategoryFindFirstArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryFindFirstOrThrowArgs} args - Arguments to find a HotelCategory
     * @example
     * // Get one HotelCategory
     * const hotelCategory = await prisma.hotelCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelCategories
     * const hotelCategories = await prisma.hotelCategory.findMany()
     * 
     * // Get first 10 HotelCategories
     * const hotelCategories = await prisma.hotelCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelCategoryWithIdOnly = await prisma.hotelCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelCategoryFindManyArgs>(args?: SelectSubset<T, HotelCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelCategory.
     * @param {HotelCategoryCreateArgs} args - Arguments to create a HotelCategory.
     * @example
     * // Create one HotelCategory
     * const HotelCategory = await prisma.hotelCategory.create({
     *   data: {
     *     // ... data to create a HotelCategory
     *   }
     * })
     * 
     */
    create<T extends HotelCategoryCreateArgs>(args: SelectSubset<T, HotelCategoryCreateArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelCategories.
     * @param {HotelCategoryCreateManyArgs} args - Arguments to create many HotelCategories.
     * @example
     * // Create many HotelCategories
     * const hotelCategory = await prisma.hotelCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCategoryCreateManyArgs>(args?: SelectSubset<T, HotelCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelCategories and returns the data saved in the database.
     * @param {HotelCategoryCreateManyAndReturnArgs} args - Arguments to create many HotelCategories.
     * @example
     * // Create many HotelCategories
     * const hotelCategory = await prisma.hotelCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelCategories and only return the `id`
     * const hotelCategoryWithIdOnly = await prisma.hotelCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelCategory.
     * @param {HotelCategoryDeleteArgs} args - Arguments to delete one HotelCategory.
     * @example
     * // Delete one HotelCategory
     * const HotelCategory = await prisma.hotelCategory.delete({
     *   where: {
     *     // ... filter to delete one HotelCategory
     *   }
     * })
     * 
     */
    delete<T extends HotelCategoryDeleteArgs>(args: SelectSubset<T, HotelCategoryDeleteArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelCategory.
     * @param {HotelCategoryUpdateArgs} args - Arguments to update one HotelCategory.
     * @example
     * // Update one HotelCategory
     * const hotelCategory = await prisma.hotelCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelCategoryUpdateArgs>(args: SelectSubset<T, HotelCategoryUpdateArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelCategories.
     * @param {HotelCategoryDeleteManyArgs} args - Arguments to filter HotelCategories to delete.
     * @example
     * // Delete a few HotelCategories
     * const { count } = await prisma.hotelCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelCategoryDeleteManyArgs>(args?: SelectSubset<T, HotelCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelCategories
     * const hotelCategory = await prisma.hotelCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelCategoryUpdateManyArgs>(args: SelectSubset<T, HotelCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelCategory.
     * @param {HotelCategoryUpsertArgs} args - Arguments to update or create a HotelCategory.
     * @example
     * // Update or create a HotelCategory
     * const hotelCategory = await prisma.hotelCategory.upsert({
     *   create: {
     *     // ... data to create a HotelCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelCategory we want to update
     *   }
     * })
     */
    upsert<T extends HotelCategoryUpsertArgs>(args: SelectSubset<T, HotelCategoryUpsertArgs<ExtArgs>>): Prisma__HotelCategoryClient<$Result.GetResult<Prisma.$HotelCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryCountArgs} args - Arguments to filter HotelCategories to count.
     * @example
     * // Count the number of HotelCategories
     * const count = await prisma.hotelCategory.count({
     *   where: {
     *     // ... the filter for the HotelCategories we want to count
     *   }
     * })
    **/
    count<T extends HotelCategoryCountArgs>(
      args?: Subset<T, HotelCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelCategoryAggregateArgs>(args: Subset<T, HotelCategoryAggregateArgs>): Prisma.PrismaPromise<GetHotelCategoryAggregateType<T>>

    /**
     * Group by HotelCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelCategoryGroupByArgs['orderBy'] }
        : { orderBy?: HotelCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelCategory model
   */
  readonly fields: HotelCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotels<T extends HotelCategory$hotelsArgs<ExtArgs> = {}>(args?: Subset<T, HotelCategory$hotelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelCategory model
   */ 
  interface HotelCategoryFieldRefs {
    readonly id: FieldRef<"HotelCategory", 'String'>
    readonly name: FieldRef<"HotelCategory", 'String'>
    readonly icon: FieldRef<"HotelCategory", 'String'>
    readonly description: FieldRef<"HotelCategory", 'String'>
    readonly isActive: FieldRef<"HotelCategory", 'Boolean'>
    readonly displayOrder: FieldRef<"HotelCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HotelCategory findUnique
   */
  export type HotelCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HotelCategory to fetch.
     */
    where: HotelCategoryWhereUniqueInput
  }

  /**
   * HotelCategory findUniqueOrThrow
   */
  export type HotelCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HotelCategory to fetch.
     */
    where: HotelCategoryWhereUniqueInput
  }

  /**
   * HotelCategory findFirst
   */
  export type HotelCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HotelCategory to fetch.
     */
    where?: HotelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCategories to fetch.
     */
    orderBy?: HotelCategoryOrderByWithRelationInput | HotelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCategories.
     */
    cursor?: HotelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCategories.
     */
    distinct?: HotelCategoryScalarFieldEnum | HotelCategoryScalarFieldEnum[]
  }

  /**
   * HotelCategory findFirstOrThrow
   */
  export type HotelCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HotelCategory to fetch.
     */
    where?: HotelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCategories to fetch.
     */
    orderBy?: HotelCategoryOrderByWithRelationInput | HotelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelCategories.
     */
    cursor?: HotelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelCategories.
     */
    distinct?: HotelCategoryScalarFieldEnum | HotelCategoryScalarFieldEnum[]
  }

  /**
   * HotelCategory findMany
   */
  export type HotelCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HotelCategories to fetch.
     */
    where?: HotelCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelCategories to fetch.
     */
    orderBy?: HotelCategoryOrderByWithRelationInput | HotelCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelCategories.
     */
    cursor?: HotelCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelCategories.
     */
    skip?: number
    distinct?: HotelCategoryScalarFieldEnum | HotelCategoryScalarFieldEnum[]
  }

  /**
   * HotelCategory create
   */
  export type HotelCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelCategory.
     */
    data: XOR<HotelCategoryCreateInput, HotelCategoryUncheckedCreateInput>
  }

  /**
   * HotelCategory createMany
   */
  export type HotelCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelCategories.
     */
    data: HotelCategoryCreateManyInput | HotelCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelCategory createManyAndReturn
   */
  export type HotelCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelCategories.
     */
    data: HotelCategoryCreateManyInput | HotelCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelCategory update
   */
  export type HotelCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelCategory.
     */
    data: XOR<HotelCategoryUpdateInput, HotelCategoryUncheckedUpdateInput>
    /**
     * Choose, which HotelCategory to update.
     */
    where: HotelCategoryWhereUniqueInput
  }

  /**
   * HotelCategory updateMany
   */
  export type HotelCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelCategories.
     */
    data: XOR<HotelCategoryUpdateManyMutationInput, HotelCategoryUncheckedUpdateManyInput>
    /**
     * Filter which HotelCategories to update
     */
    where?: HotelCategoryWhereInput
  }

  /**
   * HotelCategory upsert
   */
  export type HotelCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelCategory to update in case it exists.
     */
    where: HotelCategoryWhereUniqueInput
    /**
     * In case the HotelCategory found by the `where` argument doesn't exist, create a new HotelCategory with this data.
     */
    create: XOR<HotelCategoryCreateInput, HotelCategoryUncheckedCreateInput>
    /**
     * In case the HotelCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelCategoryUpdateInput, HotelCategoryUncheckedUpdateInput>
  }

  /**
   * HotelCategory delete
   */
  export type HotelCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
    /**
     * Filter which HotelCategory to delete.
     */
    where: HotelCategoryWhereUniqueInput
  }

  /**
   * HotelCategory deleteMany
   */
  export type HotelCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelCategories to delete
     */
    where?: HotelCategoryWhereInput
  }

  /**
   * HotelCategory.hotels
   */
  export type HotelCategory$hotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    cursor?: HotelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * HotelCategory without action
   */
  export type HotelCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCategory
     */
    select?: HotelCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelCategoryInclude<ExtArgs> | null
  }


  /**
   * Model TravelActivity
   */

  export type AggregateTravelActivity = {
    _count: TravelActivityCountAggregateOutputType | null
    _avg: TravelActivityAvgAggregateOutputType | null
    _sum: TravelActivitySumAggregateOutputType | null
    _min: TravelActivityMinAggregateOutputType | null
    _max: TravelActivityMaxAggregateOutputType | null
  }

  export type TravelActivityAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TravelActivitySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TravelActivityMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    difficulty: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TravelActivityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    difficulty: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TravelActivityCountAggregateOutputType = {
    id: number
    name: number
    category: number
    difficulty: number
    isActive: number
    displayOrder: number
    _all: number
  }


  export type TravelActivityAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TravelActivitySumAggregateInputType = {
    displayOrder?: true
  }

  export type TravelActivityMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    difficulty?: true
    isActive?: true
    displayOrder?: true
  }

  export type TravelActivityMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    difficulty?: true
    isActive?: true
    displayOrder?: true
  }

  export type TravelActivityCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    difficulty?: true
    isActive?: true
    displayOrder?: true
    _all?: true
  }

  export type TravelActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelActivity to aggregate.
     */
    where?: TravelActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelActivities to fetch.
     */
    orderBy?: TravelActivityOrderByWithRelationInput | TravelActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TravelActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TravelActivities
    **/
    _count?: true | TravelActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TravelActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TravelActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TravelActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TravelActivityMaxAggregateInputType
  }

  export type GetTravelActivityAggregateType<T extends TravelActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateTravelActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTravelActivity[P]>
      : GetScalarType<T[P], AggregateTravelActivity[P]>
  }




  export type TravelActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelActivityWhereInput
    orderBy?: TravelActivityOrderByWithAggregationInput | TravelActivityOrderByWithAggregationInput[]
    by: TravelActivityScalarFieldEnum[] | TravelActivityScalarFieldEnum
    having?: TravelActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TravelActivityCountAggregateInputType | true
    _avg?: TravelActivityAvgAggregateInputType
    _sum?: TravelActivitySumAggregateInputType
    _min?: TravelActivityMinAggregateInputType
    _max?: TravelActivityMaxAggregateInputType
  }

  export type TravelActivityGroupByOutputType = {
    id: string
    name: string
    category: string
    difficulty: string
    isActive: boolean
    displayOrder: number | null
    _count: TravelActivityCountAggregateOutputType | null
    _avg: TravelActivityAvgAggregateOutputType | null
    _sum: TravelActivitySumAggregateOutputType | null
    _min: TravelActivityMinAggregateOutputType | null
    _max: TravelActivityMaxAggregateOutputType | null
  }

  type GetTravelActivityGroupByPayload<T extends TravelActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TravelActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TravelActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TravelActivityGroupByOutputType[P]>
            : GetScalarType<T[P], TravelActivityGroupByOutputType[P]>
        }
      >
    >


  export type TravelActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    difficulty?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["travelActivity"]>

  export type TravelActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    difficulty?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["travelActivity"]>

  export type TravelActivitySelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    difficulty?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }


  export type $TravelActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TravelActivity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      difficulty: string
      isActive: boolean
      displayOrder: number | null
    }, ExtArgs["result"]["travelActivity"]>
    composites: {}
  }

  type TravelActivityGetPayload<S extends boolean | null | undefined | TravelActivityDefaultArgs> = $Result.GetResult<Prisma.$TravelActivityPayload, S>

  type TravelActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TravelActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TravelActivityCountAggregateInputType | true
    }

  export interface TravelActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TravelActivity'], meta: { name: 'TravelActivity' } }
    /**
     * Find zero or one TravelActivity that matches the filter.
     * @param {TravelActivityFindUniqueArgs} args - Arguments to find a TravelActivity
     * @example
     * // Get one TravelActivity
     * const travelActivity = await prisma.travelActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TravelActivityFindUniqueArgs>(args: SelectSubset<T, TravelActivityFindUniqueArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TravelActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TravelActivityFindUniqueOrThrowArgs} args - Arguments to find a TravelActivity
     * @example
     * // Get one TravelActivity
     * const travelActivity = await prisma.travelActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TravelActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, TravelActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TravelActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityFindFirstArgs} args - Arguments to find a TravelActivity
     * @example
     * // Get one TravelActivity
     * const travelActivity = await prisma.travelActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TravelActivityFindFirstArgs>(args?: SelectSubset<T, TravelActivityFindFirstArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TravelActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityFindFirstOrThrowArgs} args - Arguments to find a TravelActivity
     * @example
     * // Get one TravelActivity
     * const travelActivity = await prisma.travelActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TravelActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, TravelActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TravelActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TravelActivities
     * const travelActivities = await prisma.travelActivity.findMany()
     * 
     * // Get first 10 TravelActivities
     * const travelActivities = await prisma.travelActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const travelActivityWithIdOnly = await prisma.travelActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TravelActivityFindManyArgs>(args?: SelectSubset<T, TravelActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TravelActivity.
     * @param {TravelActivityCreateArgs} args - Arguments to create a TravelActivity.
     * @example
     * // Create one TravelActivity
     * const TravelActivity = await prisma.travelActivity.create({
     *   data: {
     *     // ... data to create a TravelActivity
     *   }
     * })
     * 
     */
    create<T extends TravelActivityCreateArgs>(args: SelectSubset<T, TravelActivityCreateArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TravelActivities.
     * @param {TravelActivityCreateManyArgs} args - Arguments to create many TravelActivities.
     * @example
     * // Create many TravelActivities
     * const travelActivity = await prisma.travelActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TravelActivityCreateManyArgs>(args?: SelectSubset<T, TravelActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TravelActivities and returns the data saved in the database.
     * @param {TravelActivityCreateManyAndReturnArgs} args - Arguments to create many TravelActivities.
     * @example
     * // Create many TravelActivities
     * const travelActivity = await prisma.travelActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TravelActivities and only return the `id`
     * const travelActivityWithIdOnly = await prisma.travelActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TravelActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, TravelActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TravelActivity.
     * @param {TravelActivityDeleteArgs} args - Arguments to delete one TravelActivity.
     * @example
     * // Delete one TravelActivity
     * const TravelActivity = await prisma.travelActivity.delete({
     *   where: {
     *     // ... filter to delete one TravelActivity
     *   }
     * })
     * 
     */
    delete<T extends TravelActivityDeleteArgs>(args: SelectSubset<T, TravelActivityDeleteArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TravelActivity.
     * @param {TravelActivityUpdateArgs} args - Arguments to update one TravelActivity.
     * @example
     * // Update one TravelActivity
     * const travelActivity = await prisma.travelActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TravelActivityUpdateArgs>(args: SelectSubset<T, TravelActivityUpdateArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TravelActivities.
     * @param {TravelActivityDeleteManyArgs} args - Arguments to filter TravelActivities to delete.
     * @example
     * // Delete a few TravelActivities
     * const { count } = await prisma.travelActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TravelActivityDeleteManyArgs>(args?: SelectSubset<T, TravelActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TravelActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TravelActivities
     * const travelActivity = await prisma.travelActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TravelActivityUpdateManyArgs>(args: SelectSubset<T, TravelActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TravelActivity.
     * @param {TravelActivityUpsertArgs} args - Arguments to update or create a TravelActivity.
     * @example
     * // Update or create a TravelActivity
     * const travelActivity = await prisma.travelActivity.upsert({
     *   create: {
     *     // ... data to create a TravelActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TravelActivity we want to update
     *   }
     * })
     */
    upsert<T extends TravelActivityUpsertArgs>(args: SelectSubset<T, TravelActivityUpsertArgs<ExtArgs>>): Prisma__TravelActivityClient<$Result.GetResult<Prisma.$TravelActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TravelActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityCountArgs} args - Arguments to filter TravelActivities to count.
     * @example
     * // Count the number of TravelActivities
     * const count = await prisma.travelActivity.count({
     *   where: {
     *     // ... the filter for the TravelActivities we want to count
     *   }
     * })
    **/
    count<T extends TravelActivityCountArgs>(
      args?: Subset<T, TravelActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TravelActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TravelActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TravelActivityAggregateArgs>(args: Subset<T, TravelActivityAggregateArgs>): Prisma.PrismaPromise<GetTravelActivityAggregateType<T>>

    /**
     * Group by TravelActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TravelActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TravelActivityGroupByArgs['orderBy'] }
        : { orderBy?: TravelActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TravelActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTravelActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TravelActivity model
   */
  readonly fields: TravelActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TravelActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TravelActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TravelActivity model
   */ 
  interface TravelActivityFieldRefs {
    readonly id: FieldRef<"TravelActivity", 'String'>
    readonly name: FieldRef<"TravelActivity", 'String'>
    readonly category: FieldRef<"TravelActivity", 'String'>
    readonly difficulty: FieldRef<"TravelActivity", 'String'>
    readonly isActive: FieldRef<"TravelActivity", 'Boolean'>
    readonly displayOrder: FieldRef<"TravelActivity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TravelActivity findUnique
   */
  export type TravelActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter, which TravelActivity to fetch.
     */
    where: TravelActivityWhereUniqueInput
  }

  /**
   * TravelActivity findUniqueOrThrow
   */
  export type TravelActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter, which TravelActivity to fetch.
     */
    where: TravelActivityWhereUniqueInput
  }

  /**
   * TravelActivity findFirst
   */
  export type TravelActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter, which TravelActivity to fetch.
     */
    where?: TravelActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelActivities to fetch.
     */
    orderBy?: TravelActivityOrderByWithRelationInput | TravelActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelActivities.
     */
    cursor?: TravelActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelActivities.
     */
    distinct?: TravelActivityScalarFieldEnum | TravelActivityScalarFieldEnum[]
  }

  /**
   * TravelActivity findFirstOrThrow
   */
  export type TravelActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter, which TravelActivity to fetch.
     */
    where?: TravelActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelActivities to fetch.
     */
    orderBy?: TravelActivityOrderByWithRelationInput | TravelActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelActivities.
     */
    cursor?: TravelActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelActivities.
     */
    distinct?: TravelActivityScalarFieldEnum | TravelActivityScalarFieldEnum[]
  }

  /**
   * TravelActivity findMany
   */
  export type TravelActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter, which TravelActivities to fetch.
     */
    where?: TravelActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelActivities to fetch.
     */
    orderBy?: TravelActivityOrderByWithRelationInput | TravelActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TravelActivities.
     */
    cursor?: TravelActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelActivities.
     */
    skip?: number
    distinct?: TravelActivityScalarFieldEnum | TravelActivityScalarFieldEnum[]
  }

  /**
   * TravelActivity create
   */
  export type TravelActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * The data needed to create a TravelActivity.
     */
    data: XOR<TravelActivityCreateInput, TravelActivityUncheckedCreateInput>
  }

  /**
   * TravelActivity createMany
   */
  export type TravelActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TravelActivities.
     */
    data: TravelActivityCreateManyInput | TravelActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TravelActivity createManyAndReturn
   */
  export type TravelActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TravelActivities.
     */
    data: TravelActivityCreateManyInput | TravelActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TravelActivity update
   */
  export type TravelActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * The data needed to update a TravelActivity.
     */
    data: XOR<TravelActivityUpdateInput, TravelActivityUncheckedUpdateInput>
    /**
     * Choose, which TravelActivity to update.
     */
    where: TravelActivityWhereUniqueInput
  }

  /**
   * TravelActivity updateMany
   */
  export type TravelActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TravelActivities.
     */
    data: XOR<TravelActivityUpdateManyMutationInput, TravelActivityUncheckedUpdateManyInput>
    /**
     * Filter which TravelActivities to update
     */
    where?: TravelActivityWhereInput
  }

  /**
   * TravelActivity upsert
   */
  export type TravelActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * The filter to search for the TravelActivity to update in case it exists.
     */
    where: TravelActivityWhereUniqueInput
    /**
     * In case the TravelActivity found by the `where` argument doesn't exist, create a new TravelActivity with this data.
     */
    create: XOR<TravelActivityCreateInput, TravelActivityUncheckedCreateInput>
    /**
     * In case the TravelActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TravelActivityUpdateInput, TravelActivityUncheckedUpdateInput>
  }

  /**
   * TravelActivity delete
   */
  export type TravelActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
    /**
     * Filter which TravelActivity to delete.
     */
    where: TravelActivityWhereUniqueInput
  }

  /**
   * TravelActivity deleteMany
   */
  export type TravelActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelActivities to delete
     */
    where?: TravelActivityWhereInput
  }

  /**
   * TravelActivity without action
   */
  export type TravelActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelActivity
     */
    select?: TravelActivitySelect<ExtArgs> | null
  }


  /**
   * Model TravelInterest
   */

  export type AggregateTravelInterest = {
    _count: TravelInterestCountAggregateOutputType | null
    _avg: TravelInterestAvgAggregateOutputType | null
    _sum: TravelInterestSumAggregateOutputType | null
    _min: TravelInterestMinAggregateOutputType | null
    _max: TravelInterestMaxAggregateOutputType | null
  }

  export type TravelInterestAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TravelInterestSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TravelInterestMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TravelInterestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
  }

  export type TravelInterestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    displayOrder: number
    _all: number
  }


  export type TravelInterestAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TravelInterestSumAggregateInputType = {
    displayOrder?: true
  }

  export type TravelInterestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type TravelInterestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
  }

  export type TravelInterestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
    _all?: true
  }

  export type TravelInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelInterest to aggregate.
     */
    where?: TravelInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelInterests to fetch.
     */
    orderBy?: TravelInterestOrderByWithRelationInput | TravelInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TravelInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TravelInterests
    **/
    _count?: true | TravelInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TravelInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TravelInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TravelInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TravelInterestMaxAggregateInputType
  }

  export type GetTravelInterestAggregateType<T extends TravelInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateTravelInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTravelInterest[P]>
      : GetScalarType<T[P], AggregateTravelInterest[P]>
  }




  export type TravelInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelInterestWhereInput
    orderBy?: TravelInterestOrderByWithAggregationInput | TravelInterestOrderByWithAggregationInput[]
    by: TravelInterestScalarFieldEnum[] | TravelInterestScalarFieldEnum
    having?: TravelInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TravelInterestCountAggregateInputType | true
    _avg?: TravelInterestAvgAggregateInputType
    _sum?: TravelInterestSumAggregateInputType
    _min?: TravelInterestMinAggregateInputType
    _max?: TravelInterestMaxAggregateInputType
  }

  export type TravelInterestGroupByOutputType = {
    id: string
    name: string
    description: string
    isActive: boolean
    displayOrder: number | null
    _count: TravelInterestCountAggregateOutputType | null
    _avg: TravelInterestAvgAggregateOutputType | null
    _sum: TravelInterestSumAggregateOutputType | null
    _min: TravelInterestMinAggregateOutputType | null
    _max: TravelInterestMaxAggregateOutputType | null
  }

  type GetTravelInterestGroupByPayload<T extends TravelInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TravelInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TravelInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TravelInterestGroupByOutputType[P]>
            : GetScalarType<T[P], TravelInterestGroupByOutputType[P]>
        }
      >
    >


  export type TravelInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
    userInterests?: boolean | TravelInterest$userInterestsArgs<ExtArgs>
    customTourInterests?: boolean | TravelInterest$customTourInterestsArgs<ExtArgs>
    _count?: boolean | TravelInterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["travelInterest"]>

  export type TravelInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }, ExtArgs["result"]["travelInterest"]>

  export type TravelInterestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
  }

  export type TravelInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userInterests?: boolean | TravelInterest$userInterestsArgs<ExtArgs>
    customTourInterests?: boolean | TravelInterest$customTourInterestsArgs<ExtArgs>
    _count?: boolean | TravelInterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TravelInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TravelInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TravelInterest"
    objects: {
      userInterests: Prisma.$UserInterestPayload<ExtArgs>[]
      customTourInterests: Prisma.$CustomTourInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      isActive: boolean
      displayOrder: number | null
    }, ExtArgs["result"]["travelInterest"]>
    composites: {}
  }

  type TravelInterestGetPayload<S extends boolean | null | undefined | TravelInterestDefaultArgs> = $Result.GetResult<Prisma.$TravelInterestPayload, S>

  type TravelInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TravelInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TravelInterestCountAggregateInputType | true
    }

  export interface TravelInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TravelInterest'], meta: { name: 'TravelInterest' } }
    /**
     * Find zero or one TravelInterest that matches the filter.
     * @param {TravelInterestFindUniqueArgs} args - Arguments to find a TravelInterest
     * @example
     * // Get one TravelInterest
     * const travelInterest = await prisma.travelInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TravelInterestFindUniqueArgs>(args: SelectSubset<T, TravelInterestFindUniqueArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TravelInterest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TravelInterestFindUniqueOrThrowArgs} args - Arguments to find a TravelInterest
     * @example
     * // Get one TravelInterest
     * const travelInterest = await prisma.travelInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TravelInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, TravelInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TravelInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestFindFirstArgs} args - Arguments to find a TravelInterest
     * @example
     * // Get one TravelInterest
     * const travelInterest = await prisma.travelInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TravelInterestFindFirstArgs>(args?: SelectSubset<T, TravelInterestFindFirstArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TravelInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestFindFirstOrThrowArgs} args - Arguments to find a TravelInterest
     * @example
     * // Get one TravelInterest
     * const travelInterest = await prisma.travelInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TravelInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, TravelInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TravelInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TravelInterests
     * const travelInterests = await prisma.travelInterest.findMany()
     * 
     * // Get first 10 TravelInterests
     * const travelInterests = await prisma.travelInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const travelInterestWithIdOnly = await prisma.travelInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TravelInterestFindManyArgs>(args?: SelectSubset<T, TravelInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TravelInterest.
     * @param {TravelInterestCreateArgs} args - Arguments to create a TravelInterest.
     * @example
     * // Create one TravelInterest
     * const TravelInterest = await prisma.travelInterest.create({
     *   data: {
     *     // ... data to create a TravelInterest
     *   }
     * })
     * 
     */
    create<T extends TravelInterestCreateArgs>(args: SelectSubset<T, TravelInterestCreateArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TravelInterests.
     * @param {TravelInterestCreateManyArgs} args - Arguments to create many TravelInterests.
     * @example
     * // Create many TravelInterests
     * const travelInterest = await prisma.travelInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TravelInterestCreateManyArgs>(args?: SelectSubset<T, TravelInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TravelInterests and returns the data saved in the database.
     * @param {TravelInterestCreateManyAndReturnArgs} args - Arguments to create many TravelInterests.
     * @example
     * // Create many TravelInterests
     * const travelInterest = await prisma.travelInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TravelInterests and only return the `id`
     * const travelInterestWithIdOnly = await prisma.travelInterest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TravelInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, TravelInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TravelInterest.
     * @param {TravelInterestDeleteArgs} args - Arguments to delete one TravelInterest.
     * @example
     * // Delete one TravelInterest
     * const TravelInterest = await prisma.travelInterest.delete({
     *   where: {
     *     // ... filter to delete one TravelInterest
     *   }
     * })
     * 
     */
    delete<T extends TravelInterestDeleteArgs>(args: SelectSubset<T, TravelInterestDeleteArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TravelInterest.
     * @param {TravelInterestUpdateArgs} args - Arguments to update one TravelInterest.
     * @example
     * // Update one TravelInterest
     * const travelInterest = await prisma.travelInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TravelInterestUpdateArgs>(args: SelectSubset<T, TravelInterestUpdateArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TravelInterests.
     * @param {TravelInterestDeleteManyArgs} args - Arguments to filter TravelInterests to delete.
     * @example
     * // Delete a few TravelInterests
     * const { count } = await prisma.travelInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TravelInterestDeleteManyArgs>(args?: SelectSubset<T, TravelInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TravelInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TravelInterests
     * const travelInterest = await prisma.travelInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TravelInterestUpdateManyArgs>(args: SelectSubset<T, TravelInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TravelInterest.
     * @param {TravelInterestUpsertArgs} args - Arguments to update or create a TravelInterest.
     * @example
     * // Update or create a TravelInterest
     * const travelInterest = await prisma.travelInterest.upsert({
     *   create: {
     *     // ... data to create a TravelInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TravelInterest we want to update
     *   }
     * })
     */
    upsert<T extends TravelInterestUpsertArgs>(args: SelectSubset<T, TravelInterestUpsertArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TravelInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestCountArgs} args - Arguments to filter TravelInterests to count.
     * @example
     * // Count the number of TravelInterests
     * const count = await prisma.travelInterest.count({
     *   where: {
     *     // ... the filter for the TravelInterests we want to count
     *   }
     * })
    **/
    count<T extends TravelInterestCountArgs>(
      args?: Subset<T, TravelInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TravelInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TravelInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TravelInterestAggregateArgs>(args: Subset<T, TravelInterestAggregateArgs>): Prisma.PrismaPromise<GetTravelInterestAggregateType<T>>

    /**
     * Group by TravelInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TravelInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TravelInterestGroupByArgs['orderBy'] }
        : { orderBy?: TravelInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TravelInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTravelInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TravelInterest model
   */
  readonly fields: TravelInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TravelInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TravelInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userInterests<T extends TravelInterest$userInterestsArgs<ExtArgs> = {}>(args?: Subset<T, TravelInterest$userInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findMany"> | Null>
    customTourInterests<T extends TravelInterest$customTourInterestsArgs<ExtArgs> = {}>(args?: Subset<T, TravelInterest$customTourInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TravelInterest model
   */ 
  interface TravelInterestFieldRefs {
    readonly id: FieldRef<"TravelInterest", 'String'>
    readonly name: FieldRef<"TravelInterest", 'String'>
    readonly description: FieldRef<"TravelInterest", 'String'>
    readonly isActive: FieldRef<"TravelInterest", 'Boolean'>
    readonly displayOrder: FieldRef<"TravelInterest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TravelInterest findUnique
   */
  export type TravelInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter, which TravelInterest to fetch.
     */
    where: TravelInterestWhereUniqueInput
  }

  /**
   * TravelInterest findUniqueOrThrow
   */
  export type TravelInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter, which TravelInterest to fetch.
     */
    where: TravelInterestWhereUniqueInput
  }

  /**
   * TravelInterest findFirst
   */
  export type TravelInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter, which TravelInterest to fetch.
     */
    where?: TravelInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelInterests to fetch.
     */
    orderBy?: TravelInterestOrderByWithRelationInput | TravelInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelInterests.
     */
    cursor?: TravelInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelInterests.
     */
    distinct?: TravelInterestScalarFieldEnum | TravelInterestScalarFieldEnum[]
  }

  /**
   * TravelInterest findFirstOrThrow
   */
  export type TravelInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter, which TravelInterest to fetch.
     */
    where?: TravelInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelInterests to fetch.
     */
    orderBy?: TravelInterestOrderByWithRelationInput | TravelInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelInterests.
     */
    cursor?: TravelInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelInterests.
     */
    distinct?: TravelInterestScalarFieldEnum | TravelInterestScalarFieldEnum[]
  }

  /**
   * TravelInterest findMany
   */
  export type TravelInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter, which TravelInterests to fetch.
     */
    where?: TravelInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelInterests to fetch.
     */
    orderBy?: TravelInterestOrderByWithRelationInput | TravelInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TravelInterests.
     */
    cursor?: TravelInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelInterests.
     */
    skip?: number
    distinct?: TravelInterestScalarFieldEnum | TravelInterestScalarFieldEnum[]
  }

  /**
   * TravelInterest create
   */
  export type TravelInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a TravelInterest.
     */
    data: XOR<TravelInterestCreateInput, TravelInterestUncheckedCreateInput>
  }

  /**
   * TravelInterest createMany
   */
  export type TravelInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TravelInterests.
     */
    data: TravelInterestCreateManyInput | TravelInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TravelInterest createManyAndReturn
   */
  export type TravelInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TravelInterests.
     */
    data: TravelInterestCreateManyInput | TravelInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TravelInterest update
   */
  export type TravelInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a TravelInterest.
     */
    data: XOR<TravelInterestUpdateInput, TravelInterestUncheckedUpdateInput>
    /**
     * Choose, which TravelInterest to update.
     */
    where: TravelInterestWhereUniqueInput
  }

  /**
   * TravelInterest updateMany
   */
  export type TravelInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TravelInterests.
     */
    data: XOR<TravelInterestUpdateManyMutationInput, TravelInterestUncheckedUpdateManyInput>
    /**
     * Filter which TravelInterests to update
     */
    where?: TravelInterestWhereInput
  }

  /**
   * TravelInterest upsert
   */
  export type TravelInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the TravelInterest to update in case it exists.
     */
    where: TravelInterestWhereUniqueInput
    /**
     * In case the TravelInterest found by the `where` argument doesn't exist, create a new TravelInterest with this data.
     */
    create: XOR<TravelInterestCreateInput, TravelInterestUncheckedCreateInput>
    /**
     * In case the TravelInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TravelInterestUpdateInput, TravelInterestUncheckedUpdateInput>
  }

  /**
   * TravelInterest delete
   */
  export type TravelInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
    /**
     * Filter which TravelInterest to delete.
     */
    where: TravelInterestWhereUniqueInput
  }

  /**
   * TravelInterest deleteMany
   */
  export type TravelInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelInterests to delete
     */
    where?: TravelInterestWhereInput
  }

  /**
   * TravelInterest.userInterests
   */
  export type TravelInterest$userInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    where?: UserInterestWhereInput
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    cursor?: UserInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * TravelInterest.customTourInterests
   */
  export type TravelInterest$customTourInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    where?: CustomTourInterestWhereInput
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    cursor?: CustomTourInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomTourInterestScalarFieldEnum | CustomTourInterestScalarFieldEnum[]
  }

  /**
   * TravelInterest without action
   */
  export type TravelInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelInterest
     */
    select?: TravelInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelInterestInclude<ExtArgs> | null
  }


  /**
   * Model FlightRoute
   */

  export type AggregateFlightRoute = {
    _count: FlightRouteCountAggregateOutputType | null
    _avg: FlightRouteAvgAggregateOutputType | null
    _sum: FlightRouteSumAggregateOutputType | null
    _min: FlightRouteMinAggregateOutputType | null
    _max: FlightRouteMaxAggregateOutputType | null
  }

  export type FlightRouteAvgAggregateOutputType = {
    price: number | null
  }

  export type FlightRouteSumAggregateOutputType = {
    price: number | null
  }

  export type FlightRouteMinAggregateOutputType = {
    id: string | null
    origin: string | null
    destination: string | null
    airline: string | null
    duration: string | null
    frequency: string | null
    price: number | null
    isActive: boolean | null
  }

  export type FlightRouteMaxAggregateOutputType = {
    id: string | null
    origin: string | null
    destination: string | null
    airline: string | null
    duration: string | null
    frequency: string | null
    price: number | null
    isActive: boolean | null
  }

  export type FlightRouteCountAggregateOutputType = {
    id: number
    origin: number
    destination: number
    airline: number
    duration: number
    frequency: number
    price: number
    isActive: number
    _all: number
  }


  export type FlightRouteAvgAggregateInputType = {
    price?: true
  }

  export type FlightRouteSumAggregateInputType = {
    price?: true
  }

  export type FlightRouteMinAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    airline?: true
    duration?: true
    frequency?: true
    price?: true
    isActive?: true
  }

  export type FlightRouteMaxAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    airline?: true
    duration?: true
    frequency?: true
    price?: true
    isActive?: true
  }

  export type FlightRouteCountAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    airline?: true
    duration?: true
    frequency?: true
    price?: true
    isActive?: true
    _all?: true
  }

  export type FlightRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightRoute to aggregate.
     */
    where?: FlightRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRoutes to fetch.
     */
    orderBy?: FlightRouteOrderByWithRelationInput | FlightRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlightRoutes
    **/
    _count?: true | FlightRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightRouteMaxAggregateInputType
  }

  export type GetFlightRouteAggregateType<T extends FlightRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateFlightRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlightRoute[P]>
      : GetScalarType<T[P], AggregateFlightRoute[P]>
  }




  export type FlightRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightRouteWhereInput
    orderBy?: FlightRouteOrderByWithAggregationInput | FlightRouteOrderByWithAggregationInput[]
    by: FlightRouteScalarFieldEnum[] | FlightRouteScalarFieldEnum
    having?: FlightRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightRouteCountAggregateInputType | true
    _avg?: FlightRouteAvgAggregateInputType
    _sum?: FlightRouteSumAggregateInputType
    _min?: FlightRouteMinAggregateInputType
    _max?: FlightRouteMaxAggregateInputType
  }

  export type FlightRouteGroupByOutputType = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive: boolean
    _count: FlightRouteCountAggregateOutputType | null
    _avg: FlightRouteAvgAggregateOutputType | null
    _sum: FlightRouteSumAggregateOutputType | null
    _min: FlightRouteMinAggregateOutputType | null
    _max: FlightRouteMaxAggregateOutputType | null
  }

  type GetFlightRouteGroupByPayload<T extends FlightRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightRouteGroupByOutputType[P]>
            : GetScalarType<T[P], FlightRouteGroupByOutputType[P]>
        }
      >
    >


  export type FlightRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin?: boolean
    destination?: boolean
    airline?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    isActive?: boolean
    flightBookings?: boolean | FlightRoute$flightBookingsArgs<ExtArgs>
    _count?: boolean | FlightRouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightRoute"]>

  export type FlightRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin?: boolean
    destination?: boolean
    airline?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["flightRoute"]>

  export type FlightRouteSelectScalar = {
    id?: boolean
    origin?: boolean
    destination?: boolean
    airline?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    isActive?: boolean
  }

  export type FlightRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightBookings?: boolean | FlightRoute$flightBookingsArgs<ExtArgs>
    _count?: boolean | FlightRouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlightRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FlightRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlightRoute"
    objects: {
      flightBookings: Prisma.$FlightBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      origin: string
      destination: string
      airline: string
      duration: string
      frequency: string
      price: number
      isActive: boolean
    }, ExtArgs["result"]["flightRoute"]>
    composites: {}
  }

  type FlightRouteGetPayload<S extends boolean | null | undefined | FlightRouteDefaultArgs> = $Result.GetResult<Prisma.$FlightRoutePayload, S>

  type FlightRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlightRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlightRouteCountAggregateInputType | true
    }

  export interface FlightRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlightRoute'], meta: { name: 'FlightRoute' } }
    /**
     * Find zero or one FlightRoute that matches the filter.
     * @param {FlightRouteFindUniqueArgs} args - Arguments to find a FlightRoute
     * @example
     * // Get one FlightRoute
     * const flightRoute = await prisma.flightRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightRouteFindUniqueArgs>(args: SelectSubset<T, FlightRouteFindUniqueArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlightRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlightRouteFindUniqueOrThrowArgs} args - Arguments to find a FlightRoute
     * @example
     * // Get one FlightRoute
     * const flightRoute = await prisma.flightRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlightRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteFindFirstArgs} args - Arguments to find a FlightRoute
     * @example
     * // Get one FlightRoute
     * const flightRoute = await prisma.flightRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightRouteFindFirstArgs>(args?: SelectSubset<T, FlightRouteFindFirstArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlightRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteFindFirstOrThrowArgs} args - Arguments to find a FlightRoute
     * @example
     * // Get one FlightRoute
     * const flightRoute = await prisma.flightRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlightRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlightRoutes
     * const flightRoutes = await prisma.flightRoute.findMany()
     * 
     * // Get first 10 FlightRoutes
     * const flightRoutes = await prisma.flightRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightRouteWithIdOnly = await prisma.flightRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightRouteFindManyArgs>(args?: SelectSubset<T, FlightRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlightRoute.
     * @param {FlightRouteCreateArgs} args - Arguments to create a FlightRoute.
     * @example
     * // Create one FlightRoute
     * const FlightRoute = await prisma.flightRoute.create({
     *   data: {
     *     // ... data to create a FlightRoute
     *   }
     * })
     * 
     */
    create<T extends FlightRouteCreateArgs>(args: SelectSubset<T, FlightRouteCreateArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlightRoutes.
     * @param {FlightRouteCreateManyArgs} args - Arguments to create many FlightRoutes.
     * @example
     * // Create many FlightRoutes
     * const flightRoute = await prisma.flightRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightRouteCreateManyArgs>(args?: SelectSubset<T, FlightRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlightRoutes and returns the data saved in the database.
     * @param {FlightRouteCreateManyAndReturnArgs} args - Arguments to create many FlightRoutes.
     * @example
     * // Create many FlightRoutes
     * const flightRoute = await prisma.flightRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlightRoutes and only return the `id`
     * const flightRouteWithIdOnly = await prisma.flightRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlightRoute.
     * @param {FlightRouteDeleteArgs} args - Arguments to delete one FlightRoute.
     * @example
     * // Delete one FlightRoute
     * const FlightRoute = await prisma.flightRoute.delete({
     *   where: {
     *     // ... filter to delete one FlightRoute
     *   }
     * })
     * 
     */
    delete<T extends FlightRouteDeleteArgs>(args: SelectSubset<T, FlightRouteDeleteArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlightRoute.
     * @param {FlightRouteUpdateArgs} args - Arguments to update one FlightRoute.
     * @example
     * // Update one FlightRoute
     * const flightRoute = await prisma.flightRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightRouteUpdateArgs>(args: SelectSubset<T, FlightRouteUpdateArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlightRoutes.
     * @param {FlightRouteDeleteManyArgs} args - Arguments to filter FlightRoutes to delete.
     * @example
     * // Delete a few FlightRoutes
     * const { count } = await prisma.flightRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightRouteDeleteManyArgs>(args?: SelectSubset<T, FlightRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlightRoutes
     * const flightRoute = await prisma.flightRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightRouteUpdateManyArgs>(args: SelectSubset<T, FlightRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlightRoute.
     * @param {FlightRouteUpsertArgs} args - Arguments to update or create a FlightRoute.
     * @example
     * // Update or create a FlightRoute
     * const flightRoute = await prisma.flightRoute.upsert({
     *   create: {
     *     // ... data to create a FlightRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlightRoute we want to update
     *   }
     * })
     */
    upsert<T extends FlightRouteUpsertArgs>(args: SelectSubset<T, FlightRouteUpsertArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlightRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteCountArgs} args - Arguments to filter FlightRoutes to count.
     * @example
     * // Count the number of FlightRoutes
     * const count = await prisma.flightRoute.count({
     *   where: {
     *     // ... the filter for the FlightRoutes we want to count
     *   }
     * })
    **/
    count<T extends FlightRouteCountArgs>(
      args?: Subset<T, FlightRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlightRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightRouteAggregateArgs>(args: Subset<T, FlightRouteAggregateArgs>): Prisma.PrismaPromise<GetFlightRouteAggregateType<T>>

    /**
     * Group by FlightRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightRouteGroupByArgs['orderBy'] }
        : { orderBy?: FlightRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlightRoute model
   */
  readonly fields: FlightRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlightRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flightBookings<T extends FlightRoute$flightBookingsArgs<ExtArgs> = {}>(args?: Subset<T, FlightRoute$flightBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlightRoute model
   */ 
  interface FlightRouteFieldRefs {
    readonly id: FieldRef<"FlightRoute", 'String'>
    readonly origin: FieldRef<"FlightRoute", 'String'>
    readonly destination: FieldRef<"FlightRoute", 'String'>
    readonly airline: FieldRef<"FlightRoute", 'String'>
    readonly duration: FieldRef<"FlightRoute", 'String'>
    readonly frequency: FieldRef<"FlightRoute", 'String'>
    readonly price: FieldRef<"FlightRoute", 'Int'>
    readonly isActive: FieldRef<"FlightRoute", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FlightRoute findUnique
   */
  export type FlightRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter, which FlightRoute to fetch.
     */
    where: FlightRouteWhereUniqueInput
  }

  /**
   * FlightRoute findUniqueOrThrow
   */
  export type FlightRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter, which FlightRoute to fetch.
     */
    where: FlightRouteWhereUniqueInput
  }

  /**
   * FlightRoute findFirst
   */
  export type FlightRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter, which FlightRoute to fetch.
     */
    where?: FlightRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRoutes to fetch.
     */
    orderBy?: FlightRouteOrderByWithRelationInput | FlightRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightRoutes.
     */
    cursor?: FlightRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightRoutes.
     */
    distinct?: FlightRouteScalarFieldEnum | FlightRouteScalarFieldEnum[]
  }

  /**
   * FlightRoute findFirstOrThrow
   */
  export type FlightRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter, which FlightRoute to fetch.
     */
    where?: FlightRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRoutes to fetch.
     */
    orderBy?: FlightRouteOrderByWithRelationInput | FlightRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightRoutes.
     */
    cursor?: FlightRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightRoutes.
     */
    distinct?: FlightRouteScalarFieldEnum | FlightRouteScalarFieldEnum[]
  }

  /**
   * FlightRoute findMany
   */
  export type FlightRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter, which FlightRoutes to fetch.
     */
    where?: FlightRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRoutes to fetch.
     */
    orderBy?: FlightRouteOrderByWithRelationInput | FlightRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlightRoutes.
     */
    cursor?: FlightRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRoutes.
     */
    skip?: number
    distinct?: FlightRouteScalarFieldEnum | FlightRouteScalarFieldEnum[]
  }

  /**
   * FlightRoute create
   */
  export type FlightRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a FlightRoute.
     */
    data: XOR<FlightRouteCreateInput, FlightRouteUncheckedCreateInput>
  }

  /**
   * FlightRoute createMany
   */
  export type FlightRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlightRoutes.
     */
    data: FlightRouteCreateManyInput | FlightRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlightRoute createManyAndReturn
   */
  export type FlightRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlightRoutes.
     */
    data: FlightRouteCreateManyInput | FlightRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlightRoute update
   */
  export type FlightRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a FlightRoute.
     */
    data: XOR<FlightRouteUpdateInput, FlightRouteUncheckedUpdateInput>
    /**
     * Choose, which FlightRoute to update.
     */
    where: FlightRouteWhereUniqueInput
  }

  /**
   * FlightRoute updateMany
   */
  export type FlightRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlightRoutes.
     */
    data: XOR<FlightRouteUpdateManyMutationInput, FlightRouteUncheckedUpdateManyInput>
    /**
     * Filter which FlightRoutes to update
     */
    where?: FlightRouteWhereInput
  }

  /**
   * FlightRoute upsert
   */
  export type FlightRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the FlightRoute to update in case it exists.
     */
    where: FlightRouteWhereUniqueInput
    /**
     * In case the FlightRoute found by the `where` argument doesn't exist, create a new FlightRoute with this data.
     */
    create: XOR<FlightRouteCreateInput, FlightRouteUncheckedCreateInput>
    /**
     * In case the FlightRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightRouteUpdateInput, FlightRouteUncheckedUpdateInput>
  }

  /**
   * FlightRoute delete
   */
  export type FlightRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
    /**
     * Filter which FlightRoute to delete.
     */
    where: FlightRouteWhereUniqueInput
  }

  /**
   * FlightRoute deleteMany
   */
  export type FlightRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightRoutes to delete
     */
    where?: FlightRouteWhereInput
  }

  /**
   * FlightRoute.flightBookings
   */
  export type FlightRoute$flightBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    where?: FlightBookingWhereInput
    orderBy?: FlightBookingOrderByWithRelationInput | FlightBookingOrderByWithRelationInput[]
    cursor?: FlightBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightBookingScalarFieldEnum | FlightBookingScalarFieldEnum[]
  }

  /**
   * FlightRoute without action
   */
  export type FlightRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRoute
     */
    select?: FlightRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRouteInclude<ExtArgs> | null
  }


  /**
   * Model AccommodationType
   */

  export type AggregateAccommodationType = {
    _count: AccommodationTypeCountAggregateOutputType | null
    _min: AccommodationTypeMinAggregateOutputType | null
    _max: AccommodationTypeMaxAggregateOutputType | null
  }

  export type AccommodationTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    isActive: boolean | null
  }

  export type AccommodationTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    isActive: boolean | null
  }

  export type AccommodationTypeCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    isActive: number
    _all: number
  }


  export type AccommodationTypeMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    isActive?: true
  }

  export type AccommodationTypeMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    isActive?: true
  }

  export type AccommodationTypeCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    isActive?: true
    _all?: true
  }

  export type AccommodationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationType to aggregate.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccommodationTypes
    **/
    _count?: true | AccommodationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationTypeMaxAggregateInputType
  }

  export type GetAccommodationTypeAggregateType<T extends AccommodationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodationType[P]>
      : GetScalarType<T[P], AggregateAccommodationType[P]>
  }




  export type AccommodationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationTypeWhereInput
    orderBy?: AccommodationTypeOrderByWithAggregationInput | AccommodationTypeOrderByWithAggregationInput[]
    by: AccommodationTypeScalarFieldEnum[] | AccommodationTypeScalarFieldEnum
    having?: AccommodationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationTypeCountAggregateInputType | true
    _min?: AccommodationTypeMinAggregateInputType
    _max?: AccommodationTypeMaxAggregateInputType
  }

  export type AccommodationTypeGroupByOutputType = {
    id: string
    name: string
    icon: string
    isActive: boolean
    _count: AccommodationTypeCountAggregateOutputType | null
    _min: AccommodationTypeMinAggregateOutputType | null
    _max: AccommodationTypeMaxAggregateOutputType | null
  }

  type GetAccommodationTypeGroupByPayload<T extends AccommodationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationTypeGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["accommodationType"]>

  export type AccommodationTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["accommodationType"]>

  export type AccommodationTypeSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    isActive?: boolean
  }


  export type $AccommodationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccommodationType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      isActive: boolean
    }, ExtArgs["result"]["accommodationType"]>
    composites: {}
  }

  type AccommodationTypeGetPayload<S extends boolean | null | undefined | AccommodationTypeDefaultArgs> = $Result.GetResult<Prisma.$AccommodationTypePayload, S>

  type AccommodationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccommodationTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccommodationTypeCountAggregateInputType | true
    }

  export interface AccommodationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccommodationType'], meta: { name: 'AccommodationType' } }
    /**
     * Find zero or one AccommodationType that matches the filter.
     * @param {AccommodationTypeFindUniqueArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationTypeFindUniqueArgs>(args: SelectSubset<T, AccommodationTypeFindUniqueArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccommodationType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccommodationTypeFindUniqueOrThrowArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccommodationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindFirstArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationTypeFindFirstArgs>(args?: SelectSubset<T, AccommodationTypeFindFirstArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccommodationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindFirstOrThrowArgs} args - Arguments to find a AccommodationType
     * @example
     * // Get one AccommodationType
     * const accommodationType = await prisma.accommodationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccommodationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccommodationTypes
     * const accommodationTypes = await prisma.accommodationType.findMany()
     * 
     * // Get first 10 AccommodationTypes
     * const accommodationTypes = await prisma.accommodationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationTypeWithIdOnly = await prisma.accommodationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationTypeFindManyArgs>(args?: SelectSubset<T, AccommodationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccommodationType.
     * @param {AccommodationTypeCreateArgs} args - Arguments to create a AccommodationType.
     * @example
     * // Create one AccommodationType
     * const AccommodationType = await prisma.accommodationType.create({
     *   data: {
     *     // ... data to create a AccommodationType
     *   }
     * })
     * 
     */
    create<T extends AccommodationTypeCreateArgs>(args: SelectSubset<T, AccommodationTypeCreateArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccommodationTypes.
     * @param {AccommodationTypeCreateManyArgs} args - Arguments to create many AccommodationTypes.
     * @example
     * // Create many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationTypeCreateManyArgs>(args?: SelectSubset<T, AccommodationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccommodationTypes and returns the data saved in the database.
     * @param {AccommodationTypeCreateManyAndReturnArgs} args - Arguments to create many AccommodationTypes.
     * @example
     * // Create many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccommodationTypes and only return the `id`
     * const accommodationTypeWithIdOnly = await prisma.accommodationType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccommodationType.
     * @param {AccommodationTypeDeleteArgs} args - Arguments to delete one AccommodationType.
     * @example
     * // Delete one AccommodationType
     * const AccommodationType = await prisma.accommodationType.delete({
     *   where: {
     *     // ... filter to delete one AccommodationType
     *   }
     * })
     * 
     */
    delete<T extends AccommodationTypeDeleteArgs>(args: SelectSubset<T, AccommodationTypeDeleteArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccommodationType.
     * @param {AccommodationTypeUpdateArgs} args - Arguments to update one AccommodationType.
     * @example
     * // Update one AccommodationType
     * const accommodationType = await prisma.accommodationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationTypeUpdateArgs>(args: SelectSubset<T, AccommodationTypeUpdateArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccommodationTypes.
     * @param {AccommodationTypeDeleteManyArgs} args - Arguments to filter AccommodationTypes to delete.
     * @example
     * // Delete a few AccommodationTypes
     * const { count } = await prisma.accommodationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationTypeDeleteManyArgs>(args?: SelectSubset<T, AccommodationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccommodationTypes
     * const accommodationType = await prisma.accommodationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationTypeUpdateManyArgs>(args: SelectSubset<T, AccommodationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccommodationType.
     * @param {AccommodationTypeUpsertArgs} args - Arguments to update or create a AccommodationType.
     * @example
     * // Update or create a AccommodationType
     * const accommodationType = await prisma.accommodationType.upsert({
     *   create: {
     *     // ... data to create a AccommodationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccommodationType we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationTypeUpsertArgs>(args: SelectSubset<T, AccommodationTypeUpsertArgs<ExtArgs>>): Prisma__AccommodationTypeClient<$Result.GetResult<Prisma.$AccommodationTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccommodationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeCountArgs} args - Arguments to filter AccommodationTypes to count.
     * @example
     * // Count the number of AccommodationTypes
     * const count = await prisma.accommodationType.count({
     *   where: {
     *     // ... the filter for the AccommodationTypes we want to count
     *   }
     * })
    **/
    count<T extends AccommodationTypeCountArgs>(
      args?: Subset<T, AccommodationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccommodationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationTypeAggregateArgs>(args: Subset<T, AccommodationTypeAggregateArgs>): Prisma.PrismaPromise<GetAccommodationTypeAggregateType<T>>

    /**
     * Group by AccommodationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationTypeGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccommodationType model
   */
  readonly fields: AccommodationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccommodationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccommodationType model
   */ 
  interface AccommodationTypeFieldRefs {
    readonly id: FieldRef<"AccommodationType", 'String'>
    readonly name: FieldRef<"AccommodationType", 'String'>
    readonly icon: FieldRef<"AccommodationType", 'String'>
    readonly isActive: FieldRef<"AccommodationType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AccommodationType findUnique
   */
  export type AccommodationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType findUniqueOrThrow
   */
  export type AccommodationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType findFirst
   */
  export type AccommodationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationTypes.
     */
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType findFirstOrThrow
   */
  export type AccommodationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter, which AccommodationType to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationTypes.
     */
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType findMany
   */
  export type AccommodationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter, which AccommodationTypes to fetch.
     */
    where?: AccommodationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationTypes to fetch.
     */
    orderBy?: AccommodationTypeOrderByWithRelationInput | AccommodationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccommodationTypes.
     */
    cursor?: AccommodationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationTypes.
     */
    skip?: number
    distinct?: AccommodationTypeScalarFieldEnum | AccommodationTypeScalarFieldEnum[]
  }

  /**
   * AccommodationType create
   */
  export type AccommodationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a AccommodationType.
     */
    data: XOR<AccommodationTypeCreateInput, AccommodationTypeUncheckedCreateInput>
  }

  /**
   * AccommodationType createMany
   */
  export type AccommodationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccommodationTypes.
     */
    data: AccommodationTypeCreateManyInput | AccommodationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationType createManyAndReturn
   */
  export type AccommodationTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccommodationTypes.
     */
    data: AccommodationTypeCreateManyInput | AccommodationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationType update
   */
  export type AccommodationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a AccommodationType.
     */
    data: XOR<AccommodationTypeUpdateInput, AccommodationTypeUncheckedUpdateInput>
    /**
     * Choose, which AccommodationType to update.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType updateMany
   */
  export type AccommodationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccommodationTypes.
     */
    data: XOR<AccommodationTypeUpdateManyMutationInput, AccommodationTypeUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationTypes to update
     */
    where?: AccommodationTypeWhereInput
  }

  /**
   * AccommodationType upsert
   */
  export type AccommodationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the AccommodationType to update in case it exists.
     */
    where: AccommodationTypeWhereUniqueInput
    /**
     * In case the AccommodationType found by the `where` argument doesn't exist, create a new AccommodationType with this data.
     */
    create: XOR<AccommodationTypeCreateInput, AccommodationTypeUncheckedCreateInput>
    /**
     * In case the AccommodationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationTypeUpdateInput, AccommodationTypeUncheckedUpdateInput>
  }

  /**
   * AccommodationType delete
   */
  export type AccommodationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
    /**
     * Filter which AccommodationType to delete.
     */
    where: AccommodationTypeWhereUniqueInput
  }

  /**
   * AccommodationType deleteMany
   */
  export type AccommodationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationTypes to delete
     */
    where?: AccommodationTypeWhereInput
  }

  /**
   * AccommodationType without action
   */
  export type AccommodationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationType
     */
    select?: AccommodationTypeSelect<ExtArgs> | null
  }


  /**
   * Model DifficultyLevel
   */

  export type AggregateDifficultyLevel = {
    _count: DifficultyLevelCountAggregateOutputType | null
    _min: DifficultyLevelMinAggregateOutputType | null
    _max: DifficultyLevelMaxAggregateOutputType | null
  }

  export type DifficultyLevelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
  }

  export type DifficultyLevelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
  }

  export type DifficultyLevelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    _all: number
  }


  export type DifficultyLevelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
  }

  export type DifficultyLevelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
  }

  export type DifficultyLevelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    _all?: true
  }

  export type DifficultyLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DifficultyLevel to aggregate.
     */
    where?: DifficultyLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifficultyLevels to fetch.
     */
    orderBy?: DifficultyLevelOrderByWithRelationInput | DifficultyLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DifficultyLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifficultyLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifficultyLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DifficultyLevels
    **/
    _count?: true | DifficultyLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DifficultyLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DifficultyLevelMaxAggregateInputType
  }

  export type GetDifficultyLevelAggregateType<T extends DifficultyLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateDifficultyLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDifficultyLevel[P]>
      : GetScalarType<T[P], AggregateDifficultyLevel[P]>
  }




  export type DifficultyLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifficultyLevelWhereInput
    orderBy?: DifficultyLevelOrderByWithAggregationInput | DifficultyLevelOrderByWithAggregationInput[]
    by: DifficultyLevelScalarFieldEnum[] | DifficultyLevelScalarFieldEnum
    having?: DifficultyLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DifficultyLevelCountAggregateInputType | true
    _min?: DifficultyLevelMinAggregateInputType
    _max?: DifficultyLevelMaxAggregateInputType
  }

  export type DifficultyLevelGroupByOutputType = {
    id: string
    name: string
    description: string
    isActive: boolean
    _count: DifficultyLevelCountAggregateOutputType | null
    _min: DifficultyLevelMinAggregateOutputType | null
    _max: DifficultyLevelMaxAggregateOutputType | null
  }

  type GetDifficultyLevelGroupByPayload<T extends DifficultyLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DifficultyLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DifficultyLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DifficultyLevelGroupByOutputType[P]>
            : GetScalarType<T[P], DifficultyLevelGroupByOutputType[P]>
        }
      >
    >


  export type DifficultyLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["difficultyLevel"]>

  export type DifficultyLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["difficultyLevel"]>

  export type DifficultyLevelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
  }


  export type $DifficultyLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DifficultyLevel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      isActive: boolean
    }, ExtArgs["result"]["difficultyLevel"]>
    composites: {}
  }

  type DifficultyLevelGetPayload<S extends boolean | null | undefined | DifficultyLevelDefaultArgs> = $Result.GetResult<Prisma.$DifficultyLevelPayload, S>

  type DifficultyLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DifficultyLevelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DifficultyLevelCountAggregateInputType | true
    }

  export interface DifficultyLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DifficultyLevel'], meta: { name: 'DifficultyLevel' } }
    /**
     * Find zero or one DifficultyLevel that matches the filter.
     * @param {DifficultyLevelFindUniqueArgs} args - Arguments to find a DifficultyLevel
     * @example
     * // Get one DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DifficultyLevelFindUniqueArgs>(args: SelectSubset<T, DifficultyLevelFindUniqueArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DifficultyLevel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DifficultyLevelFindUniqueOrThrowArgs} args - Arguments to find a DifficultyLevel
     * @example
     * // Get one DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DifficultyLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, DifficultyLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DifficultyLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelFindFirstArgs} args - Arguments to find a DifficultyLevel
     * @example
     * // Get one DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DifficultyLevelFindFirstArgs>(args?: SelectSubset<T, DifficultyLevelFindFirstArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DifficultyLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelFindFirstOrThrowArgs} args - Arguments to find a DifficultyLevel
     * @example
     * // Get one DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DifficultyLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, DifficultyLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DifficultyLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DifficultyLevels
     * const difficultyLevels = await prisma.difficultyLevel.findMany()
     * 
     * // Get first 10 DifficultyLevels
     * const difficultyLevels = await prisma.difficultyLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const difficultyLevelWithIdOnly = await prisma.difficultyLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DifficultyLevelFindManyArgs>(args?: SelectSubset<T, DifficultyLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DifficultyLevel.
     * @param {DifficultyLevelCreateArgs} args - Arguments to create a DifficultyLevel.
     * @example
     * // Create one DifficultyLevel
     * const DifficultyLevel = await prisma.difficultyLevel.create({
     *   data: {
     *     // ... data to create a DifficultyLevel
     *   }
     * })
     * 
     */
    create<T extends DifficultyLevelCreateArgs>(args: SelectSubset<T, DifficultyLevelCreateArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DifficultyLevels.
     * @param {DifficultyLevelCreateManyArgs} args - Arguments to create many DifficultyLevels.
     * @example
     * // Create many DifficultyLevels
     * const difficultyLevel = await prisma.difficultyLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DifficultyLevelCreateManyArgs>(args?: SelectSubset<T, DifficultyLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DifficultyLevels and returns the data saved in the database.
     * @param {DifficultyLevelCreateManyAndReturnArgs} args - Arguments to create many DifficultyLevels.
     * @example
     * // Create many DifficultyLevels
     * const difficultyLevel = await prisma.difficultyLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DifficultyLevels and only return the `id`
     * const difficultyLevelWithIdOnly = await prisma.difficultyLevel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DifficultyLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, DifficultyLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DifficultyLevel.
     * @param {DifficultyLevelDeleteArgs} args - Arguments to delete one DifficultyLevel.
     * @example
     * // Delete one DifficultyLevel
     * const DifficultyLevel = await prisma.difficultyLevel.delete({
     *   where: {
     *     // ... filter to delete one DifficultyLevel
     *   }
     * })
     * 
     */
    delete<T extends DifficultyLevelDeleteArgs>(args: SelectSubset<T, DifficultyLevelDeleteArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DifficultyLevel.
     * @param {DifficultyLevelUpdateArgs} args - Arguments to update one DifficultyLevel.
     * @example
     * // Update one DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DifficultyLevelUpdateArgs>(args: SelectSubset<T, DifficultyLevelUpdateArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DifficultyLevels.
     * @param {DifficultyLevelDeleteManyArgs} args - Arguments to filter DifficultyLevels to delete.
     * @example
     * // Delete a few DifficultyLevels
     * const { count } = await prisma.difficultyLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DifficultyLevelDeleteManyArgs>(args?: SelectSubset<T, DifficultyLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DifficultyLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DifficultyLevels
     * const difficultyLevel = await prisma.difficultyLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DifficultyLevelUpdateManyArgs>(args: SelectSubset<T, DifficultyLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DifficultyLevel.
     * @param {DifficultyLevelUpsertArgs} args - Arguments to update or create a DifficultyLevel.
     * @example
     * // Update or create a DifficultyLevel
     * const difficultyLevel = await prisma.difficultyLevel.upsert({
     *   create: {
     *     // ... data to create a DifficultyLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DifficultyLevel we want to update
     *   }
     * })
     */
    upsert<T extends DifficultyLevelUpsertArgs>(args: SelectSubset<T, DifficultyLevelUpsertArgs<ExtArgs>>): Prisma__DifficultyLevelClient<$Result.GetResult<Prisma.$DifficultyLevelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DifficultyLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelCountArgs} args - Arguments to filter DifficultyLevels to count.
     * @example
     * // Count the number of DifficultyLevels
     * const count = await prisma.difficultyLevel.count({
     *   where: {
     *     // ... the filter for the DifficultyLevels we want to count
     *   }
     * })
    **/
    count<T extends DifficultyLevelCountArgs>(
      args?: Subset<T, DifficultyLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DifficultyLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DifficultyLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DifficultyLevelAggregateArgs>(args: Subset<T, DifficultyLevelAggregateArgs>): Prisma.PrismaPromise<GetDifficultyLevelAggregateType<T>>

    /**
     * Group by DifficultyLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifficultyLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DifficultyLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DifficultyLevelGroupByArgs['orderBy'] }
        : { orderBy?: DifficultyLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DifficultyLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDifficultyLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DifficultyLevel model
   */
  readonly fields: DifficultyLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DifficultyLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DifficultyLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DifficultyLevel model
   */ 
  interface DifficultyLevelFieldRefs {
    readonly id: FieldRef<"DifficultyLevel", 'String'>
    readonly name: FieldRef<"DifficultyLevel", 'String'>
    readonly description: FieldRef<"DifficultyLevel", 'String'>
    readonly isActive: FieldRef<"DifficultyLevel", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DifficultyLevel findUnique
   */
  export type DifficultyLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter, which DifficultyLevel to fetch.
     */
    where: DifficultyLevelWhereUniqueInput
  }

  /**
   * DifficultyLevel findUniqueOrThrow
   */
  export type DifficultyLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter, which DifficultyLevel to fetch.
     */
    where: DifficultyLevelWhereUniqueInput
  }

  /**
   * DifficultyLevel findFirst
   */
  export type DifficultyLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter, which DifficultyLevel to fetch.
     */
    where?: DifficultyLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifficultyLevels to fetch.
     */
    orderBy?: DifficultyLevelOrderByWithRelationInput | DifficultyLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DifficultyLevels.
     */
    cursor?: DifficultyLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifficultyLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifficultyLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DifficultyLevels.
     */
    distinct?: DifficultyLevelScalarFieldEnum | DifficultyLevelScalarFieldEnum[]
  }

  /**
   * DifficultyLevel findFirstOrThrow
   */
  export type DifficultyLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter, which DifficultyLevel to fetch.
     */
    where?: DifficultyLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifficultyLevels to fetch.
     */
    orderBy?: DifficultyLevelOrderByWithRelationInput | DifficultyLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DifficultyLevels.
     */
    cursor?: DifficultyLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifficultyLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifficultyLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DifficultyLevels.
     */
    distinct?: DifficultyLevelScalarFieldEnum | DifficultyLevelScalarFieldEnum[]
  }

  /**
   * DifficultyLevel findMany
   */
  export type DifficultyLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter, which DifficultyLevels to fetch.
     */
    where?: DifficultyLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifficultyLevels to fetch.
     */
    orderBy?: DifficultyLevelOrderByWithRelationInput | DifficultyLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DifficultyLevels.
     */
    cursor?: DifficultyLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifficultyLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifficultyLevels.
     */
    skip?: number
    distinct?: DifficultyLevelScalarFieldEnum | DifficultyLevelScalarFieldEnum[]
  }

  /**
   * DifficultyLevel create
   */
  export type DifficultyLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * The data needed to create a DifficultyLevel.
     */
    data: XOR<DifficultyLevelCreateInput, DifficultyLevelUncheckedCreateInput>
  }

  /**
   * DifficultyLevel createMany
   */
  export type DifficultyLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DifficultyLevels.
     */
    data: DifficultyLevelCreateManyInput | DifficultyLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DifficultyLevel createManyAndReturn
   */
  export type DifficultyLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DifficultyLevels.
     */
    data: DifficultyLevelCreateManyInput | DifficultyLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DifficultyLevel update
   */
  export type DifficultyLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * The data needed to update a DifficultyLevel.
     */
    data: XOR<DifficultyLevelUpdateInput, DifficultyLevelUncheckedUpdateInput>
    /**
     * Choose, which DifficultyLevel to update.
     */
    where: DifficultyLevelWhereUniqueInput
  }

  /**
   * DifficultyLevel updateMany
   */
  export type DifficultyLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DifficultyLevels.
     */
    data: XOR<DifficultyLevelUpdateManyMutationInput, DifficultyLevelUncheckedUpdateManyInput>
    /**
     * Filter which DifficultyLevels to update
     */
    where?: DifficultyLevelWhereInput
  }

  /**
   * DifficultyLevel upsert
   */
  export type DifficultyLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * The filter to search for the DifficultyLevel to update in case it exists.
     */
    where: DifficultyLevelWhereUniqueInput
    /**
     * In case the DifficultyLevel found by the `where` argument doesn't exist, create a new DifficultyLevel with this data.
     */
    create: XOR<DifficultyLevelCreateInput, DifficultyLevelUncheckedCreateInput>
    /**
     * In case the DifficultyLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DifficultyLevelUpdateInput, DifficultyLevelUncheckedUpdateInput>
  }

  /**
   * DifficultyLevel delete
   */
  export type DifficultyLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
    /**
     * Filter which DifficultyLevel to delete.
     */
    where: DifficultyLevelWhereUniqueInput
  }

  /**
   * DifficultyLevel deleteMany
   */
  export type DifficultyLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DifficultyLevels to delete
     */
    where?: DifficultyLevelWhereInput
  }

  /**
   * DifficultyLevel without action
   */
  export type DifficultyLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifficultyLevel
     */
    select?: DifficultyLevelSelect<ExtArgs> | null
  }


  /**
   * Model SeasonalPeriod
   */

  export type AggregateSeasonalPeriod = {
    _count: SeasonalPeriodCountAggregateOutputType | null
    _min: SeasonalPeriodMinAggregateOutputType | null
    _max: SeasonalPeriodMaxAggregateOutputType | null
  }

  export type SeasonalPeriodMinAggregateOutputType = {
    id: string | null
    name: string | null
    weather: string | null
    isActive: boolean | null
  }

  export type SeasonalPeriodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weather: string | null
    isActive: boolean | null
  }

  export type SeasonalPeriodCountAggregateOutputType = {
    id: number
    name: number
    weather: number
    isActive: number
    _all: number
  }


  export type SeasonalPeriodMinAggregateInputType = {
    id?: true
    name?: true
    weather?: true
    isActive?: true
  }

  export type SeasonalPeriodMaxAggregateInputType = {
    id?: true
    name?: true
    weather?: true
    isActive?: true
  }

  export type SeasonalPeriodCountAggregateInputType = {
    id?: true
    name?: true
    weather?: true
    isActive?: true
    _all?: true
  }

  export type SeasonalPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalPeriod to aggregate.
     */
    where?: SeasonalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPeriods to fetch.
     */
    orderBy?: SeasonalPeriodOrderByWithRelationInput | SeasonalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeasonalPeriods
    **/
    _count?: true | SeasonalPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonalPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonalPeriodMaxAggregateInputType
  }

  export type GetSeasonalPeriodAggregateType<T extends SeasonalPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasonalPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasonalPeriod[P]>
      : GetScalarType<T[P], AggregateSeasonalPeriod[P]>
  }




  export type SeasonalPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonalPeriodWhereInput
    orderBy?: SeasonalPeriodOrderByWithAggregationInput | SeasonalPeriodOrderByWithAggregationInput[]
    by: SeasonalPeriodScalarFieldEnum[] | SeasonalPeriodScalarFieldEnum
    having?: SeasonalPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonalPeriodCountAggregateInputType | true
    _min?: SeasonalPeriodMinAggregateInputType
    _max?: SeasonalPeriodMaxAggregateInputType
  }

  export type SeasonalPeriodGroupByOutputType = {
    id: string
    name: string
    weather: string
    isActive: boolean
    _count: SeasonalPeriodCountAggregateOutputType | null
    _min: SeasonalPeriodMinAggregateOutputType | null
    _max: SeasonalPeriodMaxAggregateOutputType | null
  }

  type GetSeasonalPeriodGroupByPayload<T extends SeasonalPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonalPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonalPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonalPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonalPeriodGroupByOutputType[P]>
        }
      >
    >


  export type SeasonalPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weather?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["seasonalPeriod"]>

  export type SeasonalPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weather?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["seasonalPeriod"]>

  export type SeasonalPeriodSelectScalar = {
    id?: boolean
    name?: boolean
    weather?: boolean
    isActive?: boolean
  }


  export type $SeasonalPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeasonalPeriod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weather: string
      isActive: boolean
    }, ExtArgs["result"]["seasonalPeriod"]>
    composites: {}
  }

  type SeasonalPeriodGetPayload<S extends boolean | null | undefined | SeasonalPeriodDefaultArgs> = $Result.GetResult<Prisma.$SeasonalPeriodPayload, S>

  type SeasonalPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeasonalPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeasonalPeriodCountAggregateInputType | true
    }

  export interface SeasonalPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeasonalPeriod'], meta: { name: 'SeasonalPeriod' } }
    /**
     * Find zero or one SeasonalPeriod that matches the filter.
     * @param {SeasonalPeriodFindUniqueArgs} args - Arguments to find a SeasonalPeriod
     * @example
     * // Get one SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonalPeriodFindUniqueArgs>(args: SelectSubset<T, SeasonalPeriodFindUniqueArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeasonalPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeasonalPeriodFindUniqueOrThrowArgs} args - Arguments to find a SeasonalPeriod
     * @example
     * // Get one SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonalPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonalPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeasonalPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodFindFirstArgs} args - Arguments to find a SeasonalPeriod
     * @example
     * // Get one SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonalPeriodFindFirstArgs>(args?: SelectSubset<T, SeasonalPeriodFindFirstArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeasonalPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodFindFirstOrThrowArgs} args - Arguments to find a SeasonalPeriod
     * @example
     * // Get one SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonalPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonalPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeasonalPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeasonalPeriods
     * const seasonalPeriods = await prisma.seasonalPeriod.findMany()
     * 
     * // Get first 10 SeasonalPeriods
     * const seasonalPeriods = await prisma.seasonalPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonalPeriodWithIdOnly = await prisma.seasonalPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonalPeriodFindManyArgs>(args?: SelectSubset<T, SeasonalPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeasonalPeriod.
     * @param {SeasonalPeriodCreateArgs} args - Arguments to create a SeasonalPeriod.
     * @example
     * // Create one SeasonalPeriod
     * const SeasonalPeriod = await prisma.seasonalPeriod.create({
     *   data: {
     *     // ... data to create a SeasonalPeriod
     *   }
     * })
     * 
     */
    create<T extends SeasonalPeriodCreateArgs>(args: SelectSubset<T, SeasonalPeriodCreateArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeasonalPeriods.
     * @param {SeasonalPeriodCreateManyArgs} args - Arguments to create many SeasonalPeriods.
     * @example
     * // Create many SeasonalPeriods
     * const seasonalPeriod = await prisma.seasonalPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonalPeriodCreateManyArgs>(args?: SelectSubset<T, SeasonalPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeasonalPeriods and returns the data saved in the database.
     * @param {SeasonalPeriodCreateManyAndReturnArgs} args - Arguments to create many SeasonalPeriods.
     * @example
     * // Create many SeasonalPeriods
     * const seasonalPeriod = await prisma.seasonalPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeasonalPeriods and only return the `id`
     * const seasonalPeriodWithIdOnly = await prisma.seasonalPeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonalPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonalPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeasonalPeriod.
     * @param {SeasonalPeriodDeleteArgs} args - Arguments to delete one SeasonalPeriod.
     * @example
     * // Delete one SeasonalPeriod
     * const SeasonalPeriod = await prisma.seasonalPeriod.delete({
     *   where: {
     *     // ... filter to delete one SeasonalPeriod
     *   }
     * })
     * 
     */
    delete<T extends SeasonalPeriodDeleteArgs>(args: SelectSubset<T, SeasonalPeriodDeleteArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeasonalPeriod.
     * @param {SeasonalPeriodUpdateArgs} args - Arguments to update one SeasonalPeriod.
     * @example
     * // Update one SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonalPeriodUpdateArgs>(args: SelectSubset<T, SeasonalPeriodUpdateArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeasonalPeriods.
     * @param {SeasonalPeriodDeleteManyArgs} args - Arguments to filter SeasonalPeriods to delete.
     * @example
     * // Delete a few SeasonalPeriods
     * const { count } = await prisma.seasonalPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonalPeriodDeleteManyArgs>(args?: SelectSubset<T, SeasonalPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeasonalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeasonalPeriods
     * const seasonalPeriod = await prisma.seasonalPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonalPeriodUpdateManyArgs>(args: SelectSubset<T, SeasonalPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeasonalPeriod.
     * @param {SeasonalPeriodUpsertArgs} args - Arguments to update or create a SeasonalPeriod.
     * @example
     * // Update or create a SeasonalPeriod
     * const seasonalPeriod = await prisma.seasonalPeriod.upsert({
     *   create: {
     *     // ... data to create a SeasonalPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeasonalPeriod we want to update
     *   }
     * })
     */
    upsert<T extends SeasonalPeriodUpsertArgs>(args: SelectSubset<T, SeasonalPeriodUpsertArgs<ExtArgs>>): Prisma__SeasonalPeriodClient<$Result.GetResult<Prisma.$SeasonalPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeasonalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodCountArgs} args - Arguments to filter SeasonalPeriods to count.
     * @example
     * // Count the number of SeasonalPeriods
     * const count = await prisma.seasonalPeriod.count({
     *   where: {
     *     // ... the filter for the SeasonalPeriods we want to count
     *   }
     * })
    **/
    count<T extends SeasonalPeriodCountArgs>(
      args?: Subset<T, SeasonalPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonalPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeasonalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonalPeriodAggregateArgs>(args: Subset<T, SeasonalPeriodAggregateArgs>): Prisma.PrismaPromise<GetSeasonalPeriodAggregateType<T>>

    /**
     * Group by SeasonalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonalPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonalPeriodGroupByArgs['orderBy'] }
        : { orderBy?: SeasonalPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonalPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonalPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeasonalPeriod model
   */
  readonly fields: SeasonalPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeasonalPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonalPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeasonalPeriod model
   */ 
  interface SeasonalPeriodFieldRefs {
    readonly id: FieldRef<"SeasonalPeriod", 'String'>
    readonly name: FieldRef<"SeasonalPeriod", 'String'>
    readonly weather: FieldRef<"SeasonalPeriod", 'String'>
    readonly isActive: FieldRef<"SeasonalPeriod", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SeasonalPeriod findUnique
   */
  export type SeasonalPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter, which SeasonalPeriod to fetch.
     */
    where: SeasonalPeriodWhereUniqueInput
  }

  /**
   * SeasonalPeriod findUniqueOrThrow
   */
  export type SeasonalPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter, which SeasonalPeriod to fetch.
     */
    where: SeasonalPeriodWhereUniqueInput
  }

  /**
   * SeasonalPeriod findFirst
   */
  export type SeasonalPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter, which SeasonalPeriod to fetch.
     */
    where?: SeasonalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPeriods to fetch.
     */
    orderBy?: SeasonalPeriodOrderByWithRelationInput | SeasonalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalPeriods.
     */
    cursor?: SeasonalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalPeriods.
     */
    distinct?: SeasonalPeriodScalarFieldEnum | SeasonalPeriodScalarFieldEnum[]
  }

  /**
   * SeasonalPeriod findFirstOrThrow
   */
  export type SeasonalPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter, which SeasonalPeriod to fetch.
     */
    where?: SeasonalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPeriods to fetch.
     */
    orderBy?: SeasonalPeriodOrderByWithRelationInput | SeasonalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalPeriods.
     */
    cursor?: SeasonalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalPeriods.
     */
    distinct?: SeasonalPeriodScalarFieldEnum | SeasonalPeriodScalarFieldEnum[]
  }

  /**
   * SeasonalPeriod findMany
   */
  export type SeasonalPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter, which SeasonalPeriods to fetch.
     */
    where?: SeasonalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalPeriods to fetch.
     */
    orderBy?: SeasonalPeriodOrderByWithRelationInput | SeasonalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeasonalPeriods.
     */
    cursor?: SeasonalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalPeriods.
     */
    skip?: number
    distinct?: SeasonalPeriodScalarFieldEnum | SeasonalPeriodScalarFieldEnum[]
  }

  /**
   * SeasonalPeriod create
   */
  export type SeasonalPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * The data needed to create a SeasonalPeriod.
     */
    data: XOR<SeasonalPeriodCreateInput, SeasonalPeriodUncheckedCreateInput>
  }

  /**
   * SeasonalPeriod createMany
   */
  export type SeasonalPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeasonalPeriods.
     */
    data: SeasonalPeriodCreateManyInput | SeasonalPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeasonalPeriod createManyAndReturn
   */
  export type SeasonalPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeasonalPeriods.
     */
    data: SeasonalPeriodCreateManyInput | SeasonalPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeasonalPeriod update
   */
  export type SeasonalPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * The data needed to update a SeasonalPeriod.
     */
    data: XOR<SeasonalPeriodUpdateInput, SeasonalPeriodUncheckedUpdateInput>
    /**
     * Choose, which SeasonalPeriod to update.
     */
    where: SeasonalPeriodWhereUniqueInput
  }

  /**
   * SeasonalPeriod updateMany
   */
  export type SeasonalPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeasonalPeriods.
     */
    data: XOR<SeasonalPeriodUpdateManyMutationInput, SeasonalPeriodUncheckedUpdateManyInput>
    /**
     * Filter which SeasonalPeriods to update
     */
    where?: SeasonalPeriodWhereInput
  }

  /**
   * SeasonalPeriod upsert
   */
  export type SeasonalPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * The filter to search for the SeasonalPeriod to update in case it exists.
     */
    where: SeasonalPeriodWhereUniqueInput
    /**
     * In case the SeasonalPeriod found by the `where` argument doesn't exist, create a new SeasonalPeriod with this data.
     */
    create: XOR<SeasonalPeriodCreateInput, SeasonalPeriodUncheckedCreateInput>
    /**
     * In case the SeasonalPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonalPeriodUpdateInput, SeasonalPeriodUncheckedUpdateInput>
  }

  /**
   * SeasonalPeriod delete
   */
  export type SeasonalPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
    /**
     * Filter which SeasonalPeriod to delete.
     */
    where: SeasonalPeriodWhereUniqueInput
  }

  /**
   * SeasonalPeriod deleteMany
   */
  export type SeasonalPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalPeriods to delete
     */
    where?: SeasonalPeriodWhereInput
  }

  /**
   * SeasonalPeriod without action
   */
  export type SeasonalPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalPeriod
     */
    select?: SeasonalPeriodSelect<ExtArgs> | null
  }


  /**
   * Model BookingActivity
   */

  export type AggregateBookingActivity = {
    _count: BookingActivityCountAggregateOutputType | null
    _avg: BookingActivityAvgAggregateOutputType | null
    _sum: BookingActivitySumAggregateOutputType | null
    _min: BookingActivityMinAggregateOutputType | null
    _max: BookingActivityMaxAggregateOutputType | null
  }

  export type BookingActivityAvgAggregateOutputType = {
    bookingId: number | null
    activityId: number | null
  }

  export type BookingActivitySumAggregateOutputType = {
    bookingId: number | null
    activityId: number | null
  }

  export type BookingActivityMinAggregateOutputType = {
    bookingId: number | null
    activityId: number | null
  }

  export type BookingActivityMaxAggregateOutputType = {
    bookingId: number | null
    activityId: number | null
  }

  export type BookingActivityCountAggregateOutputType = {
    bookingId: number
    activityId: number
    _all: number
  }


  export type BookingActivityAvgAggregateInputType = {
    bookingId?: true
    activityId?: true
  }

  export type BookingActivitySumAggregateInputType = {
    bookingId?: true
    activityId?: true
  }

  export type BookingActivityMinAggregateInputType = {
    bookingId?: true
    activityId?: true
  }

  export type BookingActivityMaxAggregateInputType = {
    bookingId?: true
    activityId?: true
  }

  export type BookingActivityCountAggregateInputType = {
    bookingId?: true
    activityId?: true
    _all?: true
  }

  export type BookingActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingActivity to aggregate.
     */
    where?: BookingActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingActivities to fetch.
     */
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingActivities
    **/
    _count?: true | BookingActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingActivityMaxAggregateInputType
  }

  export type GetBookingActivityAggregateType<T extends BookingActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingActivity[P]>
      : GetScalarType<T[P], AggregateBookingActivity[P]>
  }




  export type BookingActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingActivityWhereInput
    orderBy?: BookingActivityOrderByWithAggregationInput | BookingActivityOrderByWithAggregationInput[]
    by: BookingActivityScalarFieldEnum[] | BookingActivityScalarFieldEnum
    having?: BookingActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingActivityCountAggregateInputType | true
    _avg?: BookingActivityAvgAggregateInputType
    _sum?: BookingActivitySumAggregateInputType
    _min?: BookingActivityMinAggregateInputType
    _max?: BookingActivityMaxAggregateInputType
  }

  export type BookingActivityGroupByOutputType = {
    bookingId: number
    activityId: number
    _count: BookingActivityCountAggregateOutputType | null
    _avg: BookingActivityAvgAggregateOutputType | null
    _sum: BookingActivitySumAggregateOutputType | null
    _min: BookingActivityMinAggregateOutputType | null
    _max: BookingActivityMaxAggregateOutputType | null
  }

  type GetBookingActivityGroupByPayload<T extends BookingActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingActivityGroupByOutputType[P]>
            : GetScalarType<T[P], BookingActivityGroupByOutputType[P]>
        }
      >
    >


  export type BookingActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    activityId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingActivity"]>

  export type BookingActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    activityId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingActivity"]>

  export type BookingActivitySelectScalar = {
    bookingId?: boolean
    activityId?: boolean
  }

  export type BookingActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type BookingActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $BookingActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingActivity"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: number
      activityId: number
    }, ExtArgs["result"]["bookingActivity"]>
    composites: {}
  }

  type BookingActivityGetPayload<S extends boolean | null | undefined | BookingActivityDefaultArgs> = $Result.GetResult<Prisma.$BookingActivityPayload, S>

  type BookingActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingActivityCountAggregateInputType | true
    }

  export interface BookingActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingActivity'], meta: { name: 'BookingActivity' } }
    /**
     * Find zero or one BookingActivity that matches the filter.
     * @param {BookingActivityFindUniqueArgs} args - Arguments to find a BookingActivity
     * @example
     * // Get one BookingActivity
     * const bookingActivity = await prisma.bookingActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingActivityFindUniqueArgs>(args: SelectSubset<T, BookingActivityFindUniqueArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingActivityFindUniqueOrThrowArgs} args - Arguments to find a BookingActivity
     * @example
     * // Get one BookingActivity
     * const bookingActivity = await prisma.bookingActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityFindFirstArgs} args - Arguments to find a BookingActivity
     * @example
     * // Get one BookingActivity
     * const bookingActivity = await prisma.bookingActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingActivityFindFirstArgs>(args?: SelectSubset<T, BookingActivityFindFirstArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityFindFirstOrThrowArgs} args - Arguments to find a BookingActivity
     * @example
     * // Get one BookingActivity
     * const bookingActivity = await prisma.bookingActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingActivities
     * const bookingActivities = await prisma.bookingActivity.findMany()
     * 
     * // Get first 10 BookingActivities
     * const bookingActivities = await prisma.bookingActivity.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const bookingActivityWithBookingIdOnly = await prisma.bookingActivity.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends BookingActivityFindManyArgs>(args?: SelectSubset<T, BookingActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingActivity.
     * @param {BookingActivityCreateArgs} args - Arguments to create a BookingActivity.
     * @example
     * // Create one BookingActivity
     * const BookingActivity = await prisma.bookingActivity.create({
     *   data: {
     *     // ... data to create a BookingActivity
     *   }
     * })
     * 
     */
    create<T extends BookingActivityCreateArgs>(args: SelectSubset<T, BookingActivityCreateArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingActivities.
     * @param {BookingActivityCreateManyArgs} args - Arguments to create many BookingActivities.
     * @example
     * // Create many BookingActivities
     * const bookingActivity = await prisma.bookingActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingActivityCreateManyArgs>(args?: SelectSubset<T, BookingActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingActivities and returns the data saved in the database.
     * @param {BookingActivityCreateManyAndReturnArgs} args - Arguments to create many BookingActivities.
     * @example
     * // Create many BookingActivities
     * const bookingActivity = await prisma.bookingActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingActivities and only return the `bookingId`
     * const bookingActivityWithBookingIdOnly = await prisma.bookingActivity.createManyAndReturn({ 
     *   select: { bookingId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BookingActivity.
     * @param {BookingActivityDeleteArgs} args - Arguments to delete one BookingActivity.
     * @example
     * // Delete one BookingActivity
     * const BookingActivity = await prisma.bookingActivity.delete({
     *   where: {
     *     // ... filter to delete one BookingActivity
     *   }
     * })
     * 
     */
    delete<T extends BookingActivityDeleteArgs>(args: SelectSubset<T, BookingActivityDeleteArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingActivity.
     * @param {BookingActivityUpdateArgs} args - Arguments to update one BookingActivity.
     * @example
     * // Update one BookingActivity
     * const bookingActivity = await prisma.bookingActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingActivityUpdateArgs>(args: SelectSubset<T, BookingActivityUpdateArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingActivities.
     * @param {BookingActivityDeleteManyArgs} args - Arguments to filter BookingActivities to delete.
     * @example
     * // Delete a few BookingActivities
     * const { count } = await prisma.bookingActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingActivityDeleteManyArgs>(args?: SelectSubset<T, BookingActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingActivities
     * const bookingActivity = await prisma.bookingActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingActivityUpdateManyArgs>(args: SelectSubset<T, BookingActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingActivity.
     * @param {BookingActivityUpsertArgs} args - Arguments to update or create a BookingActivity.
     * @example
     * // Update or create a BookingActivity
     * const bookingActivity = await prisma.bookingActivity.upsert({
     *   create: {
     *     // ... data to create a BookingActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingActivity we want to update
     *   }
     * })
     */
    upsert<T extends BookingActivityUpsertArgs>(args: SelectSubset<T, BookingActivityUpsertArgs<ExtArgs>>): Prisma__BookingActivityClient<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityCountArgs} args - Arguments to filter BookingActivities to count.
     * @example
     * // Count the number of BookingActivities
     * const count = await prisma.bookingActivity.count({
     *   where: {
     *     // ... the filter for the BookingActivities we want to count
     *   }
     * })
    **/
    count<T extends BookingActivityCountArgs>(
      args?: Subset<T, BookingActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingActivityAggregateArgs>(args: Subset<T, BookingActivityAggregateArgs>): Prisma.PrismaPromise<GetBookingActivityAggregateType<T>>

    /**
     * Group by BookingActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingActivityGroupByArgs['orderBy'] }
        : { orderBy?: BookingActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingActivity model
   */
  readonly fields: BookingActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingActivity model
   */ 
  interface BookingActivityFieldRefs {
    readonly bookingId: FieldRef<"BookingActivity", 'Int'>
    readonly activityId: FieldRef<"BookingActivity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BookingActivity findUnique
   */
  export type BookingActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter, which BookingActivity to fetch.
     */
    where: BookingActivityWhereUniqueInput
  }

  /**
   * BookingActivity findUniqueOrThrow
   */
  export type BookingActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter, which BookingActivity to fetch.
     */
    where: BookingActivityWhereUniqueInput
  }

  /**
   * BookingActivity findFirst
   */
  export type BookingActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter, which BookingActivity to fetch.
     */
    where?: BookingActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingActivities to fetch.
     */
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingActivities.
     */
    cursor?: BookingActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingActivities.
     */
    distinct?: BookingActivityScalarFieldEnum | BookingActivityScalarFieldEnum[]
  }

  /**
   * BookingActivity findFirstOrThrow
   */
  export type BookingActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter, which BookingActivity to fetch.
     */
    where?: BookingActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingActivities to fetch.
     */
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingActivities.
     */
    cursor?: BookingActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingActivities.
     */
    distinct?: BookingActivityScalarFieldEnum | BookingActivityScalarFieldEnum[]
  }

  /**
   * BookingActivity findMany
   */
  export type BookingActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter, which BookingActivities to fetch.
     */
    where?: BookingActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingActivities to fetch.
     */
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingActivities.
     */
    cursor?: BookingActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingActivities.
     */
    skip?: number
    distinct?: BookingActivityScalarFieldEnum | BookingActivityScalarFieldEnum[]
  }

  /**
   * BookingActivity create
   */
  export type BookingActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingActivity.
     */
    data: XOR<BookingActivityCreateInput, BookingActivityUncheckedCreateInput>
  }

  /**
   * BookingActivity createMany
   */
  export type BookingActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingActivities.
     */
    data: BookingActivityCreateManyInput | BookingActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingActivity createManyAndReturn
   */
  export type BookingActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BookingActivities.
     */
    data: BookingActivityCreateManyInput | BookingActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingActivity update
   */
  export type BookingActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingActivity.
     */
    data: XOR<BookingActivityUpdateInput, BookingActivityUncheckedUpdateInput>
    /**
     * Choose, which BookingActivity to update.
     */
    where: BookingActivityWhereUniqueInput
  }

  /**
   * BookingActivity updateMany
   */
  export type BookingActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingActivities.
     */
    data: XOR<BookingActivityUpdateManyMutationInput, BookingActivityUncheckedUpdateManyInput>
    /**
     * Filter which BookingActivities to update
     */
    where?: BookingActivityWhereInput
  }

  /**
   * BookingActivity upsert
   */
  export type BookingActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingActivity to update in case it exists.
     */
    where: BookingActivityWhereUniqueInput
    /**
     * In case the BookingActivity found by the `where` argument doesn't exist, create a new BookingActivity with this data.
     */
    create: XOR<BookingActivityCreateInput, BookingActivityUncheckedCreateInput>
    /**
     * In case the BookingActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingActivityUpdateInput, BookingActivityUncheckedUpdateInput>
  }

  /**
   * BookingActivity delete
   */
  export type BookingActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    /**
     * Filter which BookingActivity to delete.
     */
    where: BookingActivityWhereUniqueInput
  }

  /**
   * BookingActivity deleteMany
   */
  export type BookingActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingActivities to delete
     */
    where?: BookingActivityWhereInput
  }

  /**
   * BookingActivity without action
   */
  export type BookingActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
  }


  /**
   * Model UserInterest
   */

  export type AggregateUserInterest = {
    _count: UserInterestCountAggregateOutputType | null
    _avg: UserInterestAvgAggregateOutputType | null
    _sum: UserInterestSumAggregateOutputType | null
    _min: UserInterestMinAggregateOutputType | null
    _max: UserInterestMaxAggregateOutputType | null
  }

  export type UserInterestAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserInterestSumAggregateOutputType = {
    userId: number | null
  }

  export type UserInterestMinAggregateOutputType = {
    userId: number | null
    interestId: string | null
  }

  export type UserInterestMaxAggregateOutputType = {
    userId: number | null
    interestId: string | null
  }

  export type UserInterestCountAggregateOutputType = {
    userId: number
    interestId: number
    _all: number
  }


  export type UserInterestAvgAggregateInputType = {
    userId?: true
  }

  export type UserInterestSumAggregateInputType = {
    userId?: true
  }

  export type UserInterestMinAggregateInputType = {
    userId?: true
    interestId?: true
  }

  export type UserInterestMaxAggregateInputType = {
    userId?: true
    interestId?: true
  }

  export type UserInterestCountAggregateInputType = {
    userId?: true
    interestId?: true
    _all?: true
  }

  export type UserInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInterest to aggregate.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInterests
    **/
    _count?: true | UserInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInterestMaxAggregateInputType
  }

  export type GetUserInterestAggregateType<T extends UserInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInterest[P]>
      : GetScalarType<T[P], AggregateUserInterest[P]>
  }




  export type UserInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInterestWhereInput
    orderBy?: UserInterestOrderByWithAggregationInput | UserInterestOrderByWithAggregationInput[]
    by: UserInterestScalarFieldEnum[] | UserInterestScalarFieldEnum
    having?: UserInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInterestCountAggregateInputType | true
    _avg?: UserInterestAvgAggregateInputType
    _sum?: UserInterestSumAggregateInputType
    _min?: UserInterestMinAggregateInputType
    _max?: UserInterestMaxAggregateInputType
  }

  export type UserInterestGroupByOutputType = {
    userId: number
    interestId: string
    _count: UserInterestCountAggregateOutputType | null
    _avg: UserInterestAvgAggregateOutputType | null
    _sum: UserInterestSumAggregateOutputType | null
    _min: UserInterestMinAggregateOutputType | null
    _max: UserInterestMaxAggregateOutputType | null
  }

  type GetUserInterestGroupByPayload<T extends UserInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInterestGroupByOutputType[P]>
            : GetScalarType<T[P], UserInterestGroupByOutputType[P]>
        }
      >
    >


  export type UserInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInterest"]>

  export type UserInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInterest"]>

  export type UserInterestSelectScalar = {
    userId?: boolean
    interestId?: boolean
  }

  export type UserInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }
  export type UserInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserAccountDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }

  export type $UserInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInterest"
    objects: {
      user: Prisma.$UserAccountPayload<ExtArgs>
      interest: Prisma.$TravelInterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      interestId: string
    }, ExtArgs["result"]["userInterest"]>
    composites: {}
  }

  type UserInterestGetPayload<S extends boolean | null | undefined | UserInterestDefaultArgs> = $Result.GetResult<Prisma.$UserInterestPayload, S>

  type UserInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserInterestCountAggregateInputType | true
    }

  export interface UserInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInterest'], meta: { name: 'UserInterest' } }
    /**
     * Find zero or one UserInterest that matches the filter.
     * @param {UserInterestFindUniqueArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInterestFindUniqueArgs>(args: SelectSubset<T, UserInterestFindUniqueArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserInterest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserInterestFindUniqueOrThrowArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindFirstArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInterestFindFirstArgs>(args?: SelectSubset<T, UserInterestFindFirstArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindFirstOrThrowArgs} args - Arguments to find a UserInterest
     * @example
     * // Get one UserInterest
     * const userInterest = await prisma.userInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInterests
     * const userInterests = await prisma.userInterest.findMany()
     * 
     * // Get first 10 UserInterests
     * const userInterests = await prisma.userInterest.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userInterestWithUserIdOnly = await prisma.userInterest.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserInterestFindManyArgs>(args?: SelectSubset<T, UserInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserInterest.
     * @param {UserInterestCreateArgs} args - Arguments to create a UserInterest.
     * @example
     * // Create one UserInterest
     * const UserInterest = await prisma.userInterest.create({
     *   data: {
     *     // ... data to create a UserInterest
     *   }
     * })
     * 
     */
    create<T extends UserInterestCreateArgs>(args: SelectSubset<T, UserInterestCreateArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserInterests.
     * @param {UserInterestCreateManyArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterest = await prisma.userInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInterestCreateManyArgs>(args?: SelectSubset<T, UserInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInterests and returns the data saved in the database.
     * @param {UserInterestCreateManyAndReturnArgs} args - Arguments to create many UserInterests.
     * @example
     * // Create many UserInterests
     * const userInterest = await prisma.userInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInterests and only return the `userId`
     * const userInterestWithUserIdOnly = await prisma.userInterest.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserInterest.
     * @param {UserInterestDeleteArgs} args - Arguments to delete one UserInterest.
     * @example
     * // Delete one UserInterest
     * const UserInterest = await prisma.userInterest.delete({
     *   where: {
     *     // ... filter to delete one UserInterest
     *   }
     * })
     * 
     */
    delete<T extends UserInterestDeleteArgs>(args: SelectSubset<T, UserInterestDeleteArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserInterest.
     * @param {UserInterestUpdateArgs} args - Arguments to update one UserInterest.
     * @example
     * // Update one UserInterest
     * const userInterest = await prisma.userInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInterestUpdateArgs>(args: SelectSubset<T, UserInterestUpdateArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserInterests.
     * @param {UserInterestDeleteManyArgs} args - Arguments to filter UserInterests to delete.
     * @example
     * // Delete a few UserInterests
     * const { count } = await prisma.userInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInterestDeleteManyArgs>(args?: SelectSubset<T, UserInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInterests
     * const userInterest = await prisma.userInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInterestUpdateManyArgs>(args: SelectSubset<T, UserInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserInterest.
     * @param {UserInterestUpsertArgs} args - Arguments to update or create a UserInterest.
     * @example
     * // Update or create a UserInterest
     * const userInterest = await prisma.userInterest.upsert({
     *   create: {
     *     // ... data to create a UserInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInterest we want to update
     *   }
     * })
     */
    upsert<T extends UserInterestUpsertArgs>(args: SelectSubset<T, UserInterestUpsertArgs<ExtArgs>>): Prisma__UserInterestClient<$Result.GetResult<Prisma.$UserInterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestCountArgs} args - Arguments to filter UserInterests to count.
     * @example
     * // Count the number of UserInterests
     * const count = await prisma.userInterest.count({
     *   where: {
     *     // ... the filter for the UserInterests we want to count
     *   }
     * })
    **/
    count<T extends UserInterestCountArgs>(
      args?: Subset<T, UserInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInterestAggregateArgs>(args: Subset<T, UserInterestAggregateArgs>): Prisma.PrismaPromise<GetUserInterestAggregateType<T>>

    /**
     * Group by UserInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInterestGroupByArgs['orderBy'] }
        : { orderBy?: UserInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInterest model
   */
  readonly fields: UserInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserAccountDefaultArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interest<T extends TravelInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TravelInterestDefaultArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInterest model
   */ 
  interface UserInterestFieldRefs {
    readonly userId: FieldRef<"UserInterest", 'Int'>
    readonly interestId: FieldRef<"UserInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserInterest findUnique
   */
  export type UserInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest findUniqueOrThrow
   */
  export type UserInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest findFirst
   */
  export type UserInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest findFirstOrThrow
   */
  export type UserInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterest to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInterests.
     */
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest findMany
   */
  export type UserInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter, which UserInterests to fetch.
     */
    where?: UserInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInterests to fetch.
     */
    orderBy?: UserInterestOrderByWithRelationInput | UserInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInterests.
     */
    cursor?: UserInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInterests.
     */
    skip?: number
    distinct?: UserInterestScalarFieldEnum | UserInterestScalarFieldEnum[]
  }

  /**
   * UserInterest create
   */
  export type UserInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInterest.
     */
    data: XOR<UserInterestCreateInput, UserInterestUncheckedCreateInput>
  }

  /**
   * UserInterest createMany
   */
  export type UserInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestCreateManyInput | UserInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInterest createManyAndReturn
   */
  export type UserInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserInterests.
     */
    data: UserInterestCreateManyInput | UserInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInterest update
   */
  export type UserInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInterest.
     */
    data: XOR<UserInterestUpdateInput, UserInterestUncheckedUpdateInput>
    /**
     * Choose, which UserInterest to update.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest updateMany
   */
  export type UserInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInterests.
     */
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyInput>
    /**
     * Filter which UserInterests to update
     */
    where?: UserInterestWhereInput
  }

  /**
   * UserInterest upsert
   */
  export type UserInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInterest to update in case it exists.
     */
    where: UserInterestWhereUniqueInput
    /**
     * In case the UserInterest found by the `where` argument doesn't exist, create a new UserInterest with this data.
     */
    create: XOR<UserInterestCreateInput, UserInterestUncheckedCreateInput>
    /**
     * In case the UserInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInterestUpdateInput, UserInterestUncheckedUpdateInput>
  }

  /**
   * UserInterest delete
   */
  export type UserInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
    /**
     * Filter which UserInterest to delete.
     */
    where: UserInterestWhereUniqueInput
  }

  /**
   * UserInterest deleteMany
   */
  export type UserInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInterests to delete
     */
    where?: UserInterestWhereInput
  }

  /**
   * UserInterest without action
   */
  export type UserInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInterest
     */
    select?: UserInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInterestInclude<ExtArgs> | null
  }


  /**
   * Model CustomTourInterest
   */

  export type AggregateCustomTourInterest = {
    _count: CustomTourInterestCountAggregateOutputType | null
    _avg: CustomTourInterestAvgAggregateOutputType | null
    _sum: CustomTourInterestSumAggregateOutputType | null
    _min: CustomTourInterestMinAggregateOutputType | null
    _max: CustomTourInterestMaxAggregateOutputType | null
  }

  export type CustomTourInterestAvgAggregateOutputType = {
    customTourRequestId: number | null
  }

  export type CustomTourInterestSumAggregateOutputType = {
    customTourRequestId: number | null
  }

  export type CustomTourInterestMinAggregateOutputType = {
    customTourRequestId: number | null
    interestId: string | null
  }

  export type CustomTourInterestMaxAggregateOutputType = {
    customTourRequestId: number | null
    interestId: string | null
  }

  export type CustomTourInterestCountAggregateOutputType = {
    customTourRequestId: number
    interestId: number
    _all: number
  }


  export type CustomTourInterestAvgAggregateInputType = {
    customTourRequestId?: true
  }

  export type CustomTourInterestSumAggregateInputType = {
    customTourRequestId?: true
  }

  export type CustomTourInterestMinAggregateInputType = {
    customTourRequestId?: true
    interestId?: true
  }

  export type CustomTourInterestMaxAggregateInputType = {
    customTourRequestId?: true
    interestId?: true
  }

  export type CustomTourInterestCountAggregateInputType = {
    customTourRequestId?: true
    interestId?: true
    _all?: true
  }

  export type CustomTourInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourInterest to aggregate.
     */
    where?: CustomTourInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourInterests to fetch.
     */
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomTourInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomTourInterests
    **/
    _count?: true | CustomTourInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomTourInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomTourInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomTourInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomTourInterestMaxAggregateInputType
  }

  export type GetCustomTourInterestAggregateType<T extends CustomTourInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomTourInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomTourInterest[P]>
      : GetScalarType<T[P], AggregateCustomTourInterest[P]>
  }




  export type CustomTourInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomTourInterestWhereInput
    orderBy?: CustomTourInterestOrderByWithAggregationInput | CustomTourInterestOrderByWithAggregationInput[]
    by: CustomTourInterestScalarFieldEnum[] | CustomTourInterestScalarFieldEnum
    having?: CustomTourInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomTourInterestCountAggregateInputType | true
    _avg?: CustomTourInterestAvgAggregateInputType
    _sum?: CustomTourInterestSumAggregateInputType
    _min?: CustomTourInterestMinAggregateInputType
    _max?: CustomTourInterestMaxAggregateInputType
  }

  export type CustomTourInterestGroupByOutputType = {
    customTourRequestId: number
    interestId: string
    _count: CustomTourInterestCountAggregateOutputType | null
    _avg: CustomTourInterestAvgAggregateOutputType | null
    _sum: CustomTourInterestSumAggregateOutputType | null
    _min: CustomTourInterestMinAggregateOutputType | null
    _max: CustomTourInterestMaxAggregateOutputType | null
  }

  type GetCustomTourInterestGroupByPayload<T extends CustomTourInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomTourInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomTourInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomTourInterestGroupByOutputType[P]>
            : GetScalarType<T[P], CustomTourInterestGroupByOutputType[P]>
        }
      >
    >


  export type CustomTourInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customTourRequestId?: boolean
    interestId?: boolean
    customTourRequest?: boolean | CustomTourRequestDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customTourInterest"]>

  export type CustomTourInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customTourRequestId?: boolean
    interestId?: boolean
    customTourRequest?: boolean | CustomTourRequestDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customTourInterest"]>

  export type CustomTourInterestSelectScalar = {
    customTourRequestId?: boolean
    interestId?: boolean
  }

  export type CustomTourInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customTourRequest?: boolean | CustomTourRequestDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }
  export type CustomTourInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customTourRequest?: boolean | CustomTourRequestDefaultArgs<ExtArgs>
    interest?: boolean | TravelInterestDefaultArgs<ExtArgs>
  }

  export type $CustomTourInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomTourInterest"
    objects: {
      customTourRequest: Prisma.$CustomTourRequestPayload<ExtArgs>
      interest: Prisma.$TravelInterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      customTourRequestId: number
      interestId: string
    }, ExtArgs["result"]["customTourInterest"]>
    composites: {}
  }

  type CustomTourInterestGetPayload<S extends boolean | null | undefined | CustomTourInterestDefaultArgs> = $Result.GetResult<Prisma.$CustomTourInterestPayload, S>

  type CustomTourInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomTourInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomTourInterestCountAggregateInputType | true
    }

  export interface CustomTourInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomTourInterest'], meta: { name: 'CustomTourInterest' } }
    /**
     * Find zero or one CustomTourInterest that matches the filter.
     * @param {CustomTourInterestFindUniqueArgs} args - Arguments to find a CustomTourInterest
     * @example
     * // Get one CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomTourInterestFindUniqueArgs>(args: SelectSubset<T, CustomTourInterestFindUniqueArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomTourInterest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomTourInterestFindUniqueOrThrowArgs} args - Arguments to find a CustomTourInterest
     * @example
     * // Get one CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomTourInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomTourInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomTourInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestFindFirstArgs} args - Arguments to find a CustomTourInterest
     * @example
     * // Get one CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomTourInterestFindFirstArgs>(args?: SelectSubset<T, CustomTourInterestFindFirstArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomTourInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestFindFirstOrThrowArgs} args - Arguments to find a CustomTourInterest
     * @example
     * // Get one CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomTourInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomTourInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomTourInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomTourInterests
     * const customTourInterests = await prisma.customTourInterest.findMany()
     * 
     * // Get first 10 CustomTourInterests
     * const customTourInterests = await prisma.customTourInterest.findMany({ take: 10 })
     * 
     * // Only select the `customTourRequestId`
     * const customTourInterestWithCustomTourRequestIdOnly = await prisma.customTourInterest.findMany({ select: { customTourRequestId: true } })
     * 
     */
    findMany<T extends CustomTourInterestFindManyArgs>(args?: SelectSubset<T, CustomTourInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomTourInterest.
     * @param {CustomTourInterestCreateArgs} args - Arguments to create a CustomTourInterest.
     * @example
     * // Create one CustomTourInterest
     * const CustomTourInterest = await prisma.customTourInterest.create({
     *   data: {
     *     // ... data to create a CustomTourInterest
     *   }
     * })
     * 
     */
    create<T extends CustomTourInterestCreateArgs>(args: SelectSubset<T, CustomTourInterestCreateArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomTourInterests.
     * @param {CustomTourInterestCreateManyArgs} args - Arguments to create many CustomTourInterests.
     * @example
     * // Create many CustomTourInterests
     * const customTourInterest = await prisma.customTourInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomTourInterestCreateManyArgs>(args?: SelectSubset<T, CustomTourInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomTourInterests and returns the data saved in the database.
     * @param {CustomTourInterestCreateManyAndReturnArgs} args - Arguments to create many CustomTourInterests.
     * @example
     * // Create many CustomTourInterests
     * const customTourInterest = await prisma.customTourInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomTourInterests and only return the `customTourRequestId`
     * const customTourInterestWithCustomTourRequestIdOnly = await prisma.customTourInterest.createManyAndReturn({ 
     *   select: { customTourRequestId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomTourInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomTourInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomTourInterest.
     * @param {CustomTourInterestDeleteArgs} args - Arguments to delete one CustomTourInterest.
     * @example
     * // Delete one CustomTourInterest
     * const CustomTourInterest = await prisma.customTourInterest.delete({
     *   where: {
     *     // ... filter to delete one CustomTourInterest
     *   }
     * })
     * 
     */
    delete<T extends CustomTourInterestDeleteArgs>(args: SelectSubset<T, CustomTourInterestDeleteArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomTourInterest.
     * @param {CustomTourInterestUpdateArgs} args - Arguments to update one CustomTourInterest.
     * @example
     * // Update one CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomTourInterestUpdateArgs>(args: SelectSubset<T, CustomTourInterestUpdateArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomTourInterests.
     * @param {CustomTourInterestDeleteManyArgs} args - Arguments to filter CustomTourInterests to delete.
     * @example
     * // Delete a few CustomTourInterests
     * const { count } = await prisma.customTourInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomTourInterestDeleteManyArgs>(args?: SelectSubset<T, CustomTourInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomTourInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomTourInterests
     * const customTourInterest = await prisma.customTourInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomTourInterestUpdateManyArgs>(args: SelectSubset<T, CustomTourInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomTourInterest.
     * @param {CustomTourInterestUpsertArgs} args - Arguments to update or create a CustomTourInterest.
     * @example
     * // Update or create a CustomTourInterest
     * const customTourInterest = await prisma.customTourInterest.upsert({
     *   create: {
     *     // ... data to create a CustomTourInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomTourInterest we want to update
     *   }
     * })
     */
    upsert<T extends CustomTourInterestUpsertArgs>(args: SelectSubset<T, CustomTourInterestUpsertArgs<ExtArgs>>): Prisma__CustomTourInterestClient<$Result.GetResult<Prisma.$CustomTourInterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomTourInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestCountArgs} args - Arguments to filter CustomTourInterests to count.
     * @example
     * // Count the number of CustomTourInterests
     * const count = await prisma.customTourInterest.count({
     *   where: {
     *     // ... the filter for the CustomTourInterests we want to count
     *   }
     * })
    **/
    count<T extends CustomTourInterestCountArgs>(
      args?: Subset<T, CustomTourInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomTourInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomTourInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomTourInterestAggregateArgs>(args: Subset<T, CustomTourInterestAggregateArgs>): Prisma.PrismaPromise<GetCustomTourInterestAggregateType<T>>

    /**
     * Group by CustomTourInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomTourInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomTourInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomTourInterestGroupByArgs['orderBy'] }
        : { orderBy?: CustomTourInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomTourInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomTourInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomTourInterest model
   */
  readonly fields: CustomTourInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomTourInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomTourInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customTourRequest<T extends CustomTourRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomTourRequestDefaultArgs<ExtArgs>>): Prisma__CustomTourRequestClient<$Result.GetResult<Prisma.$CustomTourRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interest<T extends TravelInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TravelInterestDefaultArgs<ExtArgs>>): Prisma__TravelInterestClient<$Result.GetResult<Prisma.$TravelInterestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomTourInterest model
   */ 
  interface CustomTourInterestFieldRefs {
    readonly customTourRequestId: FieldRef<"CustomTourInterest", 'Int'>
    readonly interestId: FieldRef<"CustomTourInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomTourInterest findUnique
   */
  export type CustomTourInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourInterest to fetch.
     */
    where: CustomTourInterestWhereUniqueInput
  }

  /**
   * CustomTourInterest findUniqueOrThrow
   */
  export type CustomTourInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourInterest to fetch.
     */
    where: CustomTourInterestWhereUniqueInput
  }

  /**
   * CustomTourInterest findFirst
   */
  export type CustomTourInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourInterest to fetch.
     */
    where?: CustomTourInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourInterests to fetch.
     */
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourInterests.
     */
    cursor?: CustomTourInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourInterests.
     */
    distinct?: CustomTourInterestScalarFieldEnum | CustomTourInterestScalarFieldEnum[]
  }

  /**
   * CustomTourInterest findFirstOrThrow
   */
  export type CustomTourInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourInterest to fetch.
     */
    where?: CustomTourInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourInterests to fetch.
     */
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomTourInterests.
     */
    cursor?: CustomTourInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomTourInterests.
     */
    distinct?: CustomTourInterestScalarFieldEnum | CustomTourInterestScalarFieldEnum[]
  }

  /**
   * CustomTourInterest findMany
   */
  export type CustomTourInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter, which CustomTourInterests to fetch.
     */
    where?: CustomTourInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomTourInterests to fetch.
     */
    orderBy?: CustomTourInterestOrderByWithRelationInput | CustomTourInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomTourInterests.
     */
    cursor?: CustomTourInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomTourInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomTourInterests.
     */
    skip?: number
    distinct?: CustomTourInterestScalarFieldEnum | CustomTourInterestScalarFieldEnum[]
  }

  /**
   * CustomTourInterest create
   */
  export type CustomTourInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomTourInterest.
     */
    data: XOR<CustomTourInterestCreateInput, CustomTourInterestUncheckedCreateInput>
  }

  /**
   * CustomTourInterest createMany
   */
  export type CustomTourInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomTourInterests.
     */
    data: CustomTourInterestCreateManyInput | CustomTourInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomTourInterest createManyAndReturn
   */
  export type CustomTourInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomTourInterests.
     */
    data: CustomTourInterestCreateManyInput | CustomTourInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomTourInterest update
   */
  export type CustomTourInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomTourInterest.
     */
    data: XOR<CustomTourInterestUpdateInput, CustomTourInterestUncheckedUpdateInput>
    /**
     * Choose, which CustomTourInterest to update.
     */
    where: CustomTourInterestWhereUniqueInput
  }

  /**
   * CustomTourInterest updateMany
   */
  export type CustomTourInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomTourInterests.
     */
    data: XOR<CustomTourInterestUpdateManyMutationInput, CustomTourInterestUncheckedUpdateManyInput>
    /**
     * Filter which CustomTourInterests to update
     */
    where?: CustomTourInterestWhereInput
  }

  /**
   * CustomTourInterest upsert
   */
  export type CustomTourInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomTourInterest to update in case it exists.
     */
    where: CustomTourInterestWhereUniqueInput
    /**
     * In case the CustomTourInterest found by the `where` argument doesn't exist, create a new CustomTourInterest with this data.
     */
    create: XOR<CustomTourInterestCreateInput, CustomTourInterestUncheckedCreateInput>
    /**
     * In case the CustomTourInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomTourInterestUpdateInput, CustomTourInterestUncheckedUpdateInput>
  }

  /**
   * CustomTourInterest delete
   */
  export type CustomTourInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
    /**
     * Filter which CustomTourInterest to delete.
     */
    where: CustomTourInterestWhereUniqueInput
  }

  /**
   * CustomTourInterest deleteMany
   */
  export type CustomTourInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomTourInterests to delete
     */
    where?: CustomTourInterestWhereInput
  }

  /**
   * CustomTourInterest without action
   */
  export type CustomTourInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomTourInterest
     */
    select?: CustomTourInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomTourInterestInclude<ExtArgs> | null
  }


  /**
   * Model FlightBooking
   */

  export type AggregateFlightBooking = {
    _count: FlightBookingCountAggregateOutputType | null
    _avg: FlightBookingAvgAggregateOutputType | null
    _sum: FlightBookingSumAggregateOutputType | null
    _min: FlightBookingMinAggregateOutputType | null
    _max: FlightBookingMaxAggregateOutputType | null
  }

  export type FlightBookingAvgAggregateOutputType = {
    id: number | null
    numberOfPassengers: number | null
    totalAmount: number | null
  }

  export type FlightBookingSumAggregateOutputType = {
    id: number | null
    numberOfPassengers: number | null
    totalAmount: number | null
  }

  export type FlightBookingMinAggregateOutputType = {
    id: number | null
    flightRouteId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    departureDate: Date | null
    returnDate: Date | null
    numberOfPassengers: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type FlightBookingMaxAggregateOutputType = {
    id: number | null
    flightRouteId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    departureDate: Date | null
    returnDate: Date | null
    numberOfPassengers: number | null
    totalAmount: number | null
    specialRequests: string | null
    status: string | null
    paymentStatus: string | null
    createdAt: Date | null
  }

  export type FlightBookingCountAggregateOutputType = {
    id: number
    flightRouteId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    departureDate: number
    returnDate: number
    numberOfPassengers: number
    totalAmount: number
    specialRequests: number
    status: number
    paymentStatus: number
    createdAt: number
    _all: number
  }


  export type FlightBookingAvgAggregateInputType = {
    id?: true
    numberOfPassengers?: true
    totalAmount?: true
  }

  export type FlightBookingSumAggregateInputType = {
    id?: true
    numberOfPassengers?: true
    totalAmount?: true
  }

  export type FlightBookingMinAggregateInputType = {
    id?: true
    flightRouteId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    departureDate?: true
    returnDate?: true
    numberOfPassengers?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type FlightBookingMaxAggregateInputType = {
    id?: true
    flightRouteId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    departureDate?: true
    returnDate?: true
    numberOfPassengers?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
  }

  export type FlightBookingCountAggregateInputType = {
    id?: true
    flightRouteId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    departureDate?: true
    returnDate?: true
    numberOfPassengers?: true
    totalAmount?: true
    specialRequests?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    _all?: true
  }

  export type FlightBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightBooking to aggregate.
     */
    where?: FlightBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightBookings to fetch.
     */
    orderBy?: FlightBookingOrderByWithRelationInput | FlightBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlightBookings
    **/
    _count?: true | FlightBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightBookingMaxAggregateInputType
  }

  export type GetFlightBookingAggregateType<T extends FlightBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateFlightBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlightBooking[P]>
      : GetScalarType<T[P], AggregateFlightBooking[P]>
  }




  export type FlightBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightBookingWhereInput
    orderBy?: FlightBookingOrderByWithAggregationInput | FlightBookingOrderByWithAggregationInput[]
    by: FlightBookingScalarFieldEnum[] | FlightBookingScalarFieldEnum
    having?: FlightBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightBookingCountAggregateInputType | true
    _avg?: FlightBookingAvgAggregateInputType
    _sum?: FlightBookingSumAggregateInputType
    _min?: FlightBookingMinAggregateInputType
    _max?: FlightBookingMaxAggregateInputType
  }

  export type FlightBookingGroupByOutputType = {
    id: number
    flightRouteId: string
    firstName: string
    lastName: string
    email: string
    phone: string | null
    departureDate: Date
    returnDate: Date | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests: string | null
    status: string
    paymentStatus: string
    createdAt: Date
    _count: FlightBookingCountAggregateOutputType | null
    _avg: FlightBookingAvgAggregateOutputType | null
    _sum: FlightBookingSumAggregateOutputType | null
    _min: FlightBookingMinAggregateOutputType | null
    _max: FlightBookingMaxAggregateOutputType | null
  }

  type GetFlightBookingGroupByPayload<T extends FlightBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightBookingGroupByOutputType[P]>
            : GetScalarType<T[P], FlightBookingGroupByOutputType[P]>
        }
      >
    >


  export type FlightBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightRouteId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    departureDate?: boolean
    returnDate?: boolean
    numberOfPassengers?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    flightRoute?: boolean | FlightRouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightBooking"]>

  export type FlightBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightRouteId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    departureDate?: boolean
    returnDate?: boolean
    numberOfPassengers?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    flightRoute?: boolean | FlightRouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightBooking"]>

  export type FlightBookingSelectScalar = {
    id?: boolean
    flightRouteId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    departureDate?: boolean
    returnDate?: boolean
    numberOfPassengers?: boolean
    totalAmount?: boolean
    specialRequests?: boolean
    status?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
  }

  export type FlightBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightRoute?: boolean | FlightRouteDefaultArgs<ExtArgs>
  }
  export type FlightBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightRoute?: boolean | FlightRouteDefaultArgs<ExtArgs>
  }

  export type $FlightBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlightBooking"
    objects: {
      flightRoute: Prisma.$FlightRoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      flightRouteId: string
      firstName: string
      lastName: string
      email: string
      phone: string | null
      departureDate: Date
      returnDate: Date | null
      numberOfPassengers: number
      totalAmount: number
      specialRequests: string | null
      status: string
      paymentStatus: string
      createdAt: Date
    }, ExtArgs["result"]["flightBooking"]>
    composites: {}
  }

  type FlightBookingGetPayload<S extends boolean | null | undefined | FlightBookingDefaultArgs> = $Result.GetResult<Prisma.$FlightBookingPayload, S>

  type FlightBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlightBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlightBookingCountAggregateInputType | true
    }

  export interface FlightBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlightBooking'], meta: { name: 'FlightBooking' } }
    /**
     * Find zero or one FlightBooking that matches the filter.
     * @param {FlightBookingFindUniqueArgs} args - Arguments to find a FlightBooking
     * @example
     * // Get one FlightBooking
     * const flightBooking = await prisma.flightBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightBookingFindUniqueArgs>(args: SelectSubset<T, FlightBookingFindUniqueArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlightBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlightBookingFindUniqueOrThrowArgs} args - Arguments to find a FlightBooking
     * @example
     * // Get one FlightBooking
     * const flightBooking = await prisma.flightBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlightBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingFindFirstArgs} args - Arguments to find a FlightBooking
     * @example
     * // Get one FlightBooking
     * const flightBooking = await prisma.flightBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightBookingFindFirstArgs>(args?: SelectSubset<T, FlightBookingFindFirstArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlightBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingFindFirstOrThrowArgs} args - Arguments to find a FlightBooking
     * @example
     * // Get one FlightBooking
     * const flightBooking = await prisma.flightBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlightBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlightBookings
     * const flightBookings = await prisma.flightBooking.findMany()
     * 
     * // Get first 10 FlightBookings
     * const flightBookings = await prisma.flightBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightBookingWithIdOnly = await prisma.flightBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightBookingFindManyArgs>(args?: SelectSubset<T, FlightBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlightBooking.
     * @param {FlightBookingCreateArgs} args - Arguments to create a FlightBooking.
     * @example
     * // Create one FlightBooking
     * const FlightBooking = await prisma.flightBooking.create({
     *   data: {
     *     // ... data to create a FlightBooking
     *   }
     * })
     * 
     */
    create<T extends FlightBookingCreateArgs>(args: SelectSubset<T, FlightBookingCreateArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlightBookings.
     * @param {FlightBookingCreateManyArgs} args - Arguments to create many FlightBookings.
     * @example
     * // Create many FlightBookings
     * const flightBooking = await prisma.flightBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightBookingCreateManyArgs>(args?: SelectSubset<T, FlightBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlightBookings and returns the data saved in the database.
     * @param {FlightBookingCreateManyAndReturnArgs} args - Arguments to create many FlightBookings.
     * @example
     * // Create many FlightBookings
     * const flightBooking = await prisma.flightBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlightBookings and only return the `id`
     * const flightBookingWithIdOnly = await prisma.flightBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlightBooking.
     * @param {FlightBookingDeleteArgs} args - Arguments to delete one FlightBooking.
     * @example
     * // Delete one FlightBooking
     * const FlightBooking = await prisma.flightBooking.delete({
     *   where: {
     *     // ... filter to delete one FlightBooking
     *   }
     * })
     * 
     */
    delete<T extends FlightBookingDeleteArgs>(args: SelectSubset<T, FlightBookingDeleteArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlightBooking.
     * @param {FlightBookingUpdateArgs} args - Arguments to update one FlightBooking.
     * @example
     * // Update one FlightBooking
     * const flightBooking = await prisma.flightBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightBookingUpdateArgs>(args: SelectSubset<T, FlightBookingUpdateArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlightBookings.
     * @param {FlightBookingDeleteManyArgs} args - Arguments to filter FlightBookings to delete.
     * @example
     * // Delete a few FlightBookings
     * const { count } = await prisma.flightBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightBookingDeleteManyArgs>(args?: SelectSubset<T, FlightBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlightBookings
     * const flightBooking = await prisma.flightBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightBookingUpdateManyArgs>(args: SelectSubset<T, FlightBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlightBooking.
     * @param {FlightBookingUpsertArgs} args - Arguments to update or create a FlightBooking.
     * @example
     * // Update or create a FlightBooking
     * const flightBooking = await prisma.flightBooking.upsert({
     *   create: {
     *     // ... data to create a FlightBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlightBooking we want to update
     *   }
     * })
     */
    upsert<T extends FlightBookingUpsertArgs>(args: SelectSubset<T, FlightBookingUpsertArgs<ExtArgs>>): Prisma__FlightBookingClient<$Result.GetResult<Prisma.$FlightBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlightBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingCountArgs} args - Arguments to filter FlightBookings to count.
     * @example
     * // Count the number of FlightBookings
     * const count = await prisma.flightBooking.count({
     *   where: {
     *     // ... the filter for the FlightBookings we want to count
     *   }
     * })
    **/
    count<T extends FlightBookingCountArgs>(
      args?: Subset<T, FlightBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlightBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightBookingAggregateArgs>(args: Subset<T, FlightBookingAggregateArgs>): Prisma.PrismaPromise<GetFlightBookingAggregateType<T>>

    /**
     * Group by FlightBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightBookingGroupByArgs['orderBy'] }
        : { orderBy?: FlightBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlightBooking model
   */
  readonly fields: FlightBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlightBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flightRoute<T extends FlightRouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlightRouteDefaultArgs<ExtArgs>>): Prisma__FlightRouteClient<$Result.GetResult<Prisma.$FlightRoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlightBooking model
   */ 
  interface FlightBookingFieldRefs {
    readonly id: FieldRef<"FlightBooking", 'Int'>
    readonly flightRouteId: FieldRef<"FlightBooking", 'String'>
    readonly firstName: FieldRef<"FlightBooking", 'String'>
    readonly lastName: FieldRef<"FlightBooking", 'String'>
    readonly email: FieldRef<"FlightBooking", 'String'>
    readonly phone: FieldRef<"FlightBooking", 'String'>
    readonly departureDate: FieldRef<"FlightBooking", 'DateTime'>
    readonly returnDate: FieldRef<"FlightBooking", 'DateTime'>
    readonly numberOfPassengers: FieldRef<"FlightBooking", 'Int'>
    readonly totalAmount: FieldRef<"FlightBooking", 'Int'>
    readonly specialRequests: FieldRef<"FlightBooking", 'String'>
    readonly status: FieldRef<"FlightBooking", 'String'>
    readonly paymentStatus: FieldRef<"FlightBooking", 'String'>
    readonly createdAt: FieldRef<"FlightBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlightBooking findUnique
   */
  export type FlightBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter, which FlightBooking to fetch.
     */
    where: FlightBookingWhereUniqueInput
  }

  /**
   * FlightBooking findUniqueOrThrow
   */
  export type FlightBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter, which FlightBooking to fetch.
     */
    where: FlightBookingWhereUniqueInput
  }

  /**
   * FlightBooking findFirst
   */
  export type FlightBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter, which FlightBooking to fetch.
     */
    where?: FlightBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightBookings to fetch.
     */
    orderBy?: FlightBookingOrderByWithRelationInput | FlightBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightBookings.
     */
    cursor?: FlightBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightBookings.
     */
    distinct?: FlightBookingScalarFieldEnum | FlightBookingScalarFieldEnum[]
  }

  /**
   * FlightBooking findFirstOrThrow
   */
  export type FlightBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter, which FlightBooking to fetch.
     */
    where?: FlightBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightBookings to fetch.
     */
    orderBy?: FlightBookingOrderByWithRelationInput | FlightBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightBookings.
     */
    cursor?: FlightBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightBookings.
     */
    distinct?: FlightBookingScalarFieldEnum | FlightBookingScalarFieldEnum[]
  }

  /**
   * FlightBooking findMany
   */
  export type FlightBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter, which FlightBookings to fetch.
     */
    where?: FlightBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightBookings to fetch.
     */
    orderBy?: FlightBookingOrderByWithRelationInput | FlightBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlightBookings.
     */
    cursor?: FlightBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightBookings.
     */
    skip?: number
    distinct?: FlightBookingScalarFieldEnum | FlightBookingScalarFieldEnum[]
  }

  /**
   * FlightBooking create
   */
  export type FlightBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a FlightBooking.
     */
    data: XOR<FlightBookingCreateInput, FlightBookingUncheckedCreateInput>
  }

  /**
   * FlightBooking createMany
   */
  export type FlightBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlightBookings.
     */
    data: FlightBookingCreateManyInput | FlightBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlightBooking createManyAndReturn
   */
  export type FlightBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlightBookings.
     */
    data: FlightBookingCreateManyInput | FlightBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlightBooking update
   */
  export type FlightBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a FlightBooking.
     */
    data: XOR<FlightBookingUpdateInput, FlightBookingUncheckedUpdateInput>
    /**
     * Choose, which FlightBooking to update.
     */
    where: FlightBookingWhereUniqueInput
  }

  /**
   * FlightBooking updateMany
   */
  export type FlightBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlightBookings.
     */
    data: XOR<FlightBookingUpdateManyMutationInput, FlightBookingUncheckedUpdateManyInput>
    /**
     * Filter which FlightBookings to update
     */
    where?: FlightBookingWhereInput
  }

  /**
   * FlightBooking upsert
   */
  export type FlightBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the FlightBooking to update in case it exists.
     */
    where: FlightBookingWhereUniqueInput
    /**
     * In case the FlightBooking found by the `where` argument doesn't exist, create a new FlightBooking with this data.
     */
    create: XOR<FlightBookingCreateInput, FlightBookingUncheckedCreateInput>
    /**
     * In case the FlightBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightBookingUpdateInput, FlightBookingUncheckedUpdateInput>
  }

  /**
   * FlightBooking delete
   */
  export type FlightBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
    /**
     * Filter which FlightBooking to delete.
     */
    where: FlightBookingWhereUniqueInput
  }

  /**
   * FlightBooking deleteMany
   */
  export type FlightBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightBookings to delete
     */
    where?: FlightBookingWhereInput
  }

  /**
   * FlightBooking without action
   */
  export type FlightBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightBooking
     */
    select?: FlightBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightBookingInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ActivitySumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    duration: string | null
    difficulty: string | null
    price: number | null
    description: string | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    duration: string | null
    difficulty: string | null
    price: number | null
    description: string | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    name: number
    category: number
    duration: number
    difficulty: number
    price: number
    description: number
    location: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ActivitySumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    duration?: true
    difficulty?: true
    price?: true
    description?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    duration?: true
    difficulty?: true
    price?: true
    description?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    duration?: true
    difficulty?: true
    price?: true
    description?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: number
    name: string
    category: string
    duration: string | null
    difficulty: string | null
    price: number
    description: string | null
    location: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    duration?: boolean
    difficulty?: boolean
    price?: boolean
    description?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tourActivities?: boolean | Activity$tourActivitiesArgs<ExtArgs>
    bookingActivities?: boolean | Activity$bookingActivitiesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    duration?: boolean
    difficulty?: boolean
    price?: boolean
    description?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    duration?: boolean
    difficulty?: boolean
    price?: boolean
    description?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourActivities?: boolean | Activity$tourActivitiesArgs<ExtArgs>
    bookingActivities?: boolean | Activity$bookingActivitiesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      tourActivities: Prisma.$TourActivityJunctionPayload<ExtArgs>[]
      bookingActivities: Prisma.$BookingActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      duration: string | null
      difficulty: string | null
      price: number
      description: string | null
      location: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tourActivities<T extends Activity$tourActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$tourActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findMany"> | Null>
    bookingActivities<T extends Activity$bookingActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$bookingActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'Int'>
    readonly name: FieldRef<"Activity", 'String'>
    readonly category: FieldRef<"Activity", 'String'>
    readonly duration: FieldRef<"Activity", 'String'>
    readonly difficulty: FieldRef<"Activity", 'String'>
    readonly price: FieldRef<"Activity", 'Float'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly location: FieldRef<"Activity", 'String'>
    readonly isActive: FieldRef<"Activity", 'Boolean'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.tourActivities
   */
  export type Activity$tourActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    where?: TourActivityJunctionWhereInput
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    cursor?: TourActivityJunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourActivityJunctionScalarFieldEnum | TourActivityJunctionScalarFieldEnum[]
  }

  /**
   * Activity.bookingActivities
   */
  export type Activity$bookingActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingActivity
     */
    select?: BookingActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingActivityInclude<ExtArgs> | null
    where?: BookingActivityWhereInput
    orderBy?: BookingActivityOrderByWithRelationInput | BookingActivityOrderByWithRelationInput[]
    cursor?: BookingActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingActivityScalarFieldEnum | BookingActivityScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model TourActivityJunction
   */

  export type AggregateTourActivityJunction = {
    _count: TourActivityJunctionCountAggregateOutputType | null
    _avg: TourActivityJunctionAvgAggregateOutputType | null
    _sum: TourActivityJunctionSumAggregateOutputType | null
    _min: TourActivityJunctionMinAggregateOutputType | null
    _max: TourActivityJunctionMaxAggregateOutputType | null
  }

  export type TourActivityJunctionAvgAggregateOutputType = {
    tourId: number | null
    activityId: number | null
  }

  export type TourActivityJunctionSumAggregateOutputType = {
    tourId: number | null
    activityId: number | null
  }

  export type TourActivityJunctionMinAggregateOutputType = {
    tourId: number | null
    activityId: number | null
    included: boolean | null
    optional: boolean | null
  }

  export type TourActivityJunctionMaxAggregateOutputType = {
    tourId: number | null
    activityId: number | null
    included: boolean | null
    optional: boolean | null
  }

  export type TourActivityJunctionCountAggregateOutputType = {
    tourId: number
    activityId: number
    included: number
    optional: number
    _all: number
  }


  export type TourActivityJunctionAvgAggregateInputType = {
    tourId?: true
    activityId?: true
  }

  export type TourActivityJunctionSumAggregateInputType = {
    tourId?: true
    activityId?: true
  }

  export type TourActivityJunctionMinAggregateInputType = {
    tourId?: true
    activityId?: true
    included?: true
    optional?: true
  }

  export type TourActivityJunctionMaxAggregateInputType = {
    tourId?: true
    activityId?: true
    included?: true
    optional?: true
  }

  export type TourActivityJunctionCountAggregateInputType = {
    tourId?: true
    activityId?: true
    included?: true
    optional?: true
    _all?: true
  }

  export type TourActivityJunctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourActivityJunction to aggregate.
     */
    where?: TourActivityJunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourActivityJunctions to fetch.
     */
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourActivityJunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourActivityJunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourActivityJunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourActivityJunctions
    **/
    _count?: true | TourActivityJunctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourActivityJunctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourActivityJunctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourActivityJunctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourActivityJunctionMaxAggregateInputType
  }

  export type GetTourActivityJunctionAggregateType<T extends TourActivityJunctionAggregateArgs> = {
        [P in keyof T & keyof AggregateTourActivityJunction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourActivityJunction[P]>
      : GetScalarType<T[P], AggregateTourActivityJunction[P]>
  }




  export type TourActivityJunctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourActivityJunctionWhereInput
    orderBy?: TourActivityJunctionOrderByWithAggregationInput | TourActivityJunctionOrderByWithAggregationInput[]
    by: TourActivityJunctionScalarFieldEnum[] | TourActivityJunctionScalarFieldEnum
    having?: TourActivityJunctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourActivityJunctionCountAggregateInputType | true
    _avg?: TourActivityJunctionAvgAggregateInputType
    _sum?: TourActivityJunctionSumAggregateInputType
    _min?: TourActivityJunctionMinAggregateInputType
    _max?: TourActivityJunctionMaxAggregateInputType
  }

  export type TourActivityJunctionGroupByOutputType = {
    tourId: number
    activityId: number
    included: boolean
    optional: boolean
    _count: TourActivityJunctionCountAggregateOutputType | null
    _avg: TourActivityJunctionAvgAggregateOutputType | null
    _sum: TourActivityJunctionSumAggregateOutputType | null
    _min: TourActivityJunctionMinAggregateOutputType | null
    _max: TourActivityJunctionMaxAggregateOutputType | null
  }

  type GetTourActivityJunctionGroupByPayload<T extends TourActivityJunctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourActivityJunctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourActivityJunctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourActivityJunctionGroupByOutputType[P]>
            : GetScalarType<T[P], TourActivityJunctionGroupByOutputType[P]>
        }
      >
    >


  export type TourActivityJunctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tourId?: boolean
    activityId?: boolean
    included?: boolean
    optional?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourActivityJunction"]>

  export type TourActivityJunctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tourId?: boolean
    activityId?: boolean
    included?: boolean
    optional?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourActivityJunction"]>

  export type TourActivityJunctionSelectScalar = {
    tourId?: boolean
    activityId?: boolean
    included?: boolean
    optional?: boolean
  }

  export type TourActivityJunctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type TourActivityJunctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $TourActivityJunctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourActivityJunction"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tourId: number
      activityId: number
      included: boolean
      optional: boolean
    }, ExtArgs["result"]["tourActivityJunction"]>
    composites: {}
  }

  type TourActivityJunctionGetPayload<S extends boolean | null | undefined | TourActivityJunctionDefaultArgs> = $Result.GetResult<Prisma.$TourActivityJunctionPayload, S>

  type TourActivityJunctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourActivityJunctionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourActivityJunctionCountAggregateInputType | true
    }

  export interface TourActivityJunctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourActivityJunction'], meta: { name: 'TourActivityJunction' } }
    /**
     * Find zero or one TourActivityJunction that matches the filter.
     * @param {TourActivityJunctionFindUniqueArgs} args - Arguments to find a TourActivityJunction
     * @example
     * // Get one TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourActivityJunctionFindUniqueArgs>(args: SelectSubset<T, TourActivityJunctionFindUniqueArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourActivityJunction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourActivityJunctionFindUniqueOrThrowArgs} args - Arguments to find a TourActivityJunction
     * @example
     * // Get one TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourActivityJunctionFindUniqueOrThrowArgs>(args: SelectSubset<T, TourActivityJunctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourActivityJunction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionFindFirstArgs} args - Arguments to find a TourActivityJunction
     * @example
     * // Get one TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourActivityJunctionFindFirstArgs>(args?: SelectSubset<T, TourActivityJunctionFindFirstArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourActivityJunction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionFindFirstOrThrowArgs} args - Arguments to find a TourActivityJunction
     * @example
     * // Get one TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourActivityJunctionFindFirstOrThrowArgs>(args?: SelectSubset<T, TourActivityJunctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourActivityJunctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourActivityJunctions
     * const tourActivityJunctions = await prisma.tourActivityJunction.findMany()
     * 
     * // Get first 10 TourActivityJunctions
     * const tourActivityJunctions = await prisma.tourActivityJunction.findMany({ take: 10 })
     * 
     * // Only select the `tourId`
     * const tourActivityJunctionWithTourIdOnly = await prisma.tourActivityJunction.findMany({ select: { tourId: true } })
     * 
     */
    findMany<T extends TourActivityJunctionFindManyArgs>(args?: SelectSubset<T, TourActivityJunctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourActivityJunction.
     * @param {TourActivityJunctionCreateArgs} args - Arguments to create a TourActivityJunction.
     * @example
     * // Create one TourActivityJunction
     * const TourActivityJunction = await prisma.tourActivityJunction.create({
     *   data: {
     *     // ... data to create a TourActivityJunction
     *   }
     * })
     * 
     */
    create<T extends TourActivityJunctionCreateArgs>(args: SelectSubset<T, TourActivityJunctionCreateArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourActivityJunctions.
     * @param {TourActivityJunctionCreateManyArgs} args - Arguments to create many TourActivityJunctions.
     * @example
     * // Create many TourActivityJunctions
     * const tourActivityJunction = await prisma.tourActivityJunction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourActivityJunctionCreateManyArgs>(args?: SelectSubset<T, TourActivityJunctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourActivityJunctions and returns the data saved in the database.
     * @param {TourActivityJunctionCreateManyAndReturnArgs} args - Arguments to create many TourActivityJunctions.
     * @example
     * // Create many TourActivityJunctions
     * const tourActivityJunction = await prisma.tourActivityJunction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourActivityJunctions and only return the `tourId`
     * const tourActivityJunctionWithTourIdOnly = await prisma.tourActivityJunction.createManyAndReturn({ 
     *   select: { tourId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourActivityJunctionCreateManyAndReturnArgs>(args?: SelectSubset<T, TourActivityJunctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TourActivityJunction.
     * @param {TourActivityJunctionDeleteArgs} args - Arguments to delete one TourActivityJunction.
     * @example
     * // Delete one TourActivityJunction
     * const TourActivityJunction = await prisma.tourActivityJunction.delete({
     *   where: {
     *     // ... filter to delete one TourActivityJunction
     *   }
     * })
     * 
     */
    delete<T extends TourActivityJunctionDeleteArgs>(args: SelectSubset<T, TourActivityJunctionDeleteArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourActivityJunction.
     * @param {TourActivityJunctionUpdateArgs} args - Arguments to update one TourActivityJunction.
     * @example
     * // Update one TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourActivityJunctionUpdateArgs>(args: SelectSubset<T, TourActivityJunctionUpdateArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourActivityJunctions.
     * @param {TourActivityJunctionDeleteManyArgs} args - Arguments to filter TourActivityJunctions to delete.
     * @example
     * // Delete a few TourActivityJunctions
     * const { count } = await prisma.tourActivityJunction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourActivityJunctionDeleteManyArgs>(args?: SelectSubset<T, TourActivityJunctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourActivityJunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourActivityJunctions
     * const tourActivityJunction = await prisma.tourActivityJunction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourActivityJunctionUpdateManyArgs>(args: SelectSubset<T, TourActivityJunctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourActivityJunction.
     * @param {TourActivityJunctionUpsertArgs} args - Arguments to update or create a TourActivityJunction.
     * @example
     * // Update or create a TourActivityJunction
     * const tourActivityJunction = await prisma.tourActivityJunction.upsert({
     *   create: {
     *     // ... data to create a TourActivityJunction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourActivityJunction we want to update
     *   }
     * })
     */
    upsert<T extends TourActivityJunctionUpsertArgs>(args: SelectSubset<T, TourActivityJunctionUpsertArgs<ExtArgs>>): Prisma__TourActivityJunctionClient<$Result.GetResult<Prisma.$TourActivityJunctionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TourActivityJunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionCountArgs} args - Arguments to filter TourActivityJunctions to count.
     * @example
     * // Count the number of TourActivityJunctions
     * const count = await prisma.tourActivityJunction.count({
     *   where: {
     *     // ... the filter for the TourActivityJunctions we want to count
     *   }
     * })
    **/
    count<T extends TourActivityJunctionCountArgs>(
      args?: Subset<T, TourActivityJunctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourActivityJunctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourActivityJunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourActivityJunctionAggregateArgs>(args: Subset<T, TourActivityJunctionAggregateArgs>): Prisma.PrismaPromise<GetTourActivityJunctionAggregateType<T>>

    /**
     * Group by TourActivityJunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourActivityJunctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourActivityJunctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourActivityJunctionGroupByArgs['orderBy'] }
        : { orderBy?: TourActivityJunctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourActivityJunctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourActivityJunctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourActivityJunction model
   */
  readonly fields: TourActivityJunctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourActivityJunction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourActivityJunctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourActivityJunction model
   */ 
  interface TourActivityJunctionFieldRefs {
    readonly tourId: FieldRef<"TourActivityJunction", 'Int'>
    readonly activityId: FieldRef<"TourActivityJunction", 'Int'>
    readonly included: FieldRef<"TourActivityJunction", 'Boolean'>
    readonly optional: FieldRef<"TourActivityJunction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TourActivityJunction findUnique
   */
  export type TourActivityJunctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter, which TourActivityJunction to fetch.
     */
    where: TourActivityJunctionWhereUniqueInput
  }

  /**
   * TourActivityJunction findUniqueOrThrow
   */
  export type TourActivityJunctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter, which TourActivityJunction to fetch.
     */
    where: TourActivityJunctionWhereUniqueInput
  }

  /**
   * TourActivityJunction findFirst
   */
  export type TourActivityJunctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter, which TourActivityJunction to fetch.
     */
    where?: TourActivityJunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourActivityJunctions to fetch.
     */
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourActivityJunctions.
     */
    cursor?: TourActivityJunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourActivityJunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourActivityJunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourActivityJunctions.
     */
    distinct?: TourActivityJunctionScalarFieldEnum | TourActivityJunctionScalarFieldEnum[]
  }

  /**
   * TourActivityJunction findFirstOrThrow
   */
  export type TourActivityJunctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter, which TourActivityJunction to fetch.
     */
    where?: TourActivityJunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourActivityJunctions to fetch.
     */
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourActivityJunctions.
     */
    cursor?: TourActivityJunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourActivityJunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourActivityJunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourActivityJunctions.
     */
    distinct?: TourActivityJunctionScalarFieldEnum | TourActivityJunctionScalarFieldEnum[]
  }

  /**
   * TourActivityJunction findMany
   */
  export type TourActivityJunctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter, which TourActivityJunctions to fetch.
     */
    where?: TourActivityJunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourActivityJunctions to fetch.
     */
    orderBy?: TourActivityJunctionOrderByWithRelationInput | TourActivityJunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourActivityJunctions.
     */
    cursor?: TourActivityJunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourActivityJunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourActivityJunctions.
     */
    skip?: number
    distinct?: TourActivityJunctionScalarFieldEnum | TourActivityJunctionScalarFieldEnum[]
  }

  /**
   * TourActivityJunction create
   */
  export type TourActivityJunctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * The data needed to create a TourActivityJunction.
     */
    data: XOR<TourActivityJunctionCreateInput, TourActivityJunctionUncheckedCreateInput>
  }

  /**
   * TourActivityJunction createMany
   */
  export type TourActivityJunctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourActivityJunctions.
     */
    data: TourActivityJunctionCreateManyInput | TourActivityJunctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourActivityJunction createManyAndReturn
   */
  export type TourActivityJunctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TourActivityJunctions.
     */
    data: TourActivityJunctionCreateManyInput | TourActivityJunctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourActivityJunction update
   */
  export type TourActivityJunctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * The data needed to update a TourActivityJunction.
     */
    data: XOR<TourActivityJunctionUpdateInput, TourActivityJunctionUncheckedUpdateInput>
    /**
     * Choose, which TourActivityJunction to update.
     */
    where: TourActivityJunctionWhereUniqueInput
  }

  /**
   * TourActivityJunction updateMany
   */
  export type TourActivityJunctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourActivityJunctions.
     */
    data: XOR<TourActivityJunctionUpdateManyMutationInput, TourActivityJunctionUncheckedUpdateManyInput>
    /**
     * Filter which TourActivityJunctions to update
     */
    where?: TourActivityJunctionWhereInput
  }

  /**
   * TourActivityJunction upsert
   */
  export type TourActivityJunctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * The filter to search for the TourActivityJunction to update in case it exists.
     */
    where: TourActivityJunctionWhereUniqueInput
    /**
     * In case the TourActivityJunction found by the `where` argument doesn't exist, create a new TourActivityJunction with this data.
     */
    create: XOR<TourActivityJunctionCreateInput, TourActivityJunctionUncheckedCreateInput>
    /**
     * In case the TourActivityJunction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourActivityJunctionUpdateInput, TourActivityJunctionUncheckedUpdateInput>
  }

  /**
   * TourActivityJunction delete
   */
  export type TourActivityJunctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
    /**
     * Filter which TourActivityJunction to delete.
     */
    where: TourActivityJunctionWhereUniqueInput
  }

  /**
   * TourActivityJunction deleteMany
   */
  export type TourActivityJunctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourActivityJunctions to delete
     */
    where?: TourActivityJunctionWhereInput
  }

  /**
   * TourActivityJunction without action
   */
  export type TourActivityJunctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourActivityJunction
     */
    select?: TourActivityJunctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourActivityJunctionInclude<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _avg: InterestAvgAggregateOutputType | null
    _sum: InterestSumAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestAvgAggregateOutputType = {
    id: number | null
  }

  export type InterestSumAggregateOutputType = {
    id: number | null
  }

  export type InterestMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    experiences: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterestAvgAggregateInputType = {
    id?: true
  }

  export type InterestSumAggregateInputType = {
    id?: true
  }

  export type InterestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    experiences?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _avg?: InterestAvgAggregateInputType
    _sum?: InterestSumAggregateInputType
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string
    experiences: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InterestCountAggregateOutputType | null
    _avg: InterestAvgAggregateOutputType | null
    _sum: InterestSumAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    experiences?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    experiences?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    experiences?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string
      experiences: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interests and returns the data saved in the database.
     * @param {InterestCreateManyAndReturnArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */ 
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'Int'>
    readonly name: FieldRef<"Interest", 'String'>
    readonly description: FieldRef<"Interest", 'String'>
    readonly category: FieldRef<"Interest", 'String'>
    readonly experiences: FieldRef<"Interest", 'String[]'>
    readonly isActive: FieldRef<"Interest", 'Boolean'>
    readonly createdAt: FieldRef<"Interest", 'DateTime'>
    readonly updatedAt: FieldRef<"Interest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest createManyAndReturn
   */
  export type InterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
  }


  /**
   * Model Flight
   */

  export type AggregateFlight = {
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  export type FlightAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type FlightSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type FlightMinAggregateOutputType = {
    id: number | null
    airline: string | null
    route: string | null
    duration: string | null
    frequency: string | null
    price: number | null
    aircraft: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightMaxAggregateOutputType = {
    id: number | null
    airline: string | null
    route: string | null
    duration: string | null
    frequency: string | null
    price: number | null
    aircraft: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightCountAggregateOutputType = {
    id: number
    airline: number
    route: number
    duration: number
    frequency: number
    price: number
    aircraft: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlightAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type FlightSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type FlightMinAggregateInputType = {
    id?: true
    airline?: true
    route?: true
    duration?: true
    frequency?: true
    price?: true
    aircraft?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightMaxAggregateInputType = {
    id?: true
    airline?: true
    route?: true
    duration?: true
    frequency?: true
    price?: true
    aircraft?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightCountAggregateInputType = {
    id?: true
    airline?: true
    route?: true
    duration?: true
    frequency?: true
    price?: true
    aircraft?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flight to aggregate.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flights
    **/
    _count?: true | FlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightMaxAggregateInputType
  }

  export type GetFlightAggregateType<T extends FlightAggregateArgs> = {
        [P in keyof T & keyof AggregateFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlight[P]>
      : GetScalarType<T[P], AggregateFlight[P]>
  }




  export type FlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightWhereInput
    orderBy?: FlightOrderByWithAggregationInput | FlightOrderByWithAggregationInput[]
    by: FlightScalarFieldEnum[] | FlightScalarFieldEnum
    having?: FlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightCountAggregateInputType | true
    _avg?: FlightAvgAggregateInputType
    _sum?: FlightSumAggregateInputType
    _min?: FlightMinAggregateInputType
    _max?: FlightMaxAggregateInputType
  }

  export type FlightGroupByOutputType = {
    id: number
    airline: string
    route: string
    duration: string
    frequency: string
    price: number
    aircraft: string | null
    features: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FlightCountAggregateOutputType | null
    _avg: FlightAvgAggregateOutputType | null
    _sum: FlightSumAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  type GetFlightGroupByPayload<T extends FlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightGroupByOutputType[P]>
            : GetScalarType<T[P], FlightGroupByOutputType[P]>
        }
      >
    >


  export type FlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    airline?: boolean
    route?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    aircraft?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["flight"]>

  export type FlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    airline?: boolean
    route?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    aircraft?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["flight"]>

  export type FlightSelectScalar = {
    id?: boolean
    airline?: boolean
    route?: boolean
    duration?: boolean
    frequency?: boolean
    price?: boolean
    aircraft?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flight"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      airline: string
      route: string
      duration: string
      frequency: string
      price: number
      aircraft: string | null
      features: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flight"]>
    composites: {}
  }

  type FlightGetPayload<S extends boolean | null | undefined | FlightDefaultArgs> = $Result.GetResult<Prisma.$FlightPayload, S>

  type FlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlightCountAggregateInputType | true
    }

  export interface FlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flight'], meta: { name: 'Flight' } }
    /**
     * Find zero or one Flight that matches the filter.
     * @param {FlightFindUniqueArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightFindUniqueArgs>(args: SelectSubset<T, FlightFindUniqueArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Flight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlightFindUniqueOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Flight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindFirstArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightFindFirstArgs>(args?: SelectSubset<T, FlightFindFirstArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Flight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindFirstOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Flights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flights
     * const flights = await prisma.flight.findMany()
     * 
     * // Get first 10 Flights
     * const flights = await prisma.flight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightWithIdOnly = await prisma.flight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightFindManyArgs>(args?: SelectSubset<T, FlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Flight.
     * @param {FlightCreateArgs} args - Arguments to create a Flight.
     * @example
     * // Create one Flight
     * const Flight = await prisma.flight.create({
     *   data: {
     *     // ... data to create a Flight
     *   }
     * })
     * 
     */
    create<T extends FlightCreateArgs>(args: SelectSubset<T, FlightCreateArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Flights.
     * @param {FlightCreateManyArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightCreateManyArgs>(args?: SelectSubset<T, FlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flights and returns the data saved in the database.
     * @param {FlightCreateManyAndReturnArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flights and only return the `id`
     * const flightWithIdOnly = await prisma.flight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Flight.
     * @param {FlightDeleteArgs} args - Arguments to delete one Flight.
     * @example
     * // Delete one Flight
     * const Flight = await prisma.flight.delete({
     *   where: {
     *     // ... filter to delete one Flight
     *   }
     * })
     * 
     */
    delete<T extends FlightDeleteArgs>(args: SelectSubset<T, FlightDeleteArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Flight.
     * @param {FlightUpdateArgs} args - Arguments to update one Flight.
     * @example
     * // Update one Flight
     * const flight = await prisma.flight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightUpdateArgs>(args: SelectSubset<T, FlightUpdateArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Flights.
     * @param {FlightDeleteManyArgs} args - Arguments to filter Flights to delete.
     * @example
     * // Delete a few Flights
     * const { count } = await prisma.flight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightDeleteManyArgs>(args?: SelectSubset<T, FlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flights
     * const flight = await prisma.flight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightUpdateManyArgs>(args: SelectSubset<T, FlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flight.
     * @param {FlightUpsertArgs} args - Arguments to update or create a Flight.
     * @example
     * // Update or create a Flight
     * const flight = await prisma.flight.upsert({
     *   create: {
     *     // ... data to create a Flight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flight we want to update
     *   }
     * })
     */
    upsert<T extends FlightUpsertArgs>(args: SelectSubset<T, FlightUpsertArgs<ExtArgs>>): Prisma__FlightClient<$Result.GetResult<Prisma.$FlightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightCountArgs} args - Arguments to filter Flights to count.
     * @example
     * // Count the number of Flights
     * const count = await prisma.flight.count({
     *   where: {
     *     // ... the filter for the Flights we want to count
     *   }
     * })
    **/
    count<T extends FlightCountArgs>(
      args?: Subset<T, FlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightAggregateArgs>(args: Subset<T, FlightAggregateArgs>): Prisma.PrismaPromise<GetFlightAggregateType<T>>

    /**
     * Group by Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightGroupByArgs['orderBy'] }
        : { orderBy?: FlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flight model
   */
  readonly fields: FlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flight model
   */ 
  interface FlightFieldRefs {
    readonly id: FieldRef<"Flight", 'Int'>
    readonly airline: FieldRef<"Flight", 'String'>
    readonly route: FieldRef<"Flight", 'String'>
    readonly duration: FieldRef<"Flight", 'String'>
    readonly frequency: FieldRef<"Flight", 'String'>
    readonly price: FieldRef<"Flight", 'Float'>
    readonly aircraft: FieldRef<"Flight", 'String'>
    readonly features: FieldRef<"Flight", 'String[]'>
    readonly isActive: FieldRef<"Flight", 'Boolean'>
    readonly createdAt: FieldRef<"Flight", 'DateTime'>
    readonly updatedAt: FieldRef<"Flight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flight findUnique
   */
  export type FlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight findUniqueOrThrow
   */
  export type FlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight findFirst
   */
  export type FlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight findFirstOrThrow
   */
  export type FlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter, which Flight to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight findMany
   */
  export type FlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter, which Flights to fetch.
     */
    where?: FlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flights to fetch.
     */
    orderBy?: FlightOrderByWithRelationInput | FlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flights.
     */
    cursor?: FlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flights.
     */
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * Flight create
   */
  export type FlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * The data needed to create a Flight.
     */
    data: XOR<FlightCreateInput, FlightUncheckedCreateInput>
  }

  /**
   * Flight createMany
   */
  export type FlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flights.
     */
    data: FlightCreateManyInput | FlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flight createManyAndReturn
   */
  export type FlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Flights.
     */
    data: FlightCreateManyInput | FlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flight update
   */
  export type FlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * The data needed to update a Flight.
     */
    data: XOR<FlightUpdateInput, FlightUncheckedUpdateInput>
    /**
     * Choose, which Flight to update.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight updateMany
   */
  export type FlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flights.
     */
    data: XOR<FlightUpdateManyMutationInput, FlightUncheckedUpdateManyInput>
    /**
     * Filter which Flights to update
     */
    where?: FlightWhereInput
  }

  /**
   * Flight upsert
   */
  export type FlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * The filter to search for the Flight to update in case it exists.
     */
    where: FlightWhereUniqueInput
    /**
     * In case the Flight found by the `where` argument doesn't exist, create a new Flight with this data.
     */
    create: XOR<FlightCreateInput, FlightUncheckedCreateInput>
    /**
     * In case the Flight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightUpdateInput, FlightUncheckedUpdateInput>
  }

  /**
   * Flight delete
   */
  export type FlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
    /**
     * Filter which Flight to delete.
     */
    where: FlightWhereUniqueInput
  }

  /**
   * Flight deleteMany
   */
  export type FlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flights to delete
     */
    where?: FlightWhereInput
  }

  /**
   * Flight without action
   */
  export type FlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flight
     */
    select?: FlightSelect<ExtArgs> | null
  }


  /**
   * Model TourFestival
   */

  export type AggregateTourFestival = {
    _count: TourFestivalCountAggregateOutputType | null
    _avg: TourFestivalAvgAggregateOutputType | null
    _sum: TourFestivalSumAggregateOutputType | null
    _min: TourFestivalMinAggregateOutputType | null
    _max: TourFestivalMaxAggregateOutputType | null
  }

  export type TourFestivalAvgAggregateOutputType = {
    id: number | null
    tourId: number | null
    festivalId: number | null
  }

  export type TourFestivalSumAggregateOutputType = {
    id: number | null
    tourId: number | null
    festivalId: number | null
  }

  export type TourFestivalMinAggregateOutputType = {
    id: number | null
    tourId: number | null
    festivalId: number | null
  }

  export type TourFestivalMaxAggregateOutputType = {
    id: number | null
    tourId: number | null
    festivalId: number | null
  }

  export type TourFestivalCountAggregateOutputType = {
    id: number
    tourId: number
    festivalId: number
    _all: number
  }


  export type TourFestivalAvgAggregateInputType = {
    id?: true
    tourId?: true
    festivalId?: true
  }

  export type TourFestivalSumAggregateInputType = {
    id?: true
    tourId?: true
    festivalId?: true
  }

  export type TourFestivalMinAggregateInputType = {
    id?: true
    tourId?: true
    festivalId?: true
  }

  export type TourFestivalMaxAggregateInputType = {
    id?: true
    tourId?: true
    festivalId?: true
  }

  export type TourFestivalCountAggregateInputType = {
    id?: true
    tourId?: true
    festivalId?: true
    _all?: true
  }

  export type TourFestivalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourFestival to aggregate.
     */
    where?: TourFestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourFestivals to fetch.
     */
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourFestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourFestivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourFestivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourFestivals
    **/
    _count?: true | TourFestivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourFestivalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourFestivalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourFestivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourFestivalMaxAggregateInputType
  }

  export type GetTourFestivalAggregateType<T extends TourFestivalAggregateArgs> = {
        [P in keyof T & keyof AggregateTourFestival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourFestival[P]>
      : GetScalarType<T[P], AggregateTourFestival[P]>
  }




  export type TourFestivalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourFestivalWhereInput
    orderBy?: TourFestivalOrderByWithAggregationInput | TourFestivalOrderByWithAggregationInput[]
    by: TourFestivalScalarFieldEnum[] | TourFestivalScalarFieldEnum
    having?: TourFestivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourFestivalCountAggregateInputType | true
    _avg?: TourFestivalAvgAggregateInputType
    _sum?: TourFestivalSumAggregateInputType
    _min?: TourFestivalMinAggregateInputType
    _max?: TourFestivalMaxAggregateInputType
  }

  export type TourFestivalGroupByOutputType = {
    id: number
    tourId: number
    festivalId: number
    _count: TourFestivalCountAggregateOutputType | null
    _avg: TourFestivalAvgAggregateOutputType | null
    _sum: TourFestivalSumAggregateOutputType | null
    _min: TourFestivalMinAggregateOutputType | null
    _max: TourFestivalMaxAggregateOutputType | null
  }

  type GetTourFestivalGroupByPayload<T extends TourFestivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourFestivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourFestivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourFestivalGroupByOutputType[P]>
            : GetScalarType<T[P], TourFestivalGroupByOutputType[P]>
        }
      >
    >


  export type TourFestivalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    festivalId?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourFestival"]>

  export type TourFestivalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tourId?: boolean
    festivalId?: boolean
    tour?: boolean | TourDefaultArgs<ExtArgs>
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourFestival"]>

  export type TourFestivalSelectScalar = {
    id?: boolean
    tourId?: boolean
    festivalId?: boolean
  }

  export type TourFestivalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }
  export type TourFestivalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | TourDefaultArgs<ExtArgs>
    festival?: boolean | FestivalDefaultArgs<ExtArgs>
  }

  export type $TourFestivalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourFestival"
    objects: {
      tour: Prisma.$TourPayload<ExtArgs>
      festival: Prisma.$FestivalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tourId: number
      festivalId: number
    }, ExtArgs["result"]["tourFestival"]>
    composites: {}
  }

  type TourFestivalGetPayload<S extends boolean | null | undefined | TourFestivalDefaultArgs> = $Result.GetResult<Prisma.$TourFestivalPayload, S>

  type TourFestivalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourFestivalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourFestivalCountAggregateInputType | true
    }

  export interface TourFestivalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourFestival'], meta: { name: 'TourFestival' } }
    /**
     * Find zero or one TourFestival that matches the filter.
     * @param {TourFestivalFindUniqueArgs} args - Arguments to find a TourFestival
     * @example
     * // Get one TourFestival
     * const tourFestival = await prisma.tourFestival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFestivalFindUniqueArgs>(args: SelectSubset<T, TourFestivalFindUniqueArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TourFestival that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourFestivalFindUniqueOrThrowArgs} args - Arguments to find a TourFestival
     * @example
     * // Get one TourFestival
     * const tourFestival = await prisma.tourFestival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFestivalFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFestivalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TourFestival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalFindFirstArgs} args - Arguments to find a TourFestival
     * @example
     * // Get one TourFestival
     * const tourFestival = await prisma.tourFestival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFestivalFindFirstArgs>(args?: SelectSubset<T, TourFestivalFindFirstArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TourFestival that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalFindFirstOrThrowArgs} args - Arguments to find a TourFestival
     * @example
     * // Get one TourFestival
     * const tourFestival = await prisma.tourFestival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFestivalFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFestivalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TourFestivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourFestivals
     * const tourFestivals = await prisma.tourFestival.findMany()
     * 
     * // Get first 10 TourFestivals
     * const tourFestivals = await prisma.tourFestival.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourFestivalWithIdOnly = await prisma.tourFestival.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFestivalFindManyArgs>(args?: SelectSubset<T, TourFestivalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TourFestival.
     * @param {TourFestivalCreateArgs} args - Arguments to create a TourFestival.
     * @example
     * // Create one TourFestival
     * const TourFestival = await prisma.tourFestival.create({
     *   data: {
     *     // ... data to create a TourFestival
     *   }
     * })
     * 
     */
    create<T extends TourFestivalCreateArgs>(args: SelectSubset<T, TourFestivalCreateArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TourFestivals.
     * @param {TourFestivalCreateManyArgs} args - Arguments to create many TourFestivals.
     * @example
     * // Create many TourFestivals
     * const tourFestival = await prisma.tourFestival.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourFestivalCreateManyArgs>(args?: SelectSubset<T, TourFestivalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourFestivals and returns the data saved in the database.
     * @param {TourFestivalCreateManyAndReturnArgs} args - Arguments to create many TourFestivals.
     * @example
     * // Create many TourFestivals
     * const tourFestival = await prisma.tourFestival.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourFestivals and only return the `id`
     * const tourFestivalWithIdOnly = await prisma.tourFestival.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourFestivalCreateManyAndReturnArgs>(args?: SelectSubset<T, TourFestivalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TourFestival.
     * @param {TourFestivalDeleteArgs} args - Arguments to delete one TourFestival.
     * @example
     * // Delete one TourFestival
     * const TourFestival = await prisma.tourFestival.delete({
     *   where: {
     *     // ... filter to delete one TourFestival
     *   }
     * })
     * 
     */
    delete<T extends TourFestivalDeleteArgs>(args: SelectSubset<T, TourFestivalDeleteArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TourFestival.
     * @param {TourFestivalUpdateArgs} args - Arguments to update one TourFestival.
     * @example
     * // Update one TourFestival
     * const tourFestival = await prisma.tourFestival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourFestivalUpdateArgs>(args: SelectSubset<T, TourFestivalUpdateArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TourFestivals.
     * @param {TourFestivalDeleteManyArgs} args - Arguments to filter TourFestivals to delete.
     * @example
     * // Delete a few TourFestivals
     * const { count } = await prisma.tourFestival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourFestivalDeleteManyArgs>(args?: SelectSubset<T, TourFestivalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourFestivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourFestivals
     * const tourFestival = await prisma.tourFestival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourFestivalUpdateManyArgs>(args: SelectSubset<T, TourFestivalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TourFestival.
     * @param {TourFestivalUpsertArgs} args - Arguments to update or create a TourFestival.
     * @example
     * // Update or create a TourFestival
     * const tourFestival = await prisma.tourFestival.upsert({
     *   create: {
     *     // ... data to create a TourFestival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourFestival we want to update
     *   }
     * })
     */
    upsert<T extends TourFestivalUpsertArgs>(args: SelectSubset<T, TourFestivalUpsertArgs<ExtArgs>>): Prisma__TourFestivalClient<$Result.GetResult<Prisma.$TourFestivalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TourFestivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalCountArgs} args - Arguments to filter TourFestivals to count.
     * @example
     * // Count the number of TourFestivals
     * const count = await prisma.tourFestival.count({
     *   where: {
     *     // ... the filter for the TourFestivals we want to count
     *   }
     * })
    **/
    count<T extends TourFestivalCountArgs>(
      args?: Subset<T, TourFestivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourFestivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourFestival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourFestivalAggregateArgs>(args: Subset<T, TourFestivalAggregateArgs>): Prisma.PrismaPromise<GetTourFestivalAggregateType<T>>

    /**
     * Group by TourFestival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFestivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourFestivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourFestivalGroupByArgs['orderBy'] }
        : { orderBy?: TourFestivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourFestivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourFestivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourFestival model
   */
  readonly fields: TourFestivalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourFestival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourFestivalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends TourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TourDefaultArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    festival<T extends FestivalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FestivalDefaultArgs<ExtArgs>>): Prisma__FestivalClient<$Result.GetResult<Prisma.$FestivalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourFestival model
   */ 
  interface TourFestivalFieldRefs {
    readonly id: FieldRef<"TourFestival", 'Int'>
    readonly tourId: FieldRef<"TourFestival", 'Int'>
    readonly festivalId: FieldRef<"TourFestival", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TourFestival findUnique
   */
  export type TourFestivalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter, which TourFestival to fetch.
     */
    where: TourFestivalWhereUniqueInput
  }

  /**
   * TourFestival findUniqueOrThrow
   */
  export type TourFestivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter, which TourFestival to fetch.
     */
    where: TourFestivalWhereUniqueInput
  }

  /**
   * TourFestival findFirst
   */
  export type TourFestivalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter, which TourFestival to fetch.
     */
    where?: TourFestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourFestivals to fetch.
     */
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourFestivals.
     */
    cursor?: TourFestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourFestivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourFestivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourFestivals.
     */
    distinct?: TourFestivalScalarFieldEnum | TourFestivalScalarFieldEnum[]
  }

  /**
   * TourFestival findFirstOrThrow
   */
  export type TourFestivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter, which TourFestival to fetch.
     */
    where?: TourFestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourFestivals to fetch.
     */
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourFestivals.
     */
    cursor?: TourFestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourFestivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourFestivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourFestivals.
     */
    distinct?: TourFestivalScalarFieldEnum | TourFestivalScalarFieldEnum[]
  }

  /**
   * TourFestival findMany
   */
  export type TourFestivalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter, which TourFestivals to fetch.
     */
    where?: TourFestivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourFestivals to fetch.
     */
    orderBy?: TourFestivalOrderByWithRelationInput | TourFestivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourFestivals.
     */
    cursor?: TourFestivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourFestivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourFestivals.
     */
    skip?: number
    distinct?: TourFestivalScalarFieldEnum | TourFestivalScalarFieldEnum[]
  }

  /**
   * TourFestival create
   */
  export type TourFestivalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * The data needed to create a TourFestival.
     */
    data: XOR<TourFestivalCreateInput, TourFestivalUncheckedCreateInput>
  }

  /**
   * TourFestival createMany
   */
  export type TourFestivalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourFestivals.
     */
    data: TourFestivalCreateManyInput | TourFestivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourFestival createManyAndReturn
   */
  export type TourFestivalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TourFestivals.
     */
    data: TourFestivalCreateManyInput | TourFestivalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourFestival update
   */
  export type TourFestivalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * The data needed to update a TourFestival.
     */
    data: XOR<TourFestivalUpdateInput, TourFestivalUncheckedUpdateInput>
    /**
     * Choose, which TourFestival to update.
     */
    where: TourFestivalWhereUniqueInput
  }

  /**
   * TourFestival updateMany
   */
  export type TourFestivalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourFestivals.
     */
    data: XOR<TourFestivalUpdateManyMutationInput, TourFestivalUncheckedUpdateManyInput>
    /**
     * Filter which TourFestivals to update
     */
    where?: TourFestivalWhereInput
  }

  /**
   * TourFestival upsert
   */
  export type TourFestivalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * The filter to search for the TourFestival to update in case it exists.
     */
    where: TourFestivalWhereUniqueInput
    /**
     * In case the TourFestival found by the `where` argument doesn't exist, create a new TourFestival with this data.
     */
    create: XOR<TourFestivalCreateInput, TourFestivalUncheckedCreateInput>
    /**
     * In case the TourFestival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourFestivalUpdateInput, TourFestivalUncheckedUpdateInput>
  }

  /**
   * TourFestival delete
   */
  export type TourFestivalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
    /**
     * Filter which TourFestival to delete.
     */
    where: TourFestivalWhereUniqueInput
  }

  /**
   * TourFestival deleteMany
   */
  export type TourFestivalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourFestivals to delete
     */
    where?: TourFestivalWhereInput
  }

  /**
   * TourFestival without action
   */
  export type TourFestivalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourFestival
     */
    select?: TourFestivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourFestivalInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _avg: ChatSessionAvgAggregateOutputType | null
    _sum: ChatSessionSumAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ChatSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: number | null
    sessionId: string | null
    userId: number | null
    userEmail: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: number | null
    sessionId: string | null
    userId: number | null
    userEmail: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    userEmail: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ChatSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ChatSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userEmail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userEmail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    userEmail?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _avg?: ChatSessionAvgAggregateInputType
    _sum?: ChatSessionSumAggregateInputType
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: number
    sessionId: string
    userId: number | null
    userEmail: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChatSessionCountAggregateOutputType | null
    _avg: ChatSessionAvgAggregateOutputType | null
    _sum: ChatSessionSumAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userEmail?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userEmail?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    userEmail?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: string
      userId: number | null
      userEmail: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends ChatSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */ 
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'Int'>
    readonly sessionId: FieldRef<"ChatSession", 'String'>
    readonly userId: FieldRef<"ChatSession", 'Int'>
    readonly userEmail: FieldRef<"ChatSession", 'String'>
    readonly isActive: FieldRef<"ChatSession", 'Boolean'>
    readonly createdAt: FieldRef<"ChatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
  }

  /**
   * ChatSession.messages
   */
  export type ChatSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    sessionId: string | null
    sender: string | null
    message: string | null
    messageType: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    sessionId: string | null
    sender: string | null
    message: string | null
    messageType: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    sender: number
    message: number
    messageType: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    message?: true
    messageType?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    message?: true
    messageType?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    sender?: true
    message?: true
    messageType?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    sessionId: string
    sender: string
    message: string
    messageType: string
    metadata: JsonValue | null
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sender?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: string
      sender: string
      message: string
      messageType: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly sessionId: FieldRef<"ChatMessage", 'String'>
    readonly sender: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly messageType: FieldRef<"ChatMessage", 'String'>
    readonly metadata: FieldRef<"ChatMessage", 'Json'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    userEmail: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    priority: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    userEmail: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    priority: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    type: number
    title: number
    message: number
    isRead: number
    priority: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    priority?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    priority?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    priority?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number | null
    userEmail: string | null
    type: string
    title: string
    message: string
    isRead: boolean
    priority: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    priority?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    priority?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    priority?: boolean
    createdAt?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      userEmail: string | null
      type: string
      title: string
      message: string
      isRead: boolean
      priority: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly userEmail: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    hotelBookingId: number | null
    flightBookingId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    hotelBookingId: number | null
    flightBookingId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    hotelBookingId: number | null
    flightBookingId: number | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentGateway: string | null
    transactionId: string | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    hotelBookingId: number | null
    flightBookingId: number | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentGateway: string | null
    transactionId: string | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    hotelBookingId: number
    flightBookingId: number
    amount: number
    currency: number
    paymentMethod: number
    paymentGateway: number
    transactionId: number
    status: number
    paidAt: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    hotelBookingId?: true
    flightBookingId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
    hotelBookingId?: true
    flightBookingId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    hotelBookingId?: true
    flightBookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGateway?: true
    transactionId?: true
    status?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    hotelBookingId?: true
    flightBookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGateway?: true
    transactionId?: true
    status?: true
    paidAt?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    hotelBookingId?: true
    flightBookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGateway?: true
    transactionId?: true
    status?: true
    paidAt?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bookingId: number | null
    hotelBookingId: number | null
    flightBookingId: number | null
    amount: number
    currency: string
    paymentMethod: string
    paymentGateway: string
    transactionId: string | null
    status: string
    paidAt: Date | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    hotelBookingId?: boolean
    flightBookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGateway?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    hotelBookingId?: boolean
    flightBookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGateway?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    hotelBookingId?: boolean
    flightBookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGateway?: boolean
    transactionId?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
  }


  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number | null
      hotelBookingId: number | null
      flightBookingId: number | null
      amount: number
      currency: string
      paymentMethod: string
      paymentGateway: string
      transactionId: string | null
      status: string
      paidAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly hotelBookingId: FieldRef<"Payment", 'Int'>
    readonly flightBookingId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly paymentGateway: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    duration: 'duration',
    price: 'price',
    maxPrice: 'maxPrice',
    categoryName: 'categoryName',
    difficulty: 'difficulty',
    groupSize: 'groupSize',
    imageUrl: 'imageUrl',
    highlights: 'highlights',
    includes: 'includes',
    excludes: 'excludes',
    itinerary: 'itinerary',
    bestTime: 'bestTime',
    physicalRating: 'physicalRating',
    culturalLevel: 'culturalLevel',
    luxuryLevel: 'luxuryLevel',
    spiritualLevel: 'spiritualLevel',
    rating: 'rating',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tourOperatorId: 'tourOperatorId'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    travelDate: 'travelDate',
    groupSize: 'groupSize',
    specialRequests: 'specialRequests',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    tourInterest: 'tourInterest',
    preferredDates: 'preferredDates',
    groupSize: 'groupSize',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country: 'country',
    imageUrl: 'imageUrl',
    text: 'text',
    rating: 'rating',
    tripName: 'tripName',
    duration: 'duration',
    isActive: 'isActive'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    imageUrl: 'imageUrl',
    category: 'category',
    author: 'author',
    authorImage: 'authorImage',
    readTime: 'readTime',
    publishedAt: 'publishedAt',
    isPublished: 'isPublished'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const GuideScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    licenseImageUrl: 'licenseImageUrl',
    registrationType: 'registrationType',
    specializations: 'specializations',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type GuideScalarFieldEnum = (typeof GuideScalarFieldEnum)[keyof typeof GuideScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    guideId: 'guideId',
    driverId: 'driverId',
    maxParticipants: 'maxParticipants',
    currentParticipants: 'currentParticipants',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const ItineraryDayScalarFieldEnum: {
    id: 'id',
    itineraryId: 'itineraryId',
    dayNumber: 'dayNumber',
    title: 'title',
    description: 'description',
    activities: 'activities',
    accommodation: 'accommodation',
    meals: 'meals',
    transportation: 'transportation',
    notes: 'notes'
  };

  export type ItineraryDayScalarFieldEnum = (typeof ItineraryDayScalarFieldEnum)[keyof typeof ItineraryDayScalarFieldEnum]


  export const CustomTourRequestScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    duration: 'duration',
    groupSize: 'groupSize',
    budget: 'budget',
    preferredDates: 'preferredDates',
    specialRequirements: 'specialRequirements',
    destinations: 'destinations',
    accommodationType: 'accommodationType',
    transportPreference: 'transportPreference',
    status: 'status',
    adminNotes: 'adminNotes',
    estimatedPrice: 'estimatedPrice',
    assignedItineraryId: 'assignedItineraryId',
    createdAt: 'createdAt'
  };

  export type CustomTourRequestScalarFieldEnum = (typeof CustomTourRequestScalarFieldEnum)[keyof typeof CustomTourRequestScalarFieldEnum]


  export const TourOperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    website: 'website',
    description: 'description',
    bestFeature: 'bestFeature',
    specialties: 'specialties',
    rating: 'rating',
    reviewCount: 'reviewCount',
    logoUrl: 'logoUrl',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    isActive: 'isActive',
    establishedYear: 'establishedYear',
    certifications: 'certifications',
    awards: 'awards',
    createdAt: 'createdAt'
  };

  export type TourOperatorScalarFieldEnum = (typeof TourOperatorScalarFieldEnum)[keyof typeof TourOperatorScalarFieldEnum]


  export const FestivalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    dates: 'dates',
    duration: 'duration',
    significance: 'significance',
    activities: 'activities',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FestivalScalarFieldEnum = (typeof FestivalScalarFieldEnum)[keyof typeof FestivalScalarFieldEnum]


  export const FestivalBookingScalarFieldEnum: {
    id: 'id',
    festivalId: 'festivalId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    numberOfTickets: 'numberOfTickets',
    totalAmount: 'totalAmount',
    specialRequests: 'specialRequests',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FestivalBookingScalarFieldEnum = (typeof FestivalBookingScalarFieldEnum)[keyof typeof FestivalBookingScalarFieldEnum]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    address: 'address',
    imageUrl: 'imageUrl',
    images: 'images',
    categoryId: 'categoryId',
    starRating: 'starRating',
    amenities: 'amenities',
    features: 'features',
    pricePerNight: 'pricePerNight',
    isActive: 'isActive',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    cancellationPolicy: 'cancellationPolicy',
    createdAt: 'createdAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const HotelRoomScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomType: 'roomType',
    roomName: 'roomName',
    description: 'description',
    imageUrl: 'imageUrl',
    images: 'images',
    maxOccupancy: 'maxOccupancy',
    bedType: 'bedType',
    roomSize: 'roomSize',
    amenities: 'amenities',
    pricePerNight: 'pricePerNight',
    totalRooms: 'totalRooms',
    isActive: 'isActive'
  };

  export type HotelRoomScalarFieldEnum = (typeof HotelRoomScalarFieldEnum)[keyof typeof HotelRoomScalarFieldEnum]


  export const HotelBookingScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomId: 'roomId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    numberOfRooms: 'numberOfRooms',
    numberOfGuests: 'numberOfGuests',
    totalAmount: 'totalAmount',
    specialRequests: 'specialRequests',
    status: 'status',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt'
  };

  export type HotelBookingScalarFieldEnum = (typeof HotelBookingScalarFieldEnum)[keyof typeof HotelBookingScalarFieldEnum]


  export const UserAccountScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const UserFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itineraryId: 'itineraryId',
    tourId: 'tourId',
    rating: 'rating',
    comment: 'comment',
    category: 'category',
    isPublic: 'isPublic',
    createdAt: 'createdAt'
  };

  export type UserFeedbackScalarFieldEnum = (typeof UserFeedbackScalarFieldEnum)[keyof typeof UserFeedbackScalarFieldEnum]


  export const TourCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    description: 'description',
    isActive: 'isActive',
    displayOrder: 'displayOrder'
  };

  export type TourCategoryScalarFieldEnum = (typeof TourCategoryScalarFieldEnum)[keyof typeof TourCategoryScalarFieldEnum]


  export const HotelCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    description: 'description',
    isActive: 'isActive',
    displayOrder: 'displayOrder'
  };

  export type HotelCategoryScalarFieldEnum = (typeof HotelCategoryScalarFieldEnum)[keyof typeof HotelCategoryScalarFieldEnum]


  export const TravelActivityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    difficulty: 'difficulty',
    isActive: 'isActive',
    displayOrder: 'displayOrder'
  };

  export type TravelActivityScalarFieldEnum = (typeof TravelActivityScalarFieldEnum)[keyof typeof TravelActivityScalarFieldEnum]


  export const TravelInterestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    displayOrder: 'displayOrder'
  };

  export type TravelInterestScalarFieldEnum = (typeof TravelInterestScalarFieldEnum)[keyof typeof TravelInterestScalarFieldEnum]


  export const FlightRouteScalarFieldEnum: {
    id: 'id',
    origin: 'origin',
    destination: 'destination',
    airline: 'airline',
    duration: 'duration',
    frequency: 'frequency',
    price: 'price',
    isActive: 'isActive'
  };

  export type FlightRouteScalarFieldEnum = (typeof FlightRouteScalarFieldEnum)[keyof typeof FlightRouteScalarFieldEnum]


  export const AccommodationTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    isActive: 'isActive'
  };

  export type AccommodationTypeScalarFieldEnum = (typeof AccommodationTypeScalarFieldEnum)[keyof typeof AccommodationTypeScalarFieldEnum]


  export const DifficultyLevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive'
  };

  export type DifficultyLevelScalarFieldEnum = (typeof DifficultyLevelScalarFieldEnum)[keyof typeof DifficultyLevelScalarFieldEnum]


  export const SeasonalPeriodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weather: 'weather',
    isActive: 'isActive'
  };

  export type SeasonalPeriodScalarFieldEnum = (typeof SeasonalPeriodScalarFieldEnum)[keyof typeof SeasonalPeriodScalarFieldEnum]


  export const BookingActivityScalarFieldEnum: {
    bookingId: 'bookingId',
    activityId: 'activityId'
  };

  export type BookingActivityScalarFieldEnum = (typeof BookingActivityScalarFieldEnum)[keyof typeof BookingActivityScalarFieldEnum]


  export const UserInterestScalarFieldEnum: {
    userId: 'userId',
    interestId: 'interestId'
  };

  export type UserInterestScalarFieldEnum = (typeof UserInterestScalarFieldEnum)[keyof typeof UserInterestScalarFieldEnum]


  export const CustomTourInterestScalarFieldEnum: {
    customTourRequestId: 'customTourRequestId',
    interestId: 'interestId'
  };

  export type CustomTourInterestScalarFieldEnum = (typeof CustomTourInterestScalarFieldEnum)[keyof typeof CustomTourInterestScalarFieldEnum]


  export const FlightBookingScalarFieldEnum: {
    id: 'id',
    flightRouteId: 'flightRouteId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    departureDate: 'departureDate',
    returnDate: 'returnDate',
    numberOfPassengers: 'numberOfPassengers',
    totalAmount: 'totalAmount',
    specialRequests: 'specialRequests',
    status: 'status',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt'
  };

  export type FlightBookingScalarFieldEnum = (typeof FlightBookingScalarFieldEnum)[keyof typeof FlightBookingScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    duration: 'duration',
    difficulty: 'difficulty',
    price: 'price',
    description: 'description',
    location: 'location',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const TourActivityJunctionScalarFieldEnum: {
    tourId: 'tourId',
    activityId: 'activityId',
    included: 'included',
    optional: 'optional'
  };

  export type TourActivityJunctionScalarFieldEnum = (typeof TourActivityJunctionScalarFieldEnum)[keyof typeof TourActivityJunctionScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    experiences: 'experiences',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const FlightScalarFieldEnum: {
    id: 'id',
    airline: 'airline',
    route: 'route',
    duration: 'duration',
    frequency: 'frequency',
    price: 'price',
    aircraft: 'aircraft',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlightScalarFieldEnum = (typeof FlightScalarFieldEnum)[keyof typeof FlightScalarFieldEnum]


  export const TourFestivalScalarFieldEnum: {
    id: 'id',
    tourId: 'tourId',
    festivalId: 'festivalId'
  };

  export type TourFestivalScalarFieldEnum = (typeof TourFestivalScalarFieldEnum)[keyof typeof TourFestivalScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    userEmail: 'userEmail',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sender: 'sender',
    message: 'message',
    messageType: 'messageType',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    priority: 'priority',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    hotelBookingId: 'hotelBookingId',
    flightBookingId: 'flightBookingId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentGateway: 'paymentGateway',
    transactionId: 'transactionId',
    status: 'status',
    paidAt: 'paidAt',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type TourWhereInput = {
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    id?: IntFilter<"Tour"> | number
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    duration?: StringFilter<"Tour"> | string
    price?: FloatFilter<"Tour"> | number
    maxPrice?: FloatNullableFilter<"Tour"> | number | null
    categoryName?: StringFilter<"Tour"> | string
    difficulty?: StringNullableFilter<"Tour"> | string | null
    groupSize?: StringNullableFilter<"Tour"> | string | null
    imageUrl?: StringNullableFilter<"Tour"> | string | null
    highlights?: StringNullableListFilter<"Tour">
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    itinerary?: StringNullableFilter<"Tour"> | string | null
    bestTime?: StringNullableListFilter<"Tour">
    physicalRating?: StringNullableFilter<"Tour"> | string | null
    culturalLevel?: StringNullableFilter<"Tour"> | string | null
    luxuryLevel?: StringNullableFilter<"Tour"> | string | null
    spiritualLevel?: StringNullableFilter<"Tour"> | string | null
    rating?: FloatFilter<"Tour"> | number
    isActive?: BoolFilter<"Tour"> | boolean
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
    bookings?: BookingListRelationFilter
    itineraries?: ItineraryListRelationFilter
    tourOperator?: XOR<TourOperatorNullableRelationFilter, TourOperatorWhereInput> | null
    userFeedback?: UserFeedbackListRelationFilter
    tourFestivals?: TourFestivalListRelationFilter
    tourActivities?: TourActivityJunctionListRelationFilter
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrderInput | SortOrder
    categoryName?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    highlights?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    itinerary?: SortOrderInput | SortOrder
    bestTime?: SortOrder
    physicalRating?: SortOrderInput | SortOrder
    culturalLevel?: SortOrderInput | SortOrder
    luxuryLevel?: SortOrderInput | SortOrder
    spiritualLevel?: SortOrderInput | SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourOperatorId?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    itineraries?: ItineraryOrderByRelationAggregateInput
    tourOperator?: TourOperatorOrderByWithRelationInput
    userFeedback?: UserFeedbackOrderByRelationAggregateInput
    tourFestivals?: TourFestivalOrderByRelationAggregateInput
    tourActivities?: TourActivityJunctionOrderByRelationAggregateInput
  }

  export type TourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    duration?: StringFilter<"Tour"> | string
    price?: FloatFilter<"Tour"> | number
    maxPrice?: FloatNullableFilter<"Tour"> | number | null
    categoryName?: StringFilter<"Tour"> | string
    difficulty?: StringNullableFilter<"Tour"> | string | null
    groupSize?: StringNullableFilter<"Tour"> | string | null
    imageUrl?: StringNullableFilter<"Tour"> | string | null
    highlights?: StringNullableListFilter<"Tour">
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    itinerary?: StringNullableFilter<"Tour"> | string | null
    bestTime?: StringNullableListFilter<"Tour">
    physicalRating?: StringNullableFilter<"Tour"> | string | null
    culturalLevel?: StringNullableFilter<"Tour"> | string | null
    luxuryLevel?: StringNullableFilter<"Tour"> | string | null
    spiritualLevel?: StringNullableFilter<"Tour"> | string | null
    rating?: FloatFilter<"Tour"> | number
    isActive?: BoolFilter<"Tour"> | boolean
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
    bookings?: BookingListRelationFilter
    itineraries?: ItineraryListRelationFilter
    tourOperator?: XOR<TourOperatorNullableRelationFilter, TourOperatorWhereInput> | null
    userFeedback?: UserFeedbackListRelationFilter
    tourFestivals?: TourFestivalListRelationFilter
    tourActivities?: TourActivityJunctionListRelationFilter
  }, "id">

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrderInput | SortOrder
    categoryName?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    highlights?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    itinerary?: SortOrderInput | SortOrder
    bestTime?: SortOrder
    physicalRating?: SortOrderInput | SortOrder
    culturalLevel?: SortOrderInput | SortOrder
    luxuryLevel?: SortOrderInput | SortOrder
    spiritualLevel?: SortOrderInput | SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourOperatorId?: SortOrderInput | SortOrder
    _count?: TourCountOrderByAggregateInput
    _avg?: TourAvgOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
    _sum?: TourSumOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    OR?: TourScalarWhereWithAggregatesInput[]
    NOT?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tour"> | number
    name?: StringWithAggregatesFilter<"Tour"> | string
    description?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    duration?: StringWithAggregatesFilter<"Tour"> | string
    price?: FloatWithAggregatesFilter<"Tour"> | number
    maxPrice?: FloatNullableWithAggregatesFilter<"Tour"> | number | null
    categoryName?: StringWithAggregatesFilter<"Tour"> | string
    difficulty?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    groupSize?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    highlights?: StringNullableListFilter<"Tour">
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    itinerary?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    bestTime?: StringNullableListFilter<"Tour">
    physicalRating?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    culturalLevel?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    luxuryLevel?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    spiritualLevel?: StringNullableWithAggregatesFilter<"Tour"> | string | null
    rating?: FloatWithAggregatesFilter<"Tour"> | number
    isActive?: BoolWithAggregatesFilter<"Tour"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    tourOperatorId?: IntNullableWithAggregatesFilter<"Tour"> | number | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    activities?: BookingActivityListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    tour?: TourOrderByWithRelationInput
    activities?: BookingActivityOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    activities?: BookingActivityListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    tourId?: IntWithAggregatesFilter<"Booking"> | number
    firstName?: StringWithAggregatesFilter<"Booking"> | string
    lastName?: StringWithAggregatesFilter<"Booking"> | string
    email?: StringWithAggregatesFilter<"Booking"> | string
    phone?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    travelDate?: StringWithAggregatesFilter<"Booking"> | string
    groupSize?: IntWithAggregatesFilter<"Booking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: IntFilter<"Inquiry"> | number
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableFilter<"Inquiry"> | string | null
    groupSize?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringNullableFilter<"Inquiry"> | string | null
    status?: StringFilter<"Inquiry"> | string
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    tourInterest?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableFilter<"Inquiry"> | string | null
    groupSize?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringNullableFilter<"Inquiry"> | string | null
    status?: StringFilter<"Inquiry"> | string
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    tourInterest?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inquiry"> | number
    firstName?: StringWithAggregatesFilter<"Inquiry"> | string
    lastName?: StringWithAggregatesFilter<"Inquiry"> | string
    email?: StringWithAggregatesFilter<"Inquiry"> | string
    phone?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    tourInterest?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    preferredDates?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    groupSize?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    message?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    status?: StringWithAggregatesFilter<"Inquiry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: IntFilter<"Testimonial"> | number
    name?: StringFilter<"Testimonial"> | string
    country?: StringFilter<"Testimonial"> | string
    imageUrl?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    tripName?: StringFilter<"Testimonial"> | string
    duration?: StringFilter<"Testimonial"> | string
    isActive?: BoolFilter<"Testimonial"> | boolean
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    name?: StringFilter<"Testimonial"> | string
    country?: StringFilter<"Testimonial"> | string
    imageUrl?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    tripName?: StringFilter<"Testimonial"> | string
    duration?: StringFilter<"Testimonial"> | string
    isActive?: BoolFilter<"Testimonial"> | boolean
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Testimonial"> | number
    name?: StringWithAggregatesFilter<"Testimonial"> | string
    country?: StringWithAggregatesFilter<"Testimonial"> | string
    imageUrl?: StringWithAggregatesFilter<"Testimonial"> | string
    text?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    tripName?: StringWithAggregatesFilter<"Testimonial"> | string
    duration?: StringWithAggregatesFilter<"Testimonial"> | string
    isActive?: BoolWithAggregatesFilter<"Testimonial"> | boolean
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    imageUrl?: StringFilter<"BlogPost"> | string
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    authorImage?: StringFilter<"BlogPost"> | string
    readTime?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeFilter<"BlogPost"> | Date | string
    isPublished?: BoolFilter<"BlogPost"> | boolean
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    excerpt?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    imageUrl?: StringFilter<"BlogPost"> | string
    category?: StringFilter<"BlogPost"> | string
    author?: StringFilter<"BlogPost"> | string
    authorImage?: StringFilter<"BlogPost"> | string
    readTime?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeFilter<"BlogPost"> | Date | string
    isPublished?: BoolFilter<"BlogPost"> | boolean
  }, "id">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogPost"> | number
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    imageUrl?: StringWithAggregatesFilter<"BlogPost"> | string
    category?: StringWithAggregatesFilter<"BlogPost"> | string
    author?: StringWithAggregatesFilter<"BlogPost"> | string
    authorImage?: StringWithAggregatesFilter<"BlogPost"> | string
    readTime?: StringWithAggregatesFilter<"BlogPost"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"BlogPost"> | boolean
  }

  export type GuideWhereInput = {
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    id?: IntFilter<"Guide"> | number
    name?: StringFilter<"Guide"> | string
    email?: StringFilter<"Guide"> | string
    phone?: StringFilter<"Guide"> | string
    licenseImageUrl?: StringFilter<"Guide"> | string
    registrationType?: StringFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    guidedItineraries?: ItineraryListRelationFilter
    drivenItineraries?: ItineraryListRelationFilter
  }

  export type GuideOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    guidedItineraries?: ItineraryOrderByRelationAggregateInput
    drivenItineraries?: ItineraryOrderByRelationAggregateInput
  }

  export type GuideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    name?: StringFilter<"Guide"> | string
    phone?: StringFilter<"Guide"> | string
    licenseImageUrl?: StringFilter<"Guide"> | string
    registrationType?: StringFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    guidedItineraries?: ItineraryListRelationFilter
    drivenItineraries?: ItineraryListRelationFilter
  }, "id" | "email">

  export type GuideOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: GuideCountOrderByAggregateInput
    _avg?: GuideAvgOrderByAggregateInput
    _max?: GuideMaxOrderByAggregateInput
    _min?: GuideMinOrderByAggregateInput
    _sum?: GuideSumOrderByAggregateInput
  }

  export type GuideScalarWhereWithAggregatesInput = {
    AND?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    OR?: GuideScalarWhereWithAggregatesInput[]
    NOT?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Guide"> | number
    name?: StringWithAggregatesFilter<"Guide"> | string
    email?: StringWithAggregatesFilter<"Guide"> | string
    phone?: StringWithAggregatesFilter<"Guide"> | string
    licenseImageUrl?: StringWithAggregatesFilter<"Guide"> | string
    registrationType?: StringWithAggregatesFilter<"Guide"> | string
    specializations?: StringNullableListFilter<"Guide">
    status?: StringWithAggregatesFilter<"Guide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
  }

  export type ItineraryWhereInput = {
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    guide?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    driver?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    days?: ItineraryDayListRelationFilter
    assignedCustomTourRequests?: CustomTourRequestListRelationFilter
    UserFeedback?: UserFeedbackListRelationFilter
  }

  export type ItineraryOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    tour?: TourOrderByWithRelationInput
    guide?: GuideOrderByWithRelationInput
    driver?: GuideOrderByWithRelationInput
    days?: ItineraryDayOrderByRelationAggregateInput
    assignedCustomTourRequests?: CustomTourRequestOrderByRelationAggregateInput
    UserFeedback?: UserFeedbackOrderByRelationAggregateInput
  }

  export type ItineraryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
    tour?: XOR<TourRelationFilter, TourWhereInput>
    guide?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    driver?: XOR<GuideNullableRelationFilter, GuideWhereInput> | null
    days?: ItineraryDayListRelationFilter
    assignedCustomTourRequests?: CustomTourRequestListRelationFilter
    UserFeedback?: UserFeedbackListRelationFilter
  }, "id">

  export type ItineraryOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _avg?: ItineraryAvgOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
    _sum?: ItinerarySumOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    OR?: ItineraryScalarWhereWithAggregatesInput[]
    NOT?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Itinerary"> | number
    tourId?: IntWithAggregatesFilter<"Itinerary"> | number
    name?: StringWithAggregatesFilter<"Itinerary"> | string
    description?: StringNullableWithAggregatesFilter<"Itinerary"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
    guideId?: IntNullableWithAggregatesFilter<"Itinerary"> | number | null
    driverId?: IntNullableWithAggregatesFilter<"Itinerary"> | number | null
    maxParticipants?: IntWithAggregatesFilter<"Itinerary"> | number
    currentParticipants?: IntWithAggregatesFilter<"Itinerary"> | number
    status?: StringWithAggregatesFilter<"Itinerary"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
  }

  export type ItineraryDayWhereInput = {
    AND?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    OR?: ItineraryDayWhereInput[]
    NOT?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    id?: IntFilter<"ItineraryDay"> | number
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
  }

  export type ItineraryDayOrderByWithRelationInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrderInput | SortOrder
    meals?: SortOrder
    transportation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    itinerary?: ItineraryOrderByWithRelationInput
  }

  export type ItineraryDayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    OR?: ItineraryDayWhereInput[]
    NOT?: ItineraryDayWhereInput | ItineraryDayWhereInput[]
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
  }, "id">

  export type ItineraryDayOrderByWithAggregationInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrderInput | SortOrder
    meals?: SortOrder
    transportation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ItineraryDayCountOrderByAggregateInput
    _avg?: ItineraryDayAvgOrderByAggregateInput
    _max?: ItineraryDayMaxOrderByAggregateInput
    _min?: ItineraryDayMinOrderByAggregateInput
    _sum?: ItineraryDaySumOrderByAggregateInput
  }

  export type ItineraryDayScalarWhereWithAggregatesInput = {
    AND?: ItineraryDayScalarWhereWithAggregatesInput | ItineraryDayScalarWhereWithAggregatesInput[]
    OR?: ItineraryDayScalarWhereWithAggregatesInput[]
    NOT?: ItineraryDayScalarWhereWithAggregatesInput | ItineraryDayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItineraryDay"> | number
    itineraryId?: IntWithAggregatesFilter<"ItineraryDay"> | number
    dayNumber?: IntWithAggregatesFilter<"ItineraryDay"> | number
    title?: StringWithAggregatesFilter<"ItineraryDay"> | string
    description?: StringWithAggregatesFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ItineraryDay"> | string | null
  }

  export type CustomTourRequestWhereInput = {
    AND?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    OR?: CustomTourRequestWhereInput[]
    NOT?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    id?: IntFilter<"CustomTourRequest"> | number
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
    assignedItinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    interests?: CustomTourInterestListRelationFilter
  }

  export type CustomTourRequestOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrderInput | SortOrder
    transportPreference?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    assignedItineraryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    assignedItinerary?: ItineraryOrderByWithRelationInput
    interests?: CustomTourInterestOrderByRelationAggregateInput
  }

  export type CustomTourRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    OR?: CustomTourRequestWhereInput[]
    NOT?: CustomTourRequestWhereInput | CustomTourRequestWhereInput[]
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
    assignedItinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    interests?: CustomTourInterestListRelationFilter
  }, "id">

  export type CustomTourRequestOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrderInput | SortOrder
    preferredDates?: SortOrderInput | SortOrder
    specialRequirements?: SortOrderInput | SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrderInput | SortOrder
    transportPreference?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    assignedItineraryId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomTourRequestCountOrderByAggregateInput
    _avg?: CustomTourRequestAvgOrderByAggregateInput
    _max?: CustomTourRequestMaxOrderByAggregateInput
    _min?: CustomTourRequestMinOrderByAggregateInput
    _sum?: CustomTourRequestSumOrderByAggregateInput
  }

  export type CustomTourRequestScalarWhereWithAggregatesInput = {
    AND?: CustomTourRequestScalarWhereWithAggregatesInput | CustomTourRequestScalarWhereWithAggregatesInput[]
    OR?: CustomTourRequestScalarWhereWithAggregatesInput[]
    NOT?: CustomTourRequestScalarWhereWithAggregatesInput | CustomTourRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    firstName?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    lastName?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    email?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    phone?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    duration?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    groupSize?: IntWithAggregatesFilter<"CustomTourRequest"> | number
    budget?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    preferredDates?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    status?: StringWithAggregatesFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableWithAggregatesFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableWithAggregatesFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomTourRequest"> | Date | string
  }

  export type TourOperatorWhereInput = {
    AND?: TourOperatorWhereInput | TourOperatorWhereInput[]
    OR?: TourOperatorWhereInput[]
    NOT?: TourOperatorWhereInput | TourOperatorWhereInput[]
    id?: IntFilter<"TourOperator"> | number
    name?: StringFilter<"TourOperator"> | string
    website?: StringFilter<"TourOperator"> | string
    description?: StringFilter<"TourOperator"> | string
    bestFeature?: StringFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatFilter<"TourOperator"> | number
    reviewCount?: IntFilter<"TourOperator"> | number
    logoUrl?: StringNullableFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableFilter<"TourOperator"> | string | null
    isActive?: BoolFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeFilter<"TourOperator"> | Date | string
    tours?: TourListRelationFilter
  }

  export type TourOperatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrderInput | SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
    tours?: TourOrderByRelationAggregateInput
  }

  export type TourOperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TourOperatorWhereInput | TourOperatorWhereInput[]
    OR?: TourOperatorWhereInput[]
    NOT?: TourOperatorWhereInput | TourOperatorWhereInput[]
    website?: StringFilter<"TourOperator"> | string
    description?: StringFilter<"TourOperator"> | string
    bestFeature?: StringFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatFilter<"TourOperator"> | number
    reviewCount?: IntFilter<"TourOperator"> | number
    logoUrl?: StringNullableFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableFilter<"TourOperator"> | string | null
    isActive?: BoolFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeFilter<"TourOperator"> | Date | string
    tours?: TourListRelationFilter
  }, "id" | "name">

  export type TourOperatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrderInput | SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
    _count?: TourOperatorCountOrderByAggregateInput
    _avg?: TourOperatorAvgOrderByAggregateInput
    _max?: TourOperatorMaxOrderByAggregateInput
    _min?: TourOperatorMinOrderByAggregateInput
    _sum?: TourOperatorSumOrderByAggregateInput
  }

  export type TourOperatorScalarWhereWithAggregatesInput = {
    AND?: TourOperatorScalarWhereWithAggregatesInput | TourOperatorScalarWhereWithAggregatesInput[]
    OR?: TourOperatorScalarWhereWithAggregatesInput[]
    NOT?: TourOperatorScalarWhereWithAggregatesInput | TourOperatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TourOperator"> | number
    name?: StringWithAggregatesFilter<"TourOperator"> | string
    website?: StringWithAggregatesFilter<"TourOperator"> | string
    description?: StringWithAggregatesFilter<"TourOperator"> | string
    bestFeature?: StringWithAggregatesFilter<"TourOperator"> | string
    specialties?: StringNullableListFilter<"TourOperator">
    rating?: FloatWithAggregatesFilter<"TourOperator"> | number
    reviewCount?: IntWithAggregatesFilter<"TourOperator"> | number
    logoUrl?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"TourOperator"> | string | null
    isActive?: BoolWithAggregatesFilter<"TourOperator"> | boolean
    establishedYear?: IntNullableWithAggregatesFilter<"TourOperator"> | number | null
    certifications?: StringNullableListFilter<"TourOperator">
    awards?: StringNullableListFilter<"TourOperator">
    createdAt?: DateTimeWithAggregatesFilter<"TourOperator"> | Date | string
  }

  export type FestivalWhereInput = {
    AND?: FestivalWhereInput | FestivalWhereInput[]
    OR?: FestivalWhereInput[]
    NOT?: FestivalWhereInput | FestivalWhereInput[]
    id?: IntFilter<"Festival"> | number
    name?: StringFilter<"Festival"> | string
    description?: StringNullableFilter<"Festival"> | string | null
    location?: StringNullableFilter<"Festival"> | string | null
    dates?: StringNullableFilter<"Festival"> | string | null
    duration?: StringNullableFilter<"Festival"> | string | null
    significance?: StringNullableFilter<"Festival"> | string | null
    activities?: StringNullableListFilter<"Festival">
    imageUrl?: StringNullableFilter<"Festival"> | string | null
    isActive?: BoolFilter<"Festival"> | boolean
    createdAt?: DateTimeFilter<"Festival"> | Date | string
    updatedAt?: DateTimeFilter<"Festival"> | Date | string
    tourFestivals?: TourFestivalListRelationFilter
    festivalBookings?: FestivalBookingListRelationFilter
  }

  export type FestivalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    dates?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    significance?: SortOrderInput | SortOrder
    activities?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourFestivals?: TourFestivalOrderByRelationAggregateInput
    festivalBookings?: FestivalBookingOrderByRelationAggregateInput
  }

  export type FestivalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FestivalWhereInput | FestivalWhereInput[]
    OR?: FestivalWhereInput[]
    NOT?: FestivalWhereInput | FestivalWhereInput[]
    name?: StringFilter<"Festival"> | string
    description?: StringNullableFilter<"Festival"> | string | null
    location?: StringNullableFilter<"Festival"> | string | null
    dates?: StringNullableFilter<"Festival"> | string | null
    duration?: StringNullableFilter<"Festival"> | string | null
    significance?: StringNullableFilter<"Festival"> | string | null
    activities?: StringNullableListFilter<"Festival">
    imageUrl?: StringNullableFilter<"Festival"> | string | null
    isActive?: BoolFilter<"Festival"> | boolean
    createdAt?: DateTimeFilter<"Festival"> | Date | string
    updatedAt?: DateTimeFilter<"Festival"> | Date | string
    tourFestivals?: TourFestivalListRelationFilter
    festivalBookings?: FestivalBookingListRelationFilter
  }, "id">

  export type FestivalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    dates?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    significance?: SortOrderInput | SortOrder
    activities?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FestivalCountOrderByAggregateInput
    _avg?: FestivalAvgOrderByAggregateInput
    _max?: FestivalMaxOrderByAggregateInput
    _min?: FestivalMinOrderByAggregateInput
    _sum?: FestivalSumOrderByAggregateInput
  }

  export type FestivalScalarWhereWithAggregatesInput = {
    AND?: FestivalScalarWhereWithAggregatesInput | FestivalScalarWhereWithAggregatesInput[]
    OR?: FestivalScalarWhereWithAggregatesInput[]
    NOT?: FestivalScalarWhereWithAggregatesInput | FestivalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Festival"> | number
    name?: StringWithAggregatesFilter<"Festival"> | string
    description?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    location?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    dates?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    significance?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    activities?: StringNullableListFilter<"Festival">
    imageUrl?: StringNullableWithAggregatesFilter<"Festival"> | string | null
    isActive?: BoolWithAggregatesFilter<"Festival"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Festival"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Festival"> | Date | string
  }

  export type FestivalBookingWhereInput = {
    AND?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    OR?: FestivalBookingWhereInput[]
    NOT?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    id?: IntFilter<"FestivalBooking"> | number
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }

  export type FestivalBookingOrderByWithRelationInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    festival?: FestivalOrderByWithRelationInput
  }

  export type FestivalBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    OR?: FestivalBookingWhereInput[]
    NOT?: FestivalBookingWhereInput | FestivalBookingWhereInput[]
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }, "id">

  export type FestivalBookingOrderByWithAggregationInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FestivalBookingCountOrderByAggregateInput
    _avg?: FestivalBookingAvgOrderByAggregateInput
    _max?: FestivalBookingMaxOrderByAggregateInput
    _min?: FestivalBookingMinOrderByAggregateInput
    _sum?: FestivalBookingSumOrderByAggregateInput
  }

  export type FestivalBookingScalarWhereWithAggregatesInput = {
    AND?: FestivalBookingScalarWhereWithAggregatesInput | FestivalBookingScalarWhereWithAggregatesInput[]
    OR?: FestivalBookingScalarWhereWithAggregatesInput[]
    NOT?: FestivalBookingScalarWhereWithAggregatesInput | FestivalBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FestivalBooking"> | number
    festivalId?: IntWithAggregatesFilter<"FestivalBooking"> | number
    firstName?: StringWithAggregatesFilter<"FestivalBooking"> | string
    lastName?: StringWithAggregatesFilter<"FestivalBooking"> | string
    email?: StringWithAggregatesFilter<"FestivalBooking"> | string
    phone?: StringNullableWithAggregatesFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntWithAggregatesFilter<"FestivalBooking"> | number
    totalAmount?: IntWithAggregatesFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"FestivalBooking"> | string | null
    status?: StringWithAggregatesFilter<"FestivalBooking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FestivalBooking"> | Date | string
  }

  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    location?: StringFilter<"Hotel"> | string
    address?: StringFilter<"Hotel"> | string
    imageUrl?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    categoryId?: StringFilter<"Hotel"> | string
    starRating?: IntFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntFilter<"Hotel"> | number
    isActive?: BoolFilter<"Hotel"> | boolean
    contactEmail?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    checkInTime?: StringFilter<"Hotel"> | string
    checkOutTime?: StringFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    category?: XOR<HotelCategoryRelationFilter, HotelCategoryWhereInput>
    rooms?: HotelRoomListRelationFilter
    bookings?: HotelBookingListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    category?: HotelCategoryOrderByWithRelationInput
    rooms?: HotelRoomOrderByRelationAggregateInput
    bookings?: HotelBookingOrderByRelationAggregateInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    location?: StringFilter<"Hotel"> | string
    address?: StringFilter<"Hotel"> | string
    imageUrl?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    categoryId?: StringFilter<"Hotel"> | string
    starRating?: IntFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntFilter<"Hotel"> | number
    isActive?: BoolFilter<"Hotel"> | boolean
    contactEmail?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    checkInTime?: StringFilter<"Hotel"> | string
    checkOutTime?: StringFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    category?: XOR<HotelCategoryRelationFilter, HotelCategoryWhereInput>
    rooms?: HotelRoomListRelationFilter
    bookings?: HotelBookingListRelationFilter
  }, "id">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hotel"> | number
    name?: StringWithAggregatesFilter<"Hotel"> | string
    description?: StringWithAggregatesFilter<"Hotel"> | string
    location?: StringWithAggregatesFilter<"Hotel"> | string
    address?: StringWithAggregatesFilter<"Hotel"> | string
    imageUrl?: StringWithAggregatesFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    categoryId?: StringWithAggregatesFilter<"Hotel"> | string
    starRating?: IntWithAggregatesFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntWithAggregatesFilter<"Hotel"> | number
    isActive?: BoolWithAggregatesFilter<"Hotel"> | boolean
    contactEmail?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    website?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    checkInTime?: StringWithAggregatesFilter<"Hotel"> | string
    checkOutTime?: StringWithAggregatesFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
  }

  export type HotelRoomWhereInput = {
    AND?: HotelRoomWhereInput | HotelRoomWhereInput[]
    OR?: HotelRoomWhereInput[]
    NOT?: HotelRoomWhereInput | HotelRoomWhereInput[]
    id?: IntFilter<"HotelRoom"> | number
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    bookings?: HotelBookingListRelationFilter
  }

  export type HotelRoomOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    bookings?: HotelBookingOrderByRelationAggregateInput
  }

  export type HotelRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelRoomWhereInput | HotelRoomWhereInput[]
    OR?: HotelRoomWhereInput[]
    NOT?: HotelRoomWhereInput | HotelRoomWhereInput[]
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    bookings?: HotelBookingListRelationFilter
  }, "id">

  export type HotelRoomOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrderInput | SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
    _count?: HotelRoomCountOrderByAggregateInput
    _avg?: HotelRoomAvgOrderByAggregateInput
    _max?: HotelRoomMaxOrderByAggregateInput
    _min?: HotelRoomMinOrderByAggregateInput
    _sum?: HotelRoomSumOrderByAggregateInput
  }

  export type HotelRoomScalarWhereWithAggregatesInput = {
    AND?: HotelRoomScalarWhereWithAggregatesInput | HotelRoomScalarWhereWithAggregatesInput[]
    OR?: HotelRoomScalarWhereWithAggregatesInput[]
    NOT?: HotelRoomScalarWhereWithAggregatesInput | HotelRoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelRoom"> | number
    hotelId?: IntWithAggregatesFilter<"HotelRoom"> | number
    roomType?: StringWithAggregatesFilter<"HotelRoom"> | string
    roomName?: StringWithAggregatesFilter<"HotelRoom"> | string
    description?: StringWithAggregatesFilter<"HotelRoom"> | string
    imageUrl?: StringWithAggregatesFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntWithAggregatesFilter<"HotelRoom"> | number
    bedType?: StringWithAggregatesFilter<"HotelRoom"> | string
    roomSize?: StringNullableWithAggregatesFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntWithAggregatesFilter<"HotelRoom"> | number
    totalRooms?: IntWithAggregatesFilter<"HotelRoom"> | number
    isActive?: BoolWithAggregatesFilter<"HotelRoom"> | boolean
  }

  export type HotelBookingWhereInput = {
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    id?: IntFilter<"HotelBooking"> | number
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    room?: XOR<HotelRoomRelationFilter, HotelRoomWhereInput>
  }

  export type HotelBookingOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    room?: HotelRoomOrderByWithRelationInput
  }

  export type HotelBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HotelBookingWhereInput | HotelBookingWhereInput[]
    OR?: HotelBookingWhereInput[]
    NOT?: HotelBookingWhereInput | HotelBookingWhereInput[]
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    room?: XOR<HotelRoomRelationFilter, HotelRoomWhereInput>
  }, "id">

  export type HotelBookingOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    _count?: HotelBookingCountOrderByAggregateInput
    _avg?: HotelBookingAvgOrderByAggregateInput
    _max?: HotelBookingMaxOrderByAggregateInput
    _min?: HotelBookingMinOrderByAggregateInput
    _sum?: HotelBookingSumOrderByAggregateInput
  }

  export type HotelBookingScalarWhereWithAggregatesInput = {
    AND?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    OR?: HotelBookingScalarWhereWithAggregatesInput[]
    NOT?: HotelBookingScalarWhereWithAggregatesInput | HotelBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HotelBooking"> | number
    hotelId?: IntWithAggregatesFilter<"HotelBooking"> | number
    roomId?: IntWithAggregatesFilter<"HotelBooking"> | number
    firstName?: StringWithAggregatesFilter<"HotelBooking"> | string
    lastName?: StringWithAggregatesFilter<"HotelBooking"> | string
    email?: StringWithAggregatesFilter<"HotelBooking"> | string
    phone?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntWithAggregatesFilter<"HotelBooking"> | number
    numberOfGuests?: IntWithAggregatesFilter<"HotelBooking"> | number
    totalAmount?: IntWithAggregatesFilter<"HotelBooking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"HotelBooking"> | string | null
    status?: StringWithAggregatesFilter<"HotelBooking"> | string
    paymentStatus?: StringWithAggregatesFilter<"HotelBooking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HotelBooking"> | Date | string
  }

  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    id?: IntFilter<"UserAccount"> | number
    email?: StringFilter<"UserAccount"> | string
    password?: StringFilter<"UserAccount"> | string
    firstName?: StringFilter<"UserAccount"> | string
    lastName?: StringFilter<"UserAccount"> | string
    phone?: StringNullableFilter<"UserAccount"> | string | null
    role?: StringFilter<"UserAccount"> | string
    isActive?: BoolFilter<"UserAccount"> | boolean
    profileImage?: StringNullableFilter<"UserAccount"> | string | null
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    feedbacks?: UserFeedbackListRelationFilter
    interests?: UserInterestListRelationFilter
  }

  export type UserAccountOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    feedbacks?: UserFeedbackOrderByRelationAggregateInput
    interests?: UserInterestOrderByRelationAggregateInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    password?: StringFilter<"UserAccount"> | string
    firstName?: StringFilter<"UserAccount"> | string
    lastName?: StringFilter<"UserAccount"> | string
    phone?: StringNullableFilter<"UserAccount"> | string | null
    role?: StringFilter<"UserAccount"> | string
    isActive?: BoolFilter<"UserAccount"> | boolean
    profileImage?: StringNullableFilter<"UserAccount"> | string | null
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"UserAccount"> | Date | string | null
    feedbacks?: UserFeedbackListRelationFilter
    interests?: UserInterestListRelationFilter
  }, "id" | "email">

  export type UserAccountOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _avg?: UserAccountAvgOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
    _sum?: UserAccountSumOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAccount"> | number
    email?: StringWithAggregatesFilter<"UserAccount"> | string
    password?: StringWithAggregatesFilter<"UserAccount"> | string
    firstName?: StringWithAggregatesFilter<"UserAccount"> | string
    lastName?: StringWithAggregatesFilter<"UserAccount"> | string
    phone?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    role?: StringWithAggregatesFilter<"UserAccount"> | string
    isActive?: BoolWithAggregatesFilter<"UserAccount"> | boolean
    profileImage?: StringNullableWithAggregatesFilter<"UserAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"UserAccount"> | Date | string | null
  }

  export type UserFeedbackWhereInput = {
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    id?: IntFilter<"UserFeedback"> | number
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    itinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    tour?: XOR<TourNullableRelationFilter, TourWhereInput> | null
  }

  export type UserFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrderInput | SortOrder
    tourId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    user?: UserAccountOrderByWithRelationInput
    itinerary?: ItineraryOrderByWithRelationInput
    tour?: TourOrderByWithRelationInput
  }

  export type UserFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    OR?: UserFeedbackWhereInput[]
    NOT?: UserFeedbackWhereInput | UserFeedbackWhereInput[]
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    itinerary?: XOR<ItineraryNullableRelationFilter, ItineraryWhereInput> | null
    tour?: XOR<TourNullableRelationFilter, TourWhereInput> | null
  }, "id">

  export type UserFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrderInput | SortOrder
    tourId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    _count?: UserFeedbackCountOrderByAggregateInput
    _avg?: UserFeedbackAvgOrderByAggregateInput
    _max?: UserFeedbackMaxOrderByAggregateInput
    _min?: UserFeedbackMinOrderByAggregateInput
    _sum?: UserFeedbackSumOrderByAggregateInput
  }

  export type UserFeedbackScalarWhereWithAggregatesInput = {
    AND?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    OR?: UserFeedbackScalarWhereWithAggregatesInput[]
    NOT?: UserFeedbackScalarWhereWithAggregatesInput | UserFeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserFeedback"> | number
    userId?: IntWithAggregatesFilter<"UserFeedback"> | number
    itineraryId?: IntNullableWithAggregatesFilter<"UserFeedback"> | number | null
    tourId?: IntNullableWithAggregatesFilter<"UserFeedback"> | number | null
    rating?: IntWithAggregatesFilter<"UserFeedback"> | number
    comment?: StringNullableWithAggregatesFilter<"UserFeedback"> | string | null
    category?: StringWithAggregatesFilter<"UserFeedback"> | string
    isPublic?: BoolWithAggregatesFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserFeedback"> | Date | string
  }

  export type TourCategoryWhereInput = {
    AND?: TourCategoryWhereInput | TourCategoryWhereInput[]
    OR?: TourCategoryWhereInput[]
    NOT?: TourCategoryWhereInput | TourCategoryWhereInput[]
    id?: StringFilter<"TourCategory"> | string
    name?: StringFilter<"TourCategory"> | string
    icon?: StringFilter<"TourCategory"> | string
    description?: StringFilter<"TourCategory"> | string
    isActive?: BoolFilter<"TourCategory"> | boolean
    displayOrder?: IntNullableFilter<"TourCategory"> | number | null
  }

  export type TourCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
  }

  export type TourCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourCategoryWhereInput | TourCategoryWhereInput[]
    OR?: TourCategoryWhereInput[]
    NOT?: TourCategoryWhereInput | TourCategoryWhereInput[]
    name?: StringFilter<"TourCategory"> | string
    icon?: StringFilter<"TourCategory"> | string
    description?: StringFilter<"TourCategory"> | string
    isActive?: BoolFilter<"TourCategory"> | boolean
    displayOrder?: IntNullableFilter<"TourCategory"> | number | null
  }, "id">

  export type TourCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    _count?: TourCategoryCountOrderByAggregateInput
    _avg?: TourCategoryAvgOrderByAggregateInput
    _max?: TourCategoryMaxOrderByAggregateInput
    _min?: TourCategoryMinOrderByAggregateInput
    _sum?: TourCategorySumOrderByAggregateInput
  }

  export type TourCategoryScalarWhereWithAggregatesInput = {
    AND?: TourCategoryScalarWhereWithAggregatesInput | TourCategoryScalarWhereWithAggregatesInput[]
    OR?: TourCategoryScalarWhereWithAggregatesInput[]
    NOT?: TourCategoryScalarWhereWithAggregatesInput | TourCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TourCategory"> | string
    name?: StringWithAggregatesFilter<"TourCategory"> | string
    icon?: StringWithAggregatesFilter<"TourCategory"> | string
    description?: StringWithAggregatesFilter<"TourCategory"> | string
    isActive?: BoolWithAggregatesFilter<"TourCategory"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"TourCategory"> | number | null
  }

  export type HotelCategoryWhereInput = {
    AND?: HotelCategoryWhereInput | HotelCategoryWhereInput[]
    OR?: HotelCategoryWhereInput[]
    NOT?: HotelCategoryWhereInput | HotelCategoryWhereInput[]
    id?: StringFilter<"HotelCategory"> | string
    name?: StringFilter<"HotelCategory"> | string
    icon?: StringFilter<"HotelCategory"> | string
    description?: StringFilter<"HotelCategory"> | string
    isActive?: BoolFilter<"HotelCategory"> | boolean
    displayOrder?: IntNullableFilter<"HotelCategory"> | number | null
    hotels?: HotelListRelationFilter
  }

  export type HotelCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    hotels?: HotelOrderByRelationAggregateInput
  }

  export type HotelCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelCategoryWhereInput | HotelCategoryWhereInput[]
    OR?: HotelCategoryWhereInput[]
    NOT?: HotelCategoryWhereInput | HotelCategoryWhereInput[]
    name?: StringFilter<"HotelCategory"> | string
    icon?: StringFilter<"HotelCategory"> | string
    description?: StringFilter<"HotelCategory"> | string
    isActive?: BoolFilter<"HotelCategory"> | boolean
    displayOrder?: IntNullableFilter<"HotelCategory"> | number | null
    hotels?: HotelListRelationFilter
  }, "id">

  export type HotelCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    _count?: HotelCategoryCountOrderByAggregateInput
    _avg?: HotelCategoryAvgOrderByAggregateInput
    _max?: HotelCategoryMaxOrderByAggregateInput
    _min?: HotelCategoryMinOrderByAggregateInput
    _sum?: HotelCategorySumOrderByAggregateInput
  }

  export type HotelCategoryScalarWhereWithAggregatesInput = {
    AND?: HotelCategoryScalarWhereWithAggregatesInput | HotelCategoryScalarWhereWithAggregatesInput[]
    OR?: HotelCategoryScalarWhereWithAggregatesInput[]
    NOT?: HotelCategoryScalarWhereWithAggregatesInput | HotelCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelCategory"> | string
    name?: StringWithAggregatesFilter<"HotelCategory"> | string
    icon?: StringWithAggregatesFilter<"HotelCategory"> | string
    description?: StringWithAggregatesFilter<"HotelCategory"> | string
    isActive?: BoolWithAggregatesFilter<"HotelCategory"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"HotelCategory"> | number | null
  }

  export type TravelActivityWhereInput = {
    AND?: TravelActivityWhereInput | TravelActivityWhereInput[]
    OR?: TravelActivityWhereInput[]
    NOT?: TravelActivityWhereInput | TravelActivityWhereInput[]
    id?: StringFilter<"TravelActivity"> | string
    name?: StringFilter<"TravelActivity"> | string
    category?: StringFilter<"TravelActivity"> | string
    difficulty?: StringFilter<"TravelActivity"> | string
    isActive?: BoolFilter<"TravelActivity"> | boolean
    displayOrder?: IntNullableFilter<"TravelActivity"> | number | null
  }

  export type TravelActivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
  }

  export type TravelActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TravelActivityWhereInput | TravelActivityWhereInput[]
    OR?: TravelActivityWhereInput[]
    NOT?: TravelActivityWhereInput | TravelActivityWhereInput[]
    name?: StringFilter<"TravelActivity"> | string
    category?: StringFilter<"TravelActivity"> | string
    difficulty?: StringFilter<"TravelActivity"> | string
    isActive?: BoolFilter<"TravelActivity"> | boolean
    displayOrder?: IntNullableFilter<"TravelActivity"> | number | null
  }, "id">

  export type TravelActivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    _count?: TravelActivityCountOrderByAggregateInput
    _avg?: TravelActivityAvgOrderByAggregateInput
    _max?: TravelActivityMaxOrderByAggregateInput
    _min?: TravelActivityMinOrderByAggregateInput
    _sum?: TravelActivitySumOrderByAggregateInput
  }

  export type TravelActivityScalarWhereWithAggregatesInput = {
    AND?: TravelActivityScalarWhereWithAggregatesInput | TravelActivityScalarWhereWithAggregatesInput[]
    OR?: TravelActivityScalarWhereWithAggregatesInput[]
    NOT?: TravelActivityScalarWhereWithAggregatesInput | TravelActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TravelActivity"> | string
    name?: StringWithAggregatesFilter<"TravelActivity"> | string
    category?: StringWithAggregatesFilter<"TravelActivity"> | string
    difficulty?: StringWithAggregatesFilter<"TravelActivity"> | string
    isActive?: BoolWithAggregatesFilter<"TravelActivity"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"TravelActivity"> | number | null
  }

  export type TravelInterestWhereInput = {
    AND?: TravelInterestWhereInput | TravelInterestWhereInput[]
    OR?: TravelInterestWhereInput[]
    NOT?: TravelInterestWhereInput | TravelInterestWhereInput[]
    id?: StringFilter<"TravelInterest"> | string
    name?: StringFilter<"TravelInterest"> | string
    description?: StringFilter<"TravelInterest"> | string
    isActive?: BoolFilter<"TravelInterest"> | boolean
    displayOrder?: IntNullableFilter<"TravelInterest"> | number | null
    userInterests?: UserInterestListRelationFilter
    customTourInterests?: CustomTourInterestListRelationFilter
  }

  export type TravelInterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    userInterests?: UserInterestOrderByRelationAggregateInput
    customTourInterests?: CustomTourInterestOrderByRelationAggregateInput
  }

  export type TravelInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TravelInterestWhereInput | TravelInterestWhereInput[]
    OR?: TravelInterestWhereInput[]
    NOT?: TravelInterestWhereInput | TravelInterestWhereInput[]
    name?: StringFilter<"TravelInterest"> | string
    description?: StringFilter<"TravelInterest"> | string
    isActive?: BoolFilter<"TravelInterest"> | boolean
    displayOrder?: IntNullableFilter<"TravelInterest"> | number | null
    userInterests?: UserInterestListRelationFilter
    customTourInterests?: CustomTourInterestListRelationFilter
  }, "id">

  export type TravelInterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    _count?: TravelInterestCountOrderByAggregateInput
    _avg?: TravelInterestAvgOrderByAggregateInput
    _max?: TravelInterestMaxOrderByAggregateInput
    _min?: TravelInterestMinOrderByAggregateInput
    _sum?: TravelInterestSumOrderByAggregateInput
  }

  export type TravelInterestScalarWhereWithAggregatesInput = {
    AND?: TravelInterestScalarWhereWithAggregatesInput | TravelInterestScalarWhereWithAggregatesInput[]
    OR?: TravelInterestScalarWhereWithAggregatesInput[]
    NOT?: TravelInterestScalarWhereWithAggregatesInput | TravelInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TravelInterest"> | string
    name?: StringWithAggregatesFilter<"TravelInterest"> | string
    description?: StringWithAggregatesFilter<"TravelInterest"> | string
    isActive?: BoolWithAggregatesFilter<"TravelInterest"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"TravelInterest"> | number | null
  }

  export type FlightRouteWhereInput = {
    AND?: FlightRouteWhereInput | FlightRouteWhereInput[]
    OR?: FlightRouteWhereInput[]
    NOT?: FlightRouteWhereInput | FlightRouteWhereInput[]
    id?: StringFilter<"FlightRoute"> | string
    origin?: StringFilter<"FlightRoute"> | string
    destination?: StringFilter<"FlightRoute"> | string
    airline?: StringFilter<"FlightRoute"> | string
    duration?: StringFilter<"FlightRoute"> | string
    frequency?: StringFilter<"FlightRoute"> | string
    price?: IntFilter<"FlightRoute"> | number
    isActive?: BoolFilter<"FlightRoute"> | boolean
    flightBookings?: FlightBookingListRelationFilter
  }

  export type FlightRouteOrderByWithRelationInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    airline?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    flightBookings?: FlightBookingOrderByRelationAggregateInput
  }

  export type FlightRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlightRouteWhereInput | FlightRouteWhereInput[]
    OR?: FlightRouteWhereInput[]
    NOT?: FlightRouteWhereInput | FlightRouteWhereInput[]
    origin?: StringFilter<"FlightRoute"> | string
    destination?: StringFilter<"FlightRoute"> | string
    airline?: StringFilter<"FlightRoute"> | string
    duration?: StringFilter<"FlightRoute"> | string
    frequency?: StringFilter<"FlightRoute"> | string
    price?: IntFilter<"FlightRoute"> | number
    isActive?: BoolFilter<"FlightRoute"> | boolean
    flightBookings?: FlightBookingListRelationFilter
  }, "id">

  export type FlightRouteOrderByWithAggregationInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    airline?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    _count?: FlightRouteCountOrderByAggregateInput
    _avg?: FlightRouteAvgOrderByAggregateInput
    _max?: FlightRouteMaxOrderByAggregateInput
    _min?: FlightRouteMinOrderByAggregateInput
    _sum?: FlightRouteSumOrderByAggregateInput
  }

  export type FlightRouteScalarWhereWithAggregatesInput = {
    AND?: FlightRouteScalarWhereWithAggregatesInput | FlightRouteScalarWhereWithAggregatesInput[]
    OR?: FlightRouteScalarWhereWithAggregatesInput[]
    NOT?: FlightRouteScalarWhereWithAggregatesInput | FlightRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlightRoute"> | string
    origin?: StringWithAggregatesFilter<"FlightRoute"> | string
    destination?: StringWithAggregatesFilter<"FlightRoute"> | string
    airline?: StringWithAggregatesFilter<"FlightRoute"> | string
    duration?: StringWithAggregatesFilter<"FlightRoute"> | string
    frequency?: StringWithAggregatesFilter<"FlightRoute"> | string
    price?: IntWithAggregatesFilter<"FlightRoute"> | number
    isActive?: BoolWithAggregatesFilter<"FlightRoute"> | boolean
  }

  export type AccommodationTypeWhereInput = {
    AND?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    OR?: AccommodationTypeWhereInput[]
    NOT?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    id?: StringFilter<"AccommodationType"> | string
    name?: StringFilter<"AccommodationType"> | string
    icon?: StringFilter<"AccommodationType"> | string
    isActive?: BoolFilter<"AccommodationType"> | boolean
  }

  export type AccommodationTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
  }

  export type AccommodationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    OR?: AccommodationTypeWhereInput[]
    NOT?: AccommodationTypeWhereInput | AccommodationTypeWhereInput[]
    name?: StringFilter<"AccommodationType"> | string
    icon?: StringFilter<"AccommodationType"> | string
    isActive?: BoolFilter<"AccommodationType"> | boolean
  }, "id">

  export type AccommodationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    _count?: AccommodationTypeCountOrderByAggregateInput
    _max?: AccommodationTypeMaxOrderByAggregateInput
    _min?: AccommodationTypeMinOrderByAggregateInput
  }

  export type AccommodationTypeScalarWhereWithAggregatesInput = {
    AND?: AccommodationTypeScalarWhereWithAggregatesInput | AccommodationTypeScalarWhereWithAggregatesInput[]
    OR?: AccommodationTypeScalarWhereWithAggregatesInput[]
    NOT?: AccommodationTypeScalarWhereWithAggregatesInput | AccommodationTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccommodationType"> | string
    name?: StringWithAggregatesFilter<"AccommodationType"> | string
    icon?: StringWithAggregatesFilter<"AccommodationType"> | string
    isActive?: BoolWithAggregatesFilter<"AccommodationType"> | boolean
  }

  export type DifficultyLevelWhereInput = {
    AND?: DifficultyLevelWhereInput | DifficultyLevelWhereInput[]
    OR?: DifficultyLevelWhereInput[]
    NOT?: DifficultyLevelWhereInput | DifficultyLevelWhereInput[]
    id?: StringFilter<"DifficultyLevel"> | string
    name?: StringFilter<"DifficultyLevel"> | string
    description?: StringFilter<"DifficultyLevel"> | string
    isActive?: BoolFilter<"DifficultyLevel"> | boolean
  }

  export type DifficultyLevelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DifficultyLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DifficultyLevelWhereInput | DifficultyLevelWhereInput[]
    OR?: DifficultyLevelWhereInput[]
    NOT?: DifficultyLevelWhereInput | DifficultyLevelWhereInput[]
    name?: StringFilter<"DifficultyLevel"> | string
    description?: StringFilter<"DifficultyLevel"> | string
    isActive?: BoolFilter<"DifficultyLevel"> | boolean
  }, "id">

  export type DifficultyLevelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    _count?: DifficultyLevelCountOrderByAggregateInput
    _max?: DifficultyLevelMaxOrderByAggregateInput
    _min?: DifficultyLevelMinOrderByAggregateInput
  }

  export type DifficultyLevelScalarWhereWithAggregatesInput = {
    AND?: DifficultyLevelScalarWhereWithAggregatesInput | DifficultyLevelScalarWhereWithAggregatesInput[]
    OR?: DifficultyLevelScalarWhereWithAggregatesInput[]
    NOT?: DifficultyLevelScalarWhereWithAggregatesInput | DifficultyLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DifficultyLevel"> | string
    name?: StringWithAggregatesFilter<"DifficultyLevel"> | string
    description?: StringWithAggregatesFilter<"DifficultyLevel"> | string
    isActive?: BoolWithAggregatesFilter<"DifficultyLevel"> | boolean
  }

  export type SeasonalPeriodWhereInput = {
    AND?: SeasonalPeriodWhereInput | SeasonalPeriodWhereInput[]
    OR?: SeasonalPeriodWhereInput[]
    NOT?: SeasonalPeriodWhereInput | SeasonalPeriodWhereInput[]
    id?: StringFilter<"SeasonalPeriod"> | string
    name?: StringFilter<"SeasonalPeriod"> | string
    weather?: StringFilter<"SeasonalPeriod"> | string
    isActive?: BoolFilter<"SeasonalPeriod"> | boolean
  }

  export type SeasonalPeriodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: SortOrder
    isActive?: SortOrder
  }

  export type SeasonalPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeasonalPeriodWhereInput | SeasonalPeriodWhereInput[]
    OR?: SeasonalPeriodWhereInput[]
    NOT?: SeasonalPeriodWhereInput | SeasonalPeriodWhereInput[]
    name?: StringFilter<"SeasonalPeriod"> | string
    weather?: StringFilter<"SeasonalPeriod"> | string
    isActive?: BoolFilter<"SeasonalPeriod"> | boolean
  }, "id">

  export type SeasonalPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: SortOrder
    isActive?: SortOrder
    _count?: SeasonalPeriodCountOrderByAggregateInput
    _max?: SeasonalPeriodMaxOrderByAggregateInput
    _min?: SeasonalPeriodMinOrderByAggregateInput
  }

  export type SeasonalPeriodScalarWhereWithAggregatesInput = {
    AND?: SeasonalPeriodScalarWhereWithAggregatesInput | SeasonalPeriodScalarWhereWithAggregatesInput[]
    OR?: SeasonalPeriodScalarWhereWithAggregatesInput[]
    NOT?: SeasonalPeriodScalarWhereWithAggregatesInput | SeasonalPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeasonalPeriod"> | string
    name?: StringWithAggregatesFilter<"SeasonalPeriod"> | string
    weather?: StringWithAggregatesFilter<"SeasonalPeriod"> | string
    isActive?: BoolWithAggregatesFilter<"SeasonalPeriod"> | boolean
  }

  export type BookingActivityWhereInput = {
    AND?: BookingActivityWhereInput | BookingActivityWhereInput[]
    OR?: BookingActivityWhereInput[]
    NOT?: BookingActivityWhereInput | BookingActivityWhereInput[]
    bookingId?: IntFilter<"BookingActivity"> | number
    activityId?: IntFilter<"BookingActivity"> | number
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
  }

  export type BookingActivityOrderByWithRelationInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
    booking?: BookingOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type BookingActivityWhereUniqueInput = Prisma.AtLeast<{
    bookingId_activityId?: BookingActivityBookingIdActivityIdCompoundUniqueInput
    AND?: BookingActivityWhereInput | BookingActivityWhereInput[]
    OR?: BookingActivityWhereInput[]
    NOT?: BookingActivityWhereInput | BookingActivityWhereInput[]
    bookingId?: IntFilter<"BookingActivity"> | number
    activityId?: IntFilter<"BookingActivity"> | number
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
  }, "bookingId_activityId">

  export type BookingActivityOrderByWithAggregationInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
    _count?: BookingActivityCountOrderByAggregateInput
    _avg?: BookingActivityAvgOrderByAggregateInput
    _max?: BookingActivityMaxOrderByAggregateInput
    _min?: BookingActivityMinOrderByAggregateInput
    _sum?: BookingActivitySumOrderByAggregateInput
  }

  export type BookingActivityScalarWhereWithAggregatesInput = {
    AND?: BookingActivityScalarWhereWithAggregatesInput | BookingActivityScalarWhereWithAggregatesInput[]
    OR?: BookingActivityScalarWhereWithAggregatesInput[]
    NOT?: BookingActivityScalarWhereWithAggregatesInput | BookingActivityScalarWhereWithAggregatesInput[]
    bookingId?: IntWithAggregatesFilter<"BookingActivity"> | number
    activityId?: IntWithAggregatesFilter<"BookingActivity"> | number
  }

  export type UserInterestWhereInput = {
    AND?: UserInterestWhereInput | UserInterestWhereInput[]
    OR?: UserInterestWhereInput[]
    NOT?: UserInterestWhereInput | UserInterestWhereInput[]
    userId?: IntFilter<"UserInterest"> | number
    interestId?: StringFilter<"UserInterest"> | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    interest?: XOR<TravelInterestRelationFilter, TravelInterestWhereInput>
  }

  export type UserInterestOrderByWithRelationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    user?: UserAccountOrderByWithRelationInput
    interest?: TravelInterestOrderByWithRelationInput
  }

  export type UserInterestWhereUniqueInput = Prisma.AtLeast<{
    userId_interestId?: UserInterestUserIdInterestIdCompoundUniqueInput
    AND?: UserInterestWhereInput | UserInterestWhereInput[]
    OR?: UserInterestWhereInput[]
    NOT?: UserInterestWhereInput | UserInterestWhereInput[]
    userId?: IntFilter<"UserInterest"> | number
    interestId?: StringFilter<"UserInterest"> | string
    user?: XOR<UserAccountRelationFilter, UserAccountWhereInput>
    interest?: XOR<TravelInterestRelationFilter, TravelInterestWhereInput>
  }, "userId_interestId">

  export type UserInterestOrderByWithAggregationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    _count?: UserInterestCountOrderByAggregateInput
    _avg?: UserInterestAvgOrderByAggregateInput
    _max?: UserInterestMaxOrderByAggregateInput
    _min?: UserInterestMinOrderByAggregateInput
    _sum?: UserInterestSumOrderByAggregateInput
  }

  export type UserInterestScalarWhereWithAggregatesInput = {
    AND?: UserInterestScalarWhereWithAggregatesInput | UserInterestScalarWhereWithAggregatesInput[]
    OR?: UserInterestScalarWhereWithAggregatesInput[]
    NOT?: UserInterestScalarWhereWithAggregatesInput | UserInterestScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserInterest"> | number
    interestId?: StringWithAggregatesFilter<"UserInterest"> | string
  }

  export type CustomTourInterestWhereInput = {
    AND?: CustomTourInterestWhereInput | CustomTourInterestWhereInput[]
    OR?: CustomTourInterestWhereInput[]
    NOT?: CustomTourInterestWhereInput | CustomTourInterestWhereInput[]
    customTourRequestId?: IntFilter<"CustomTourInterest"> | number
    interestId?: StringFilter<"CustomTourInterest"> | string
    customTourRequest?: XOR<CustomTourRequestRelationFilter, CustomTourRequestWhereInput>
    interest?: XOR<TravelInterestRelationFilter, TravelInterestWhereInput>
  }

  export type CustomTourInterestOrderByWithRelationInput = {
    customTourRequestId?: SortOrder
    interestId?: SortOrder
    customTourRequest?: CustomTourRequestOrderByWithRelationInput
    interest?: TravelInterestOrderByWithRelationInput
  }

  export type CustomTourInterestWhereUniqueInput = Prisma.AtLeast<{
    customTourRequestId_interestId?: CustomTourInterestCustomTourRequestIdInterestIdCompoundUniqueInput
    AND?: CustomTourInterestWhereInput | CustomTourInterestWhereInput[]
    OR?: CustomTourInterestWhereInput[]
    NOT?: CustomTourInterestWhereInput | CustomTourInterestWhereInput[]
    customTourRequestId?: IntFilter<"CustomTourInterest"> | number
    interestId?: StringFilter<"CustomTourInterest"> | string
    customTourRequest?: XOR<CustomTourRequestRelationFilter, CustomTourRequestWhereInput>
    interest?: XOR<TravelInterestRelationFilter, TravelInterestWhereInput>
  }, "customTourRequestId_interestId">

  export type CustomTourInterestOrderByWithAggregationInput = {
    customTourRequestId?: SortOrder
    interestId?: SortOrder
    _count?: CustomTourInterestCountOrderByAggregateInput
    _avg?: CustomTourInterestAvgOrderByAggregateInput
    _max?: CustomTourInterestMaxOrderByAggregateInput
    _min?: CustomTourInterestMinOrderByAggregateInput
    _sum?: CustomTourInterestSumOrderByAggregateInput
  }

  export type CustomTourInterestScalarWhereWithAggregatesInput = {
    AND?: CustomTourInterestScalarWhereWithAggregatesInput | CustomTourInterestScalarWhereWithAggregatesInput[]
    OR?: CustomTourInterestScalarWhereWithAggregatesInput[]
    NOT?: CustomTourInterestScalarWhereWithAggregatesInput | CustomTourInterestScalarWhereWithAggregatesInput[]
    customTourRequestId?: IntWithAggregatesFilter<"CustomTourInterest"> | number
    interestId?: StringWithAggregatesFilter<"CustomTourInterest"> | string
  }

  export type FlightBookingWhereInput = {
    AND?: FlightBookingWhereInput | FlightBookingWhereInput[]
    OR?: FlightBookingWhereInput[]
    NOT?: FlightBookingWhereInput | FlightBookingWhereInput[]
    id?: IntFilter<"FlightBooking"> | number
    flightRouteId?: StringFilter<"FlightBooking"> | string
    firstName?: StringFilter<"FlightBooking"> | string
    lastName?: StringFilter<"FlightBooking"> | string
    email?: StringFilter<"FlightBooking"> | string
    phone?: StringNullableFilter<"FlightBooking"> | string | null
    departureDate?: DateTimeFilter<"FlightBooking"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightBooking"> | Date | string | null
    numberOfPassengers?: IntFilter<"FlightBooking"> | number
    totalAmount?: IntFilter<"FlightBooking"> | number
    specialRequests?: StringNullableFilter<"FlightBooking"> | string | null
    status?: StringFilter<"FlightBooking"> | string
    paymentStatus?: StringFilter<"FlightBooking"> | string
    createdAt?: DateTimeFilter<"FlightBooking"> | Date | string
    flightRoute?: XOR<FlightRouteRelationFilter, FlightRouteWhereInput>
  }

  export type FlightBookingOrderByWithRelationInput = {
    id?: SortOrder
    flightRouteId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    flightRoute?: FlightRouteOrderByWithRelationInput
  }

  export type FlightBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlightBookingWhereInput | FlightBookingWhereInput[]
    OR?: FlightBookingWhereInput[]
    NOT?: FlightBookingWhereInput | FlightBookingWhereInput[]
    flightRouteId?: StringFilter<"FlightBooking"> | string
    firstName?: StringFilter<"FlightBooking"> | string
    lastName?: StringFilter<"FlightBooking"> | string
    email?: StringFilter<"FlightBooking"> | string
    phone?: StringNullableFilter<"FlightBooking"> | string | null
    departureDate?: DateTimeFilter<"FlightBooking"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightBooking"> | Date | string | null
    numberOfPassengers?: IntFilter<"FlightBooking"> | number
    totalAmount?: IntFilter<"FlightBooking"> | number
    specialRequests?: StringNullableFilter<"FlightBooking"> | string | null
    status?: StringFilter<"FlightBooking"> | string
    paymentStatus?: StringFilter<"FlightBooking"> | string
    createdAt?: DateTimeFilter<"FlightBooking"> | Date | string
    flightRoute?: XOR<FlightRouteRelationFilter, FlightRouteWhereInput>
  }, "id">

  export type FlightBookingOrderByWithAggregationInput = {
    id?: SortOrder
    flightRouteId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    _count?: FlightBookingCountOrderByAggregateInput
    _avg?: FlightBookingAvgOrderByAggregateInput
    _max?: FlightBookingMaxOrderByAggregateInput
    _min?: FlightBookingMinOrderByAggregateInput
    _sum?: FlightBookingSumOrderByAggregateInput
  }

  export type FlightBookingScalarWhereWithAggregatesInput = {
    AND?: FlightBookingScalarWhereWithAggregatesInput | FlightBookingScalarWhereWithAggregatesInput[]
    OR?: FlightBookingScalarWhereWithAggregatesInput[]
    NOT?: FlightBookingScalarWhereWithAggregatesInput | FlightBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FlightBooking"> | number
    flightRouteId?: StringWithAggregatesFilter<"FlightBooking"> | string
    firstName?: StringWithAggregatesFilter<"FlightBooking"> | string
    lastName?: StringWithAggregatesFilter<"FlightBooking"> | string
    email?: StringWithAggregatesFilter<"FlightBooking"> | string
    phone?: StringNullableWithAggregatesFilter<"FlightBooking"> | string | null
    departureDate?: DateTimeWithAggregatesFilter<"FlightBooking"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"FlightBooking"> | Date | string | null
    numberOfPassengers?: IntWithAggregatesFilter<"FlightBooking"> | number
    totalAmount?: IntWithAggregatesFilter<"FlightBooking"> | number
    specialRequests?: StringNullableWithAggregatesFilter<"FlightBooking"> | string | null
    status?: StringWithAggregatesFilter<"FlightBooking"> | string
    paymentStatus?: StringWithAggregatesFilter<"FlightBooking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FlightBooking"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: IntFilter<"Activity"> | number
    name?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    duration?: StringNullableFilter<"Activity"> | string | null
    difficulty?: StringNullableFilter<"Activity"> | string | null
    price?: FloatFilter<"Activity"> | number
    description?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    isActive?: BoolFilter<"Activity"> | boolean
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    tourActivities?: TourActivityJunctionListRelationFilter
    bookingActivities?: BookingActivityListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourActivities?: TourActivityJunctionOrderByRelationAggregateInput
    bookingActivities?: BookingActivityOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    name?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    duration?: StringNullableFilter<"Activity"> | string | null
    difficulty?: StringNullableFilter<"Activity"> | string | null
    price?: FloatFilter<"Activity"> | number
    description?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    isActive?: BoolFilter<"Activity"> | boolean
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    tourActivities?: TourActivityJunctionListRelationFilter
    bookingActivities?: BookingActivityListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    duration?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Activity"> | number
    name?: StringWithAggregatesFilter<"Activity"> | string
    category?: StringWithAggregatesFilter<"Activity"> | string
    duration?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    price?: FloatWithAggregatesFilter<"Activity"> | number
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    location?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    isActive?: BoolWithAggregatesFilter<"Activity"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type TourActivityJunctionWhereInput = {
    AND?: TourActivityJunctionWhereInput | TourActivityJunctionWhereInput[]
    OR?: TourActivityJunctionWhereInput[]
    NOT?: TourActivityJunctionWhereInput | TourActivityJunctionWhereInput[]
    tourId?: IntFilter<"TourActivityJunction"> | number
    activityId?: IntFilter<"TourActivityJunction"> | number
    included?: BoolFilter<"TourActivityJunction"> | boolean
    optional?: BoolFilter<"TourActivityJunction"> | boolean
    tour?: XOR<TourRelationFilter, TourWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
  }

  export type TourActivityJunctionOrderByWithRelationInput = {
    tourId?: SortOrder
    activityId?: SortOrder
    included?: SortOrder
    optional?: SortOrder
    tour?: TourOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type TourActivityJunctionWhereUniqueInput = Prisma.AtLeast<{
    tourId_activityId?: TourActivityJunctionTourIdActivityIdCompoundUniqueInput
    AND?: TourActivityJunctionWhereInput | TourActivityJunctionWhereInput[]
    OR?: TourActivityJunctionWhereInput[]
    NOT?: TourActivityJunctionWhereInput | TourActivityJunctionWhereInput[]
    tourId?: IntFilter<"TourActivityJunction"> | number
    activityId?: IntFilter<"TourActivityJunction"> | number
    included?: BoolFilter<"TourActivityJunction"> | boolean
    optional?: BoolFilter<"TourActivityJunction"> | boolean
    tour?: XOR<TourRelationFilter, TourWhereInput>
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
  }, "tourId_activityId">

  export type TourActivityJunctionOrderByWithAggregationInput = {
    tourId?: SortOrder
    activityId?: SortOrder
    included?: SortOrder
    optional?: SortOrder
    _count?: TourActivityJunctionCountOrderByAggregateInput
    _avg?: TourActivityJunctionAvgOrderByAggregateInput
    _max?: TourActivityJunctionMaxOrderByAggregateInput
    _min?: TourActivityJunctionMinOrderByAggregateInput
    _sum?: TourActivityJunctionSumOrderByAggregateInput
  }

  export type TourActivityJunctionScalarWhereWithAggregatesInput = {
    AND?: TourActivityJunctionScalarWhereWithAggregatesInput | TourActivityJunctionScalarWhereWithAggregatesInput[]
    OR?: TourActivityJunctionScalarWhereWithAggregatesInput[]
    NOT?: TourActivityJunctionScalarWhereWithAggregatesInput | TourActivityJunctionScalarWhereWithAggregatesInput[]
    tourId?: IntWithAggregatesFilter<"TourActivityJunction"> | number
    activityId?: IntWithAggregatesFilter<"TourActivityJunction"> | number
    included?: BoolWithAggregatesFilter<"TourActivityJunction"> | boolean
    optional?: BoolWithAggregatesFilter<"TourActivityJunction"> | boolean
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: IntFilter<"Interest"> | number
    name?: StringFilter<"Interest"> | string
    description?: StringNullableFilter<"Interest"> | string | null
    category?: StringFilter<"Interest"> | string
    experiences?: StringNullableListFilter<"Interest">
    isActive?: BoolFilter<"Interest"> | boolean
    createdAt?: DateTimeFilter<"Interest"> | Date | string
    updatedAt?: DateTimeFilter<"Interest"> | Date | string
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    experiences?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    name?: StringFilter<"Interest"> | string
    description?: StringNullableFilter<"Interest"> | string | null
    category?: StringFilter<"Interest"> | string
    experiences?: StringNullableListFilter<"Interest">
    isActive?: BoolFilter<"Interest"> | boolean
    createdAt?: DateTimeFilter<"Interest"> | Date | string
    updatedAt?: DateTimeFilter<"Interest"> | Date | string
  }, "id">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    experiences?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _avg?: InterestAvgOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
    _sum?: InterestSumOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Interest"> | number
    name?: StringWithAggregatesFilter<"Interest"> | string
    description?: StringNullableWithAggregatesFilter<"Interest"> | string | null
    category?: StringWithAggregatesFilter<"Interest"> | string
    experiences?: StringNullableListFilter<"Interest">
    isActive?: BoolWithAggregatesFilter<"Interest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Interest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interest"> | Date | string
  }

  export type FlightWhereInput = {
    AND?: FlightWhereInput | FlightWhereInput[]
    OR?: FlightWhereInput[]
    NOT?: FlightWhereInput | FlightWhereInput[]
    id?: IntFilter<"Flight"> | number
    airline?: StringFilter<"Flight"> | string
    route?: StringFilter<"Flight"> | string
    duration?: StringFilter<"Flight"> | string
    frequency?: StringFilter<"Flight"> | string
    price?: FloatFilter<"Flight"> | number
    aircraft?: StringNullableFilter<"Flight"> | string | null
    features?: StringNullableListFilter<"Flight">
    isActive?: BoolFilter<"Flight"> | boolean
    createdAt?: DateTimeFilter<"Flight"> | Date | string
    updatedAt?: DateTimeFilter<"Flight"> | Date | string
  }

  export type FlightOrderByWithRelationInput = {
    id?: SortOrder
    airline?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    aircraft?: SortOrderInput | SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FlightWhereInput | FlightWhereInput[]
    OR?: FlightWhereInput[]
    NOT?: FlightWhereInput | FlightWhereInput[]
    airline?: StringFilter<"Flight"> | string
    route?: StringFilter<"Flight"> | string
    duration?: StringFilter<"Flight"> | string
    frequency?: StringFilter<"Flight"> | string
    price?: FloatFilter<"Flight"> | number
    aircraft?: StringNullableFilter<"Flight"> | string | null
    features?: StringNullableListFilter<"Flight">
    isActive?: BoolFilter<"Flight"> | boolean
    createdAt?: DateTimeFilter<"Flight"> | Date | string
    updatedAt?: DateTimeFilter<"Flight"> | Date | string
  }, "id">

  export type FlightOrderByWithAggregationInput = {
    id?: SortOrder
    airline?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    aircraft?: SortOrderInput | SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlightCountOrderByAggregateInput
    _avg?: FlightAvgOrderByAggregateInput
    _max?: FlightMaxOrderByAggregateInput
    _min?: FlightMinOrderByAggregateInput
    _sum?: FlightSumOrderByAggregateInput
  }

  export type FlightScalarWhereWithAggregatesInput = {
    AND?: FlightScalarWhereWithAggregatesInput | FlightScalarWhereWithAggregatesInput[]
    OR?: FlightScalarWhereWithAggregatesInput[]
    NOT?: FlightScalarWhereWithAggregatesInput | FlightScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Flight"> | number
    airline?: StringWithAggregatesFilter<"Flight"> | string
    route?: StringWithAggregatesFilter<"Flight"> | string
    duration?: StringWithAggregatesFilter<"Flight"> | string
    frequency?: StringWithAggregatesFilter<"Flight"> | string
    price?: FloatWithAggregatesFilter<"Flight"> | number
    aircraft?: StringNullableWithAggregatesFilter<"Flight"> | string | null
    features?: StringNullableListFilter<"Flight">
    isActive?: BoolWithAggregatesFilter<"Flight"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flight"> | Date | string
  }

  export type TourFestivalWhereInput = {
    AND?: TourFestivalWhereInput | TourFestivalWhereInput[]
    OR?: TourFestivalWhereInput[]
    NOT?: TourFestivalWhereInput | TourFestivalWhereInput[]
    id?: IntFilter<"TourFestival"> | number
    tourId?: IntFilter<"TourFestival"> | number
    festivalId?: IntFilter<"TourFestival"> | number
    tour?: XOR<TourRelationFilter, TourWhereInput>
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }

  export type TourFestivalOrderByWithRelationInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
    tour?: TourOrderByWithRelationInput
    festival?: FestivalOrderByWithRelationInput
  }

  export type TourFestivalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tourId_festivalId?: TourFestivalTourIdFestivalIdCompoundUniqueInput
    AND?: TourFestivalWhereInput | TourFestivalWhereInput[]
    OR?: TourFestivalWhereInput[]
    NOT?: TourFestivalWhereInput | TourFestivalWhereInput[]
    tourId?: IntFilter<"TourFestival"> | number
    festivalId?: IntFilter<"TourFestival"> | number
    tour?: XOR<TourRelationFilter, TourWhereInput>
    festival?: XOR<FestivalRelationFilter, FestivalWhereInput>
  }, "id" | "tourId_festivalId">

  export type TourFestivalOrderByWithAggregationInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
    _count?: TourFestivalCountOrderByAggregateInput
    _avg?: TourFestivalAvgOrderByAggregateInput
    _max?: TourFestivalMaxOrderByAggregateInput
    _min?: TourFestivalMinOrderByAggregateInput
    _sum?: TourFestivalSumOrderByAggregateInput
  }

  export type TourFestivalScalarWhereWithAggregatesInput = {
    AND?: TourFestivalScalarWhereWithAggregatesInput | TourFestivalScalarWhereWithAggregatesInput[]
    OR?: TourFestivalScalarWhereWithAggregatesInput[]
    NOT?: TourFestivalScalarWhereWithAggregatesInput | TourFestivalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TourFestival"> | number
    tourId?: IntWithAggregatesFilter<"TourFestival"> | number
    festivalId?: IntWithAggregatesFilter<"TourFestival"> | number
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: IntFilter<"ChatSession"> | number
    sessionId?: StringFilter<"ChatSession"> | string
    userId?: IntNullableFilter<"ChatSession"> | number | null
    userEmail?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    messages?: ChatMessageListRelationFilter
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: string
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    userId?: IntNullableFilter<"ChatSession"> | number | null
    userEmail?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    messages?: ChatMessageListRelationFilter
  }, "id" | "sessionId">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _avg?: ChatSessionAvgOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
    _sum?: ChatSessionSumOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatSession"> | number
    sessionId?: StringWithAggregatesFilter<"ChatSession"> | string
    userId?: IntNullableWithAggregatesFilter<"ChatSession"> | number | null
    userEmail?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChatSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    sessionId?: StringFilter<"ChatMessage"> | string
    sender?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    messageType?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionRelationFilter, ChatSessionWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: ChatSessionOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    sessionId?: StringFilter<"ChatMessage"> | string
    sender?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    messageType?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionRelationFilter, ChatSessionWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    sessionId?: StringWithAggregatesFilter<"ChatMessage"> | string
    sender?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    messageType?: StringWithAggregatesFilter<"ChatMessage"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ChatMessage">
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntNullableFilter<"Notification"> | number | null
    userEmail?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    priority?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntNullableFilter<"Notification"> | number | null
    userEmail?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    priority?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    userEmail?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    priority?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntNullableFilter<"Payment"> | number | null
    hotelBookingId?: IntNullableFilter<"Payment"> | number | null
    flightBookingId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentGateway?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    hotelBookingId?: SortOrderInput | SortOrder
    flightBookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: IntNullableFilter<"Payment"> | number | null
    hotelBookingId?: IntNullableFilter<"Payment"> | number | null
    flightBookingId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    paymentMethod?: StringFilter<"Payment"> | string
    paymentGateway?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    hotelBookingId?: SortOrderInput | SortOrder
    flightBookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bookingId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    hotelBookingId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    flightBookingId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    paymentGateway?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type TourCreateInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
  }

  export type TourUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutBookingsInput
    activities?: BookingActivityCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    activities?: BookingActivityUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutBookingsNestedInput
    activities?: BookingActivityUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: BookingActivityUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    tourInterest?: string | null
    preferredDates?: string | null
    groupSize?: string | null
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tourInterest?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUncheckedCreateInput = {
    id?: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialCreateManyInput = {
    id?: number
    name: string
    country: string
    imageUrl: string
    text: string
    rating: number
    tripName: string
    duration: string
    isActive?: boolean
  }

  export type TestimonialUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    tripName?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostCreateInput = {
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUncheckedCreateInput = {
    id?: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostCreateManyInput = {
    id?: number
    title: string
    excerpt: string
    content: string
    imageUrl: string
    category: string
    author: string
    authorImage: string
    readTime: string
    publishedAt?: Date | string
    isPublished?: boolean
  }

  export type BlogPostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuideCreateInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryCreateNestedManyWithoutGuideInput
    drivenItineraries?: ItineraryCreateNestedManyWithoutDriverInput
  }

  export type GuideUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryUncheckedCreateNestedManyWithoutGuideInput
    drivenItineraries?: ItineraryUncheckedCreateNestedManyWithoutDriverInput
  }

  export type GuideUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUpdateManyWithoutGuideNestedInput
    drivenItineraries?: ItineraryUpdateManyWithoutDriverNestedInput
  }

  export type GuideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUncheckedUpdateManyWithoutGuideNestedInput
    drivenItineraries?: ItineraryUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type GuideCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
  }

  export type GuideUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryCreateInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateManyInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryDayCreateInput = {
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
    itinerary: ItineraryCreateNestedOneWithoutDaysInput
  }

  export type ItineraryDayUncheckedCreateInput = {
    id?: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUpdateInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: ItineraryUpdateOneRequiredWithoutDaysNestedInput
  }

  export type ItineraryDayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayCreateManyInput = {
    id?: number
    itineraryId: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUpdateManyMutationInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomTourRequestCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
    assignedItinerary?: ItineraryCreateNestedOneWithoutAssignedCustomTourRequestsInput
    interests?: CustomTourInterestCreateNestedManyWithoutCustomTourRequestInput
  }

  export type CustomTourRequestUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    assignedItineraryId?: number | null
    createdAt?: Date | string
    interests?: CustomTourInterestUncheckedCreateNestedManyWithoutCustomTourRequestInput
  }

  export type CustomTourRequestUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedItinerary?: ItineraryUpdateOneWithoutAssignedCustomTourRequestsNestedInput
    interests?: CustomTourInterestUpdateManyWithoutCustomTourRequestNestedInput
  }

  export type CustomTourRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    assignedItineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: CustomTourInterestUncheckedUpdateManyWithoutCustomTourRequestNestedInput
  }

  export type CustomTourRequestCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    assignedItineraryId?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    assignedItineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorCreateInput = {
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
    tours?: TourCreateNestedManyWithoutTourOperatorInput
  }

  export type TourOperatorUncheckedCreateInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
    tours?: TourUncheckedCreateNestedManyWithoutTourOperatorInput
  }

  export type TourOperatorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUpdateManyWithoutTourOperatorNestedInput
  }

  export type TourOperatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUncheckedUpdateManyWithoutTourOperatorNestedInput
  }

  export type TourOperatorCreateManyInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalCreateInput = {
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourFestivals?: TourFestivalCreateNestedManyWithoutFestivalInput
    festivalBookings?: FestivalBookingCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutFestivalInput
    festivalBookings?: FestivalBookingUncheckedCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourFestivals?: TourFestivalUpdateManyWithoutFestivalNestedInput
    festivalBookings?: FestivalBookingUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutFestivalNestedInput
    festivalBookings?: FestivalBookingUncheckedUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FestivalUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    festival: FestivalCreateNestedOneWithoutFestivalBookingsInput
  }

  export type FestivalBookingUncheckedCreateInput = {
    id?: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    festival?: FestivalUpdateOneRequiredWithoutFestivalBookingsNestedInput
  }

  export type FestivalBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingCreateManyInput = {
    id?: number
    festivalId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelCreateInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    category: HotelCategoryCreateNestedOneWithoutHotelsInput
    rooms?: HotelRoomCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    categoryId: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HotelCategoryUpdateOneRequiredWithoutHotelsNestedInput
    rooms?: HotelRoomUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    categoryId: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
  }

  export type HotelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRoomCreateInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    hotel: HotelCreateNestedOneWithoutRoomsInput
    bookings?: HotelBookingCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUncheckedCreateInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUpdateInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
    bookings?: HotelBookingUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomCreateManyInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelRoomUpdateManyMutationInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelRoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelBookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    hotel: HotelCreateNestedOneWithoutBookingsInput
    room: HotelRoomCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateInput = {
    id?: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    room?: HotelRoomUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingCreateManyInput = {
    id?: number
    hotelId: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackCreateNestedManyWithoutUserInput
    interests?: UserInterestCreateNestedManyWithoutUserInput
  }

  export type UserAccountUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackUncheckedCreateNestedManyWithoutUserInput
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAccountUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUpdateManyWithoutUserNestedInput
    interests?: UserInterestUpdateManyWithoutUserNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUncheckedUpdateManyWithoutUserNestedInput
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAccountCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserAccountUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFeedbackCreateInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateManyInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCategoryCreateInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TourCategoryUncheckedCreateInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TourCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TourCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TourCategoryCreateManyInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TourCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TourCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelCategoryCreateInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    hotels?: HotelCreateNestedManyWithoutCategoryInput
  }

  export type HotelCategoryUncheckedCreateInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    hotels?: HotelUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type HotelCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    hotels?: HotelUpdateManyWithoutCategoryNestedInput
  }

  export type HotelCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    hotels?: HotelUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type HotelCategoryCreateManyInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type HotelCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelActivityCreateInput = {
    id: string
    name: string
    category: string
    difficulty: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TravelActivityUncheckedCreateInput = {
    id: string
    name: string
    category: string
    difficulty: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TravelActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelActivityCreateManyInput = {
    id: string
    name: string
    category: string
    difficulty: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TravelActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelInterestCreateInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    userInterests?: UserInterestCreateNestedManyWithoutInterestInput
    customTourInterests?: CustomTourInterestCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestUncheckedCreateInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    userInterests?: UserInterestUncheckedCreateNestedManyWithoutInterestInput
    customTourInterests?: CustomTourInterestUncheckedCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    userInterests?: UserInterestUpdateManyWithoutInterestNestedInput
    customTourInterests?: CustomTourInterestUpdateManyWithoutInterestNestedInput
  }

  export type TravelInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    userInterests?: UserInterestUncheckedUpdateManyWithoutInterestNestedInput
    customTourInterests?: CustomTourInterestUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type TravelInterestCreateManyInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type TravelInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TravelInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FlightRouteCreateInput = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive?: boolean
    flightBookings?: FlightBookingCreateNestedManyWithoutFlightRouteInput
  }

  export type FlightRouteUncheckedCreateInput = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive?: boolean
    flightBookings?: FlightBookingUncheckedCreateNestedManyWithoutFlightRouteInput
  }

  export type FlightRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    flightBookings?: FlightBookingUpdateManyWithoutFlightRouteNestedInput
  }

  export type FlightRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    flightBookings?: FlightBookingUncheckedUpdateManyWithoutFlightRouteNestedInput
  }

  export type FlightRouteCreateManyInput = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive?: boolean
  }

  export type FlightRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlightRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccommodationTypeCreateInput = {
    id: string
    name: string
    icon: string
    isActive?: boolean
  }

  export type AccommodationTypeUncheckedCreateInput = {
    id: string
    name: string
    icon: string
    isActive?: boolean
  }

  export type AccommodationTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccommodationTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccommodationTypeCreateManyInput = {
    id: string
    name: string
    icon: string
    isActive?: boolean
  }

  export type AccommodationTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccommodationTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DifficultyLevelCreateInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
  }

  export type DifficultyLevelUncheckedCreateInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
  }

  export type DifficultyLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DifficultyLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DifficultyLevelCreateManyInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
  }

  export type DifficultyLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DifficultyLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonalPeriodCreateInput = {
    id: string
    name: string
    weather: string
    isActive?: boolean
  }

  export type SeasonalPeriodUncheckedCreateInput = {
    id: string
    name: string
    weather: string
    isActive?: boolean
  }

  export type SeasonalPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonalPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonalPeriodCreateManyInput = {
    id: string
    name: string
    weather: string
    isActive?: boolean
  }

  export type SeasonalPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonalPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weather?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingActivityCreateInput = {
    booking: BookingCreateNestedOneWithoutActivitiesInput
    activity: ActivityCreateNestedOneWithoutBookingActivitiesInput
  }

  export type BookingActivityUncheckedCreateInput = {
    bookingId: number
    activityId: number
  }

  export type BookingActivityUpdateInput = {
    booking?: BookingUpdateOneRequiredWithoutActivitiesNestedInput
    activity?: ActivityUpdateOneRequiredWithoutBookingActivitiesNestedInput
  }

  export type BookingActivityUncheckedUpdateInput = {
    bookingId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingActivityCreateManyInput = {
    bookingId: number
    activityId: number
  }

  export type BookingActivityUpdateManyMutationInput = {

  }

  export type BookingActivityUncheckedUpdateManyInput = {
    bookingId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type UserInterestCreateInput = {
    user: UserAccountCreateNestedOneWithoutInterestsInput
    interest: TravelInterestCreateNestedOneWithoutUserInterestsInput
  }

  export type UserInterestUncheckedCreateInput = {
    userId: number
    interestId: string
  }

  export type UserInterestUpdateInput = {
    user?: UserAccountUpdateOneRequiredWithoutInterestsNestedInput
    interest?: TravelInterestUpdateOneRequiredWithoutUserInterestsNestedInput
  }

  export type UserInterestUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestCreateManyInput = {
    userId: number
    interestId: string
  }

  export type UserInterestUpdateManyMutationInput = {

  }

  export type UserInterestUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomTourInterestCreateInput = {
    customTourRequest: CustomTourRequestCreateNestedOneWithoutInterestsInput
    interest: TravelInterestCreateNestedOneWithoutCustomTourInterestsInput
  }

  export type CustomTourInterestUncheckedCreateInput = {
    customTourRequestId: number
    interestId: string
  }

  export type CustomTourInterestUpdateInput = {
    customTourRequest?: CustomTourRequestUpdateOneRequiredWithoutInterestsNestedInput
    interest?: TravelInterestUpdateOneRequiredWithoutCustomTourInterestsNestedInput
  }

  export type CustomTourInterestUncheckedUpdateInput = {
    customTourRequestId?: IntFieldUpdateOperationsInput | number
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomTourInterestCreateManyInput = {
    customTourRequestId: number
    interestId: string
  }

  export type CustomTourInterestUpdateManyMutationInput = {

  }

  export type CustomTourInterestUncheckedUpdateManyInput = {
    customTourRequestId?: IntFieldUpdateOperationsInput | number
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type FlightBookingCreateInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    flightRoute: FlightRouteCreateNestedOneWithoutFlightBookingsInput
  }

  export type FlightBookingUncheckedCreateInput = {
    id?: number
    flightRouteId: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type FlightBookingUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flightRoute?: FlightRouteUpdateOneRequiredWithoutFlightBookingsNestedInput
  }

  export type FlightBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    flightRouteId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightBookingCreateManyInput = {
    id?: number
    flightRouteId: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type FlightBookingUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    flightRouteId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutActivityInput
    bookingActivities?: BookingActivityCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutActivityInput
    bookingActivities?: BookingActivityUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourActivities?: TourActivityJunctionUpdateManyWithoutActivityNestedInput
    bookingActivities?: BookingActivityUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutActivityNestedInput
    bookingActivities?: BookingActivityUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: number
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourActivityJunctionCreateInput = {
    included?: boolean
    optional?: boolean
    tour: TourCreateNestedOneWithoutTourActivitiesInput
    activity: ActivityCreateNestedOneWithoutTourActivitiesInput
  }

  export type TourActivityJunctionUncheckedCreateInput = {
    tourId: number
    activityId: number
    included?: boolean
    optional?: boolean
  }

  export type TourActivityJunctionUpdateInput = {
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
    tour?: TourUpdateOneRequiredWithoutTourActivitiesNestedInput
    activity?: ActivityUpdateOneRequiredWithoutTourActivitiesNestedInput
  }

  export type TourActivityJunctionUncheckedUpdateInput = {
    tourId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TourActivityJunctionCreateManyInput = {
    tourId: number
    activityId: number
    included?: boolean
    optional?: boolean
  }

  export type TourActivityJunctionUpdateManyMutationInput = {
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TourActivityJunctionUncheckedUpdateManyInput = {
    tourId?: IntFieldUpdateOperationsInput | number
    activityId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InterestCreateInput = {
    name: string
    description?: string | null
    category: string
    experiences?: InterestCreateexperiencesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    experiences?: InterestCreateexperiencesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    experiences?: InterestUpdateexperiencesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    experiences?: InterestUpdateexperiencesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category: string
    experiences?: InterestCreateexperiencesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    experiences?: InterestUpdateexperiencesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    experiences?: InterestUpdateexperiencesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightCreateInput = {
    airline: string
    route: string
    duration: string
    frequency: string
    price: number
    aircraft?: string | null
    features?: FlightCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightUncheckedCreateInput = {
    id?: number
    airline: string
    route: string
    duration: string
    frequency: string
    price: number
    aircraft?: string | null
    features?: FlightCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightUpdateInput = {
    airline?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    aircraft?: NullableStringFieldUpdateOperationsInput | string | null
    features?: FlightUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    airline?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    aircraft?: NullableStringFieldUpdateOperationsInput | string | null
    features?: FlightUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightCreateManyInput = {
    id?: number
    airline: string
    route: string
    duration: string
    frequency: string
    price: number
    aircraft?: string | null
    features?: FlightCreatefeaturesInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightUpdateManyMutationInput = {
    airline?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    aircraft?: NullableStringFieldUpdateOperationsInput | string | null
    features?: FlightUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    airline?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    aircraft?: NullableStringFieldUpdateOperationsInput | string | null
    features?: FlightUpdatefeaturesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourFestivalCreateInput = {
    tour: TourCreateNestedOneWithoutTourFestivalsInput
    festival: FestivalCreateNestedOneWithoutTourFestivalsInput
  }

  export type TourFestivalUncheckedCreateInput = {
    id?: number
    tourId: number
    festivalId: number
  }

  export type TourFestivalUpdateInput = {
    tour?: TourUpdateOneRequiredWithoutTourFestivalsNestedInput
    festival?: FestivalUpdateOneRequiredWithoutTourFestivalsNestedInput
  }

  export type TourFestivalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
  }

  export type TourFestivalCreateManyInput = {
    id?: number
    tourId: number
    festivalId: number
  }

  export type TourFestivalUpdateManyMutationInput = {

  }

  export type TourFestivalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
  }

  export type ChatSessionCreateInput = {
    sessionId: string
    userId?: number | null
    userEmail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id?: number
    sessionId: string
    userId?: number | null
    userEmail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id?: number
    sessionId: string
    userId?: number | null
    userEmail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    session: ChatSessionCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    sessionId: string
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    sessionId: string
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    userId?: number | null
    userEmail?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    userEmail?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId?: number | null
    userEmail?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    bookingId?: number | null
    hotelBookingId?: number | null
    flightBookingId?: number | null
    amount: number
    currency?: string
    paymentMethod: string
    paymentGateway: string
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bookingId?: number | null
    hotelBookingId?: number | null
    flightBookingId?: number | null
    amount: number
    currency?: string
    paymentMethod: string
    paymentGateway: string
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    flightBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    flightBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    bookingId?: number | null
    hotelBookingId?: number | null
    flightBookingId?: number | null
    amount: number
    currency?: string
    paymentMethod: string
    paymentGateway: string
    transactionId?: string | null
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    flightBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    hotelBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    flightBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type TourOperatorNullableRelationFilter = {
    is?: TourOperatorWhereInput | null
    isNot?: TourOperatorWhereInput | null
  }

  export type UserFeedbackListRelationFilter = {
    every?: UserFeedbackWhereInput
    some?: UserFeedbackWhereInput
    none?: UserFeedbackWhereInput
  }

  export type TourFestivalListRelationFilter = {
    every?: TourFestivalWhereInput
    some?: TourFestivalWhereInput
    none?: TourFestivalWhereInput
  }

  export type TourActivityJunctionListRelationFilter = {
    every?: TourActivityJunctionWhereInput
    some?: TourActivityJunctionWhereInput
    none?: TourActivityJunctionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourFestivalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourActivityJunctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrder
    categoryName?: SortOrder
    difficulty?: SortOrder
    groupSize?: SortOrder
    imageUrl?: SortOrder
    highlights?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    itinerary?: SortOrder
    bestTime?: SortOrder
    physicalRating?: SortOrder
    culturalLevel?: SortOrder
    luxuryLevel?: SortOrder
    spiritualLevel?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrder
    rating?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrder
    categoryName?: SortOrder
    difficulty?: SortOrder
    groupSize?: SortOrder
    imageUrl?: SortOrder
    itinerary?: SortOrder
    physicalRating?: SortOrder
    culturalLevel?: SortOrder
    luxuryLevel?: SortOrder
    spiritualLevel?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrder
    categoryName?: SortOrder
    difficulty?: SortOrder
    groupSize?: SortOrder
    imageUrl?: SortOrder
    itinerary?: SortOrder
    physicalRating?: SortOrder
    culturalLevel?: SortOrder
    luxuryLevel?: SortOrder
    spiritualLevel?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type TourSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    maxPrice?: SortOrder
    rating?: SortOrder
    tourOperatorId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TourRelationFilter = {
    is?: TourWhereInput
    isNot?: TourWhereInput
  }

  export type BookingActivityListRelationFilter = {
    every?: BookingActivityWhereInput
    some?: BookingActivityWhereInput
    none?: BookingActivityWhereInput
  }

  export type BookingActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    groupSize?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    travelDate?: SortOrder
    groupSize?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    groupSize?: SortOrder
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    tourInterest?: SortOrder
    preferredDates?: SortOrder
    groupSize?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    imageUrl?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    tripName?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    author?: SortOrder
    authorImage?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    isPublished?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    specializations?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    licenseImageUrl?: SortOrder
    registrationType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GuideSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuideNullableRelationFilter = {
    is?: GuideWhereInput | null
    isNot?: GuideWhereInput | null
  }

  export type ItineraryDayListRelationFilter = {
    every?: ItineraryDayWhereInput
    some?: ItineraryDayWhereInput
    none?: ItineraryDayWhereInput
  }

  export type CustomTourRequestListRelationFilter = {
    every?: CustomTourRequestWhereInput
    some?: CustomTourRequestWhereInput
    none?: CustomTourRequestWhereInput
  }

  export type ItineraryDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomTourRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItineraryAvgOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ItinerarySumOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    guideId?: SortOrder
    driverId?: SortOrder
    maxParticipants?: SortOrder
    currentParticipants?: SortOrder
  }

  export type ItineraryRelationFilter = {
    is?: ItineraryWhereInput
    isNot?: ItineraryWhereInput
  }

  export type ItineraryDayCountOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    activities?: SortOrder
    accommodation?: SortOrder
    meals?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDayAvgOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
  }

  export type ItineraryDayMaxOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    accommodation?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDayMinOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    accommodation?: SortOrder
    transportation?: SortOrder
    notes?: SortOrder
  }

  export type ItineraryDaySumOrderByAggregateInput = {
    id?: SortOrder
    itineraryId?: SortOrder
    dayNumber?: SortOrder
  }

  export type ItineraryNullableRelationFilter = {
    is?: ItineraryWhereInput | null
    isNot?: ItineraryWhereInput | null
  }

  export type CustomTourInterestListRelationFilter = {
    every?: CustomTourInterestWhereInput
    some?: CustomTourInterestWhereInput
    none?: CustomTourInterestWhereInput
  }

  export type CustomTourInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomTourRequestCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    destinations?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
  }

  export type CustomTourRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    preferredDates?: SortOrder
    specialRequirements?: SortOrder
    accommodationType?: SortOrder
    transportPreference?: SortOrder
    status?: SortOrder
    adminNotes?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomTourRequestSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    groupSize?: SortOrder
    budget?: SortOrder
    estimatedPrice?: SortOrder
    assignedItineraryId?: SortOrder
  }

  export type TourListRelationFilter = {
    every?: TourWhereInput
    some?: TourWhereInput
    none?: TourWhereInput
  }

  export type TourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourOperatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    specialties?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    certifications?: SortOrder
    awards?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    establishedYear?: SortOrder
  }

  export type TourOperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    description?: SortOrder
    bestFeature?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    logoUrl?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    establishedYear?: SortOrder
    createdAt?: SortOrder
  }

  export type TourOperatorSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    establishedYear?: SortOrder
  }

  export type FestivalBookingListRelationFilter = {
    every?: FestivalBookingWhereInput
    some?: FestivalBookingWhereInput
    none?: FestivalBookingWhereInput
  }

  export type FestivalBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FestivalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    dates?: SortOrder
    duration?: SortOrder
    significance?: SortOrder
    activities?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FestivalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FestivalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    dates?: SortOrder
    duration?: SortOrder
    significance?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FestivalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    dates?: SortOrder
    duration?: SortOrder
    significance?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FestivalSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FestivalRelationFilter = {
    is?: FestivalWhereInput
    isNot?: FestivalWhereInput
  }

  export type FestivalBookingCountOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
  }

  export type FestivalBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingMinOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FestivalBookingSumOrderByAggregateInput = {
    id?: SortOrder
    festivalId?: SortOrder
    numberOfTickets?: SortOrder
    totalAmount?: SortOrder
  }

  export type HotelCategoryRelationFilter = {
    is?: HotelCategoryWhereInput
    isNot?: HotelCategoryWhereInput
  }

  export type HotelRoomListRelationFilter = {
    every?: HotelRoomWhereInput
    some?: HotelRoomWhereInput
    none?: HotelRoomWhereInput
  }

  export type HotelBookingListRelationFilter = {
    every?: HotelBookingWhereInput
    some?: HotelBookingWhereInput
    none?: HotelBookingWhereInput
  }

  export type HotelRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    categoryId?: SortOrder
    starRating?: SortOrder
    amenities?: SortOrder
    features?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    id?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    categoryId?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    categoryId?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
    isActive?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    id?: SortOrder
    starRating?: SortOrder
    pricePerNight?: SortOrder
  }

  export type HotelRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type HotelRoomCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    images?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    amenities?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxOccupancy?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
  }

  export type HotelRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    roomName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    maxOccupancy?: SortOrder
    bedType?: SortOrder
    roomSize?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
    isActive?: SortOrder
  }

  export type HotelRoomSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxOccupancy?: SortOrder
    pricePerNight?: SortOrder
    totalRooms?: SortOrder
  }

  export type HotelRoomRelationFilter = {
    is?: HotelRoomWhereInput
    isNot?: HotelRoomWhereInput
  }

  export type HotelBookingCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
  }

  export type HotelBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelBookingSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomId?: SortOrder
    numberOfRooms?: SortOrder
    numberOfGuests?: SortOrder
    totalAmount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserInterestListRelationFilter = {
    every?: UserInterestWhereInput
    some?: UserInterestWhereInput
    none?: UserInterestWhereInput
  }

  export type UserInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAccountCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserAccountRelationFilter = {
    is?: UserAccountWhereInput
    isNot?: UserAccountWhereInput
  }

  export type TourNullableRelationFilter = {
    is?: TourWhereInput | null
    isNot?: TourWhereInput | null
  }

  export type UserFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
  }

  export type UserFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFeedbackSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itineraryId?: SortOrder
    tourId?: SortOrder
    rating?: SortOrder
  }

  export type TourCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TourCategoryAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TourCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TourCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TourCategorySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type HotelListRelationFilter = {
    every?: HotelWhereInput
    some?: HotelWhereInput
    none?: HotelWhereInput
  }

  export type HotelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type HotelCategoryAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type HotelCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type HotelCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type HotelCategorySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TravelActivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelActivityAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TravelActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelActivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelActivitySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TravelInterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelInterestAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TravelInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelInterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
  }

  export type TravelInterestSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FlightBookingListRelationFilter = {
    every?: FlightBookingWhereInput
    some?: FlightBookingWhereInput
    none?: FlightBookingWhereInput
  }

  export type FlightBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlightRouteCountOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    airline?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type FlightRouteAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FlightRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    airline?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type FlightRouteMinOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    airline?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type FlightRouteSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AccommodationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
  }

  export type AccommodationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
  }

  export type AccommodationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
  }

  export type DifficultyLevelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DifficultyLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DifficultyLevelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type SeasonalPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: SortOrder
    isActive?: SortOrder
  }

  export type SeasonalPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: SortOrder
    isActive?: SortOrder
  }

  export type SeasonalPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weather?: SortOrder
    isActive?: SortOrder
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type ActivityRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type BookingActivityBookingIdActivityIdCompoundUniqueInput = {
    bookingId: number
    activityId: number
  }

  export type BookingActivityCountOrderByAggregateInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
  }

  export type BookingActivityAvgOrderByAggregateInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
  }

  export type BookingActivityMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
  }

  export type BookingActivityMinOrderByAggregateInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
  }

  export type BookingActivitySumOrderByAggregateInput = {
    bookingId?: SortOrder
    activityId?: SortOrder
  }

  export type TravelInterestRelationFilter = {
    is?: TravelInterestWhereInput
    isNot?: TravelInterestWhereInput
  }

  export type UserInterestUserIdInterestIdCompoundUniqueInput = {
    userId: number
    interestId: string
  }

  export type UserInterestCountOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
  }

  export type UserInterestAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserInterestMaxOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
  }

  export type UserInterestMinOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
  }

  export type UserInterestSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type CustomTourRequestRelationFilter = {
    is?: CustomTourRequestWhereInput
    isNot?: CustomTourRequestWhereInput
  }

  export type CustomTourInterestCustomTourRequestIdInterestIdCompoundUniqueInput = {
    customTourRequestId: number
    interestId: string
  }

  export type CustomTourInterestCountOrderByAggregateInput = {
    customTourRequestId?: SortOrder
    interestId?: SortOrder
  }

  export type CustomTourInterestAvgOrderByAggregateInput = {
    customTourRequestId?: SortOrder
  }

  export type CustomTourInterestMaxOrderByAggregateInput = {
    customTourRequestId?: SortOrder
    interestId?: SortOrder
  }

  export type CustomTourInterestMinOrderByAggregateInput = {
    customTourRequestId?: SortOrder
    interestId?: SortOrder
  }

  export type CustomTourInterestSumOrderByAggregateInput = {
    customTourRequestId?: SortOrder
  }

  export type FlightRouteRelationFilter = {
    is?: FlightRouteWhereInput
    isNot?: FlightRouteWhereInput
  }

  export type FlightBookingCountOrderByAggregateInput = {
    id?: SortOrder
    flightRouteId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type FlightBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
  }

  export type FlightBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    flightRouteId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type FlightBookingMinOrderByAggregateInput = {
    id?: SortOrder
    flightRouteId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type FlightBookingSumOrderByAggregateInput = {
    id?: SortOrder
    numberOfPassengers?: SortOrder
    totalAmount?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    price?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    price?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    difficulty?: SortOrder
    price?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type TourActivityJunctionTourIdActivityIdCompoundUniqueInput = {
    tourId: number
    activityId: number
  }

  export type TourActivityJunctionCountOrderByAggregateInput = {
    tourId?: SortOrder
    activityId?: SortOrder
    included?: SortOrder
    optional?: SortOrder
  }

  export type TourActivityJunctionAvgOrderByAggregateInput = {
    tourId?: SortOrder
    activityId?: SortOrder
  }

  export type TourActivityJunctionMaxOrderByAggregateInput = {
    tourId?: SortOrder
    activityId?: SortOrder
    included?: SortOrder
    optional?: SortOrder
  }

  export type TourActivityJunctionMinOrderByAggregateInput = {
    tourId?: SortOrder
    activityId?: SortOrder
    included?: SortOrder
    optional?: SortOrder
  }

  export type TourActivityJunctionSumOrderByAggregateInput = {
    tourId?: SortOrder
    activityId?: SortOrder
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    experiences?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FlightCountOrderByAggregateInput = {
    id?: SortOrder
    airline?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    aircraft?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FlightMaxOrderByAggregateInput = {
    id?: SortOrder
    airline?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    aircraft?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightMinOrderByAggregateInput = {
    id?: SortOrder
    airline?: SortOrder
    route?: SortOrder
    duration?: SortOrder
    frequency?: SortOrder
    price?: SortOrder
    aircraft?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type TourFestivalTourIdFestivalIdCompoundUniqueInput = {
    tourId: number
    festivalId: number
  }

  export type TourFestivalCountOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
  }

  export type TourFestivalAvgOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
  }

  export type TourFestivalMaxOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
  }

  export type TourFestivalMinOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
  }

  export type TourFestivalSumOrderByAggregateInput = {
    id?: SortOrder
    tourId?: SortOrder
    festivalId?: SortOrder
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChatSessionRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sender?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hotelBookingId?: SortOrder
    flightBookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hotelBookingId?: SortOrder
    flightBookingId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hotelBookingId?: SortOrder
    flightBookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hotelBookingId?: SortOrder
    flightBookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    hotelBookingId?: SortOrder
    flightBookingId?: SortOrder
    amount?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TourCreatehighlightsInput = {
    set: string[]
  }

  export type TourCreateincludesInput = {
    set: string[]
  }

  export type TourCreateexcludesInput = {
    set: string[]
  }

  export type TourCreatebestTimeInput = {
    set: string[]
  }

  export type BookingCreateNestedManyWithoutTourInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutTourInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type TourOperatorCreateNestedOneWithoutToursInput = {
    create?: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    connectOrCreate?: TourOperatorCreateOrConnectWithoutToursInput
    connect?: TourOperatorWhereUniqueInput
  }

  export type UserFeedbackCreateNestedManyWithoutTourInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type TourFestivalCreateNestedManyWithoutTourInput = {
    create?: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput> | TourFestivalCreateWithoutTourInput[] | TourFestivalUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutTourInput | TourFestivalCreateOrConnectWithoutTourInput[]
    createMany?: TourFestivalCreateManyTourInputEnvelope
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
  }

  export type TourActivityJunctionCreateNestedManyWithoutTourInput = {
    create?: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput> | TourActivityJunctionCreateWithoutTourInput[] | TourActivityJunctionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutTourInput | TourActivityJunctionCreateOrConnectWithoutTourInput[]
    createMany?: TourActivityJunctionCreateManyTourInputEnvelope
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type TourFestivalUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput> | TourFestivalCreateWithoutTourInput[] | TourFestivalUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutTourInput | TourFestivalCreateOrConnectWithoutTourInput[]
    createMany?: TourFestivalCreateManyTourInputEnvelope
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
  }

  export type TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput> | TourActivityJunctionCreateWithoutTourInput[] | TourActivityJunctionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutTourInput | TourActivityJunctionCreateOrConnectWithoutTourInput[]
    createMany?: TourActivityJunctionCreateManyTourInputEnvelope
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TourUpdatehighlightsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateincludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateexcludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdatebestTimeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookingUpdateManyWithoutTourNestedInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTourInput | BookingUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTourInput | BookingUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTourInput | BookingUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutTourNestedInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutTourInput | ItineraryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutTourInput | ItineraryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutTourInput | ItineraryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type TourOperatorUpdateOneWithoutToursNestedInput = {
    create?: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    connectOrCreate?: TourOperatorCreateOrConnectWithoutToursInput
    upsert?: TourOperatorUpsertWithoutToursInput
    disconnect?: TourOperatorWhereInput | boolean
    delete?: TourOperatorWhereInput | boolean
    connect?: TourOperatorWhereUniqueInput
    update?: XOR<XOR<TourOperatorUpdateToOneWithWhereWithoutToursInput, TourOperatorUpdateWithoutToursInput>, TourOperatorUncheckedUpdateWithoutToursInput>
  }

  export type UserFeedbackUpdateManyWithoutTourNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutTourInput | UserFeedbackUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutTourInput | UserFeedbackUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutTourInput | UserFeedbackUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type TourFestivalUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput> | TourFestivalCreateWithoutTourInput[] | TourFestivalUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutTourInput | TourFestivalCreateOrConnectWithoutTourInput[]
    upsert?: TourFestivalUpsertWithWhereUniqueWithoutTourInput | TourFestivalUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourFestivalCreateManyTourInputEnvelope
    set?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    disconnect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    delete?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    update?: TourFestivalUpdateWithWhereUniqueWithoutTourInput | TourFestivalUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourFestivalUpdateManyWithWhereWithoutTourInput | TourFestivalUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
  }

  export type TourActivityJunctionUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput> | TourActivityJunctionCreateWithoutTourInput[] | TourActivityJunctionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutTourInput | TourActivityJunctionCreateOrConnectWithoutTourInput[]
    upsert?: TourActivityJunctionUpsertWithWhereUniqueWithoutTourInput | TourActivityJunctionUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourActivityJunctionCreateManyTourInputEnvelope
    set?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    disconnect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    delete?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    update?: TourActivityJunctionUpdateWithWhereUniqueWithoutTourInput | TourActivityJunctionUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourActivityJunctionUpdateManyWithWhereWithoutTourInput | TourActivityJunctionUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput> | BookingCreateWithoutTourInput[] | BookingUncheckedCreateWithoutTourInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTourInput | BookingCreateOrConnectWithoutTourInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTourInput | BookingUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: BookingCreateManyTourInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTourInput | BookingUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTourInput | BookingUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput> | ItineraryCreateWithoutTourInput[] | ItineraryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutTourInput | ItineraryCreateOrConnectWithoutTourInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutTourInput | ItineraryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: ItineraryCreateManyTourInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutTourInput | ItineraryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutTourInput | ItineraryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput> | UserFeedbackCreateWithoutTourInput[] | UserFeedbackUncheckedCreateWithoutTourInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutTourInput | UserFeedbackCreateOrConnectWithoutTourInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutTourInput | UserFeedbackUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: UserFeedbackCreateManyTourInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutTourInput | UserFeedbackUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutTourInput | UserFeedbackUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type TourFestivalUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput> | TourFestivalCreateWithoutTourInput[] | TourFestivalUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutTourInput | TourFestivalCreateOrConnectWithoutTourInput[]
    upsert?: TourFestivalUpsertWithWhereUniqueWithoutTourInput | TourFestivalUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourFestivalCreateManyTourInputEnvelope
    set?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    disconnect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    delete?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    update?: TourFestivalUpdateWithWhereUniqueWithoutTourInput | TourFestivalUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourFestivalUpdateManyWithWhereWithoutTourInput | TourFestivalUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
  }

  export type TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput> | TourActivityJunctionCreateWithoutTourInput[] | TourActivityJunctionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutTourInput | TourActivityJunctionCreateOrConnectWithoutTourInput[]
    upsert?: TourActivityJunctionUpsertWithWhereUniqueWithoutTourInput | TourActivityJunctionUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourActivityJunctionCreateManyTourInputEnvelope
    set?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    disconnect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    delete?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    update?: TourActivityJunctionUpdateWithWhereUniqueWithoutTourInput | TourActivityJunctionUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourActivityJunctionUpdateManyWithWhereWithoutTourInput | TourActivityJunctionUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TourCreateOrConnectWithoutBookingsInput
    connect?: TourWhereUniqueInput
  }

  export type BookingActivityCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput> | BookingActivityCreateWithoutBookingInput[] | BookingActivityUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutBookingInput | BookingActivityCreateOrConnectWithoutBookingInput[]
    createMany?: BookingActivityCreateManyBookingInputEnvelope
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
  }

  export type BookingActivityUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput> | BookingActivityCreateWithoutBookingInput[] | BookingActivityUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutBookingInput | BookingActivityCreateOrConnectWithoutBookingInput[]
    createMany?: BookingActivityCreateManyBookingInputEnvelope
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
  }

  export type TourUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TourCreateOrConnectWithoutBookingsInput
    upsert?: TourUpsertWithoutBookingsInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutBookingsInput, TourUpdateWithoutBookingsInput>, TourUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingActivityUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput> | BookingActivityCreateWithoutBookingInput[] | BookingActivityUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutBookingInput | BookingActivityCreateOrConnectWithoutBookingInput[]
    upsert?: BookingActivityUpsertWithWhereUniqueWithoutBookingInput | BookingActivityUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingActivityCreateManyBookingInputEnvelope
    set?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    disconnect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    delete?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    update?: BookingActivityUpdateWithWhereUniqueWithoutBookingInput | BookingActivityUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingActivityUpdateManyWithWhereWithoutBookingInput | BookingActivityUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
  }

  export type BookingActivityUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput> | BookingActivityCreateWithoutBookingInput[] | BookingActivityUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutBookingInput | BookingActivityCreateOrConnectWithoutBookingInput[]
    upsert?: BookingActivityUpsertWithWhereUniqueWithoutBookingInput | BookingActivityUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingActivityCreateManyBookingInputEnvelope
    set?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    disconnect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    delete?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    update?: BookingActivityUpdateWithWhereUniqueWithoutBookingInput | BookingActivityUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingActivityUpdateManyWithWhereWithoutBookingInput | BookingActivityUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
  }

  export type GuideCreatespecializationsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedManyWithoutGuideInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutDriverInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutGuideInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type GuideUpdatespecializationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateManyWithoutGuideNestedInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutGuideInput | ItineraryUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutGuideInput | ItineraryUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutGuideInput | ItineraryUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutDriverInput | ItineraryUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutDriverInput | ItineraryUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutDriverInput | ItineraryUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutGuideNestedInput = {
    create?: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput> | ItineraryCreateWithoutGuideInput[] | ItineraryUncheckedCreateWithoutGuideInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutGuideInput | ItineraryCreateOrConnectWithoutGuideInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutGuideInput | ItineraryUpsertWithWhereUniqueWithoutGuideInput[]
    createMany?: ItineraryCreateManyGuideInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutGuideInput | ItineraryUpdateWithWhereUniqueWithoutGuideInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutGuideInput | ItineraryUpdateManyWithWhereWithoutGuideInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput> | ItineraryCreateWithoutDriverInput[] | ItineraryUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutDriverInput | ItineraryCreateOrConnectWithoutDriverInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutDriverInput | ItineraryUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ItineraryCreateManyDriverInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutDriverInput | ItineraryUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutDriverInput | ItineraryUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutItinerariesInput = {
    create?: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: TourCreateOrConnectWithoutItinerariesInput
    connect?: TourWhereUniqueInput
  }

  export type GuideCreateNestedOneWithoutGuidedItinerariesInput = {
    create?: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutGuidedItinerariesInput
    connect?: GuideWhereUniqueInput
  }

  export type GuideCreateNestedOneWithoutDrivenItinerariesInput = {
    create?: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutDrivenItinerariesInput
    connect?: GuideWhereUniqueInput
  }

  export type ItineraryDayCreateNestedManyWithoutItineraryInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
  }

  export type CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
  }

  export type UserFeedbackCreateNestedManyWithoutItineraryInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
  }

  export type CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type TourUpdateOneRequiredWithoutItinerariesNestedInput = {
    create?: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    connectOrCreate?: TourCreateOrConnectWithoutItinerariesInput
    upsert?: TourUpsertWithoutItinerariesInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutItinerariesInput, TourUpdateWithoutItinerariesInput>, TourUncheckedUpdateWithoutItinerariesInput>
  }

  export type GuideUpdateOneWithoutGuidedItinerariesNestedInput = {
    create?: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutGuidedItinerariesInput
    upsert?: GuideUpsertWithoutGuidedItinerariesInput
    disconnect?: GuideWhereInput | boolean
    delete?: GuideWhereInput | boolean
    connect?: GuideWhereUniqueInput
    update?: XOR<XOR<GuideUpdateToOneWithWhereWithoutGuidedItinerariesInput, GuideUpdateWithoutGuidedItinerariesInput>, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
  }

  export type GuideUpdateOneWithoutDrivenItinerariesNestedInput = {
    create?: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    connectOrCreate?: GuideCreateOrConnectWithoutDrivenItinerariesInput
    upsert?: GuideUpsertWithoutDrivenItinerariesInput
    disconnect?: GuideWhereInput | boolean
    delete?: GuideWhereInput | boolean
    connect?: GuideWhereUniqueInput
    update?: XOR<XOR<GuideUpdateToOneWithWhereWithoutDrivenItinerariesInput, GuideUpdateWithoutDrivenItinerariesInput>, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
  }

  export type ItineraryDayUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    upsert?: ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput | ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    set?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    disconnect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    delete?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    update?: ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput | ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: ItineraryDayUpdateManyWithWhereWithoutItineraryInput | ItineraryDayUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
  }

  export type CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    upsert?: CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    set?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    disconnect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    delete?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    update?: CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput[]
    updateMany?: CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput | CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput[]
    deleteMany?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
  }

  export type UserFeedbackUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput | UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput | UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutItineraryInput | UserFeedbackUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput> | ItineraryDayCreateWithoutItineraryInput[] | ItineraryDayUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: ItineraryDayCreateOrConnectWithoutItineraryInput | ItineraryDayCreateOrConnectWithoutItineraryInput[]
    upsert?: ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput | ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: ItineraryDayCreateManyItineraryInputEnvelope
    set?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    disconnect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    delete?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    connect?: ItineraryDayWhereUniqueInput | ItineraryDayWhereUniqueInput[]
    update?: ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput | ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: ItineraryDayUpdateManyWithWhereWithoutItineraryInput | ItineraryDayUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
  }

  export type CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput = {
    create?: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput> | CustomTourRequestCreateWithoutAssignedItineraryInput[] | CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput[]
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput | CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput[]
    upsert?: CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput[]
    createMany?: CustomTourRequestCreateManyAssignedItineraryInputEnvelope
    set?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    disconnect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    delete?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    connect?: CustomTourRequestWhereUniqueInput | CustomTourRequestWhereUniqueInput[]
    update?: CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput | CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput[]
    updateMany?: CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput | CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput[]
    deleteMany?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput> | UserFeedbackCreateWithoutItineraryInput[] | UserFeedbackUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutItineraryInput | UserFeedbackCreateOrConnectWithoutItineraryInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput | UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: UserFeedbackCreateManyItineraryInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput | UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutItineraryInput | UserFeedbackUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type ItineraryDayCreateactivitiesInput = {
    set: string[]
  }

  export type ItineraryDayCreatemealsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedOneWithoutDaysInput = {
    create?: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutDaysInput
    connect?: ItineraryWhereUniqueInput
  }

  export type ItineraryDayUpdateactivitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryDayUpdatemealsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateOneRequiredWithoutDaysNestedInput = {
    create?: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutDaysInput
    upsert?: ItineraryUpsertWithoutDaysInput
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutDaysInput, ItineraryUpdateWithoutDaysInput>, ItineraryUncheckedUpdateWithoutDaysInput>
  }

  export type CustomTourRequestCreatedestinationsInput = {
    set: string[]
  }

  export type ItineraryCreateNestedOneWithoutAssignedCustomTourRequestsInput = {
    create?: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput
    connect?: ItineraryWhereUniqueInput
  }

  export type CustomTourInterestCreateNestedManyWithoutCustomTourRequestInput = {
    create?: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput> | CustomTourInterestCreateWithoutCustomTourRequestInput[] | CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput | CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput[]
    createMany?: CustomTourInterestCreateManyCustomTourRequestInputEnvelope
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
  }

  export type CustomTourInterestUncheckedCreateNestedManyWithoutCustomTourRequestInput = {
    create?: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput> | CustomTourInterestCreateWithoutCustomTourRequestInput[] | CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput | CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput[]
    createMany?: CustomTourInterestCreateManyCustomTourRequestInputEnvelope
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
  }

  export type CustomTourRequestUpdatedestinationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ItineraryUpdateOneWithoutAssignedCustomTourRequestsNestedInput = {
    create?: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput
    upsert?: ItineraryUpsertWithoutAssignedCustomTourRequestsInput
    disconnect?: ItineraryWhereInput | boolean
    delete?: ItineraryWhereInput | boolean
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutAssignedCustomTourRequestsInput, ItineraryUpdateWithoutAssignedCustomTourRequestsInput>, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
  }

  export type CustomTourInterestUpdateManyWithoutCustomTourRequestNestedInput = {
    create?: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput> | CustomTourInterestCreateWithoutCustomTourRequestInput[] | CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput | CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput[]
    upsert?: CustomTourInterestUpsertWithWhereUniqueWithoutCustomTourRequestInput | CustomTourInterestUpsertWithWhereUniqueWithoutCustomTourRequestInput[]
    createMany?: CustomTourInterestCreateManyCustomTourRequestInputEnvelope
    set?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    disconnect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    delete?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    update?: CustomTourInterestUpdateWithWhereUniqueWithoutCustomTourRequestInput | CustomTourInterestUpdateWithWhereUniqueWithoutCustomTourRequestInput[]
    updateMany?: CustomTourInterestUpdateManyWithWhereWithoutCustomTourRequestInput | CustomTourInterestUpdateManyWithWhereWithoutCustomTourRequestInput[]
    deleteMany?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
  }

  export type CustomTourInterestUncheckedUpdateManyWithoutCustomTourRequestNestedInput = {
    create?: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput> | CustomTourInterestCreateWithoutCustomTourRequestInput[] | CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput | CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput[]
    upsert?: CustomTourInterestUpsertWithWhereUniqueWithoutCustomTourRequestInput | CustomTourInterestUpsertWithWhereUniqueWithoutCustomTourRequestInput[]
    createMany?: CustomTourInterestCreateManyCustomTourRequestInputEnvelope
    set?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    disconnect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    delete?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    update?: CustomTourInterestUpdateWithWhereUniqueWithoutCustomTourRequestInput | CustomTourInterestUpdateWithWhereUniqueWithoutCustomTourRequestInput[]
    updateMany?: CustomTourInterestUpdateManyWithWhereWithoutCustomTourRequestInput | CustomTourInterestUpdateManyWithWhereWithoutCustomTourRequestInput[]
    deleteMany?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
  }

  export type TourOperatorCreatespecialtiesInput = {
    set: string[]
  }

  export type TourOperatorCreatecertificationsInput = {
    set: string[]
  }

  export type TourOperatorCreateawardsInput = {
    set: string[]
  }

  export type TourCreateNestedManyWithoutTourOperatorInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutTourOperatorInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourOperatorUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourOperatorUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourOperatorUpdateawardsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateManyWithoutTourOperatorNestedInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutTourOperatorInput | TourUpsertWithWhereUniqueWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutTourOperatorInput | TourUpdateWithWhereUniqueWithoutTourOperatorInput[]
    updateMany?: TourUpdateManyWithWhereWithoutTourOperatorInput | TourUpdateManyWithWhereWithoutTourOperatorInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutTourOperatorNestedInput = {
    create?: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput> | TourCreateWithoutTourOperatorInput[] | TourUncheckedCreateWithoutTourOperatorInput[]
    connectOrCreate?: TourCreateOrConnectWithoutTourOperatorInput | TourCreateOrConnectWithoutTourOperatorInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutTourOperatorInput | TourUpsertWithWhereUniqueWithoutTourOperatorInput[]
    createMany?: TourCreateManyTourOperatorInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutTourOperatorInput | TourUpdateWithWhereUniqueWithoutTourOperatorInput[]
    updateMany?: TourUpdateManyWithWhereWithoutTourOperatorInput | TourUpdateManyWithWhereWithoutTourOperatorInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type FestivalCreateactivitiesInput = {
    set: string[]
  }

  export type TourFestivalCreateNestedManyWithoutFestivalInput = {
    create?: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput> | TourFestivalCreateWithoutFestivalInput[] | TourFestivalUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutFestivalInput | TourFestivalCreateOrConnectWithoutFestivalInput[]
    createMany?: TourFestivalCreateManyFestivalInputEnvelope
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
  }

  export type FestivalBookingCreateNestedManyWithoutFestivalInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
  }

  export type TourFestivalUncheckedCreateNestedManyWithoutFestivalInput = {
    create?: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput> | TourFestivalCreateWithoutFestivalInput[] | TourFestivalUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutFestivalInput | TourFestivalCreateOrConnectWithoutFestivalInput[]
    createMany?: TourFestivalCreateManyFestivalInputEnvelope
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
  }

  export type FestivalBookingUncheckedCreateNestedManyWithoutFestivalInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
  }

  export type FestivalUpdateactivitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourFestivalUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput> | TourFestivalCreateWithoutFestivalInput[] | TourFestivalUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutFestivalInput | TourFestivalCreateOrConnectWithoutFestivalInput[]
    upsert?: TourFestivalUpsertWithWhereUniqueWithoutFestivalInput | TourFestivalUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: TourFestivalCreateManyFestivalInputEnvelope
    set?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    disconnect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    delete?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    update?: TourFestivalUpdateWithWhereUniqueWithoutFestivalInput | TourFestivalUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: TourFestivalUpdateManyWithWhereWithoutFestivalInput | TourFestivalUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
  }

  export type FestivalBookingUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    upsert?: FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput | FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    set?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    disconnect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    delete?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    update?: FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput | FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: FestivalBookingUpdateManyWithWhereWithoutFestivalInput | FestivalBookingUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
  }

  export type TourFestivalUncheckedUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput> | TourFestivalCreateWithoutFestivalInput[] | TourFestivalUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: TourFestivalCreateOrConnectWithoutFestivalInput | TourFestivalCreateOrConnectWithoutFestivalInput[]
    upsert?: TourFestivalUpsertWithWhereUniqueWithoutFestivalInput | TourFestivalUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: TourFestivalCreateManyFestivalInputEnvelope
    set?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    disconnect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    delete?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    connect?: TourFestivalWhereUniqueInput | TourFestivalWhereUniqueInput[]
    update?: TourFestivalUpdateWithWhereUniqueWithoutFestivalInput | TourFestivalUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: TourFestivalUpdateManyWithWhereWithoutFestivalInput | TourFestivalUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
  }

  export type FestivalBookingUncheckedUpdateManyWithoutFestivalNestedInput = {
    create?: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput> | FestivalBookingCreateWithoutFestivalInput[] | FestivalBookingUncheckedCreateWithoutFestivalInput[]
    connectOrCreate?: FestivalBookingCreateOrConnectWithoutFestivalInput | FestivalBookingCreateOrConnectWithoutFestivalInput[]
    upsert?: FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput | FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput[]
    createMany?: FestivalBookingCreateManyFestivalInputEnvelope
    set?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    disconnect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    delete?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    connect?: FestivalBookingWhereUniqueInput | FestivalBookingWhereUniqueInput[]
    update?: FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput | FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput[]
    updateMany?: FestivalBookingUpdateManyWithWhereWithoutFestivalInput | FestivalBookingUpdateManyWithWhereWithoutFestivalInput[]
    deleteMany?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
  }

  export type FestivalCreateNestedOneWithoutFestivalBookingsInput = {
    create?: XOR<FestivalCreateWithoutFestivalBookingsInput, FestivalUncheckedCreateWithoutFestivalBookingsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutFestivalBookingsInput
    connect?: FestivalWhereUniqueInput
  }

  export type FestivalUpdateOneRequiredWithoutFestivalBookingsNestedInput = {
    create?: XOR<FestivalCreateWithoutFestivalBookingsInput, FestivalUncheckedCreateWithoutFestivalBookingsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutFestivalBookingsInput
    upsert?: FestivalUpsertWithoutFestivalBookingsInput
    connect?: FestivalWhereUniqueInput
    update?: XOR<XOR<FestivalUpdateToOneWithWhereWithoutFestivalBookingsInput, FestivalUpdateWithoutFestivalBookingsInput>, FestivalUncheckedUpdateWithoutFestivalBookingsInput>
  }

  export type HotelCreateimagesInput = {
    set: string[]
  }

  export type HotelCreateamenitiesInput = {
    set: string[]
  }

  export type HotelCreatefeaturesInput = {
    set: string[]
  }

  export type HotelCategoryCreateNestedOneWithoutHotelsInput = {
    create?: XOR<HotelCategoryCreateWithoutHotelsInput, HotelCategoryUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: HotelCategoryCreateOrConnectWithoutHotelsInput
    connect?: HotelCategoryWhereUniqueInput
  }

  export type HotelRoomCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
  }

  export type HotelBookingCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelRoomUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelCategoryUpdateOneRequiredWithoutHotelsNestedInput = {
    create?: XOR<HotelCategoryCreateWithoutHotelsInput, HotelCategoryUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: HotelCategoryCreateOrConnectWithoutHotelsInput
    upsert?: HotelCategoryUpsertWithoutHotelsInput
    connect?: HotelCategoryWhereUniqueInput
    update?: XOR<XOR<HotelCategoryUpdateToOneWithWhereWithoutHotelsInput, HotelCategoryUpdateWithoutHotelsInput>, HotelCategoryUncheckedUpdateWithoutHotelsInput>
  }

  export type HotelRoomUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    upsert?: HotelRoomUpsertWithWhereUniqueWithoutHotelInput | HotelRoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    set?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    disconnect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    delete?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    update?: HotelRoomUpdateWithWhereUniqueWithoutHotelInput | HotelRoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelRoomUpdateManyWithWhereWithoutHotelInput | HotelRoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
  }

  export type HotelBookingUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutHotelInput | HotelBookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutHotelInput | HotelBookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutHotelInput | HotelBookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelRoomUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput> | HotelRoomCreateWithoutHotelInput[] | HotelRoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelRoomCreateOrConnectWithoutHotelInput | HotelRoomCreateOrConnectWithoutHotelInput[]
    upsert?: HotelRoomUpsertWithWhereUniqueWithoutHotelInput | HotelRoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelRoomCreateManyHotelInputEnvelope
    set?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    disconnect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    delete?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    connect?: HotelRoomWhereUniqueInput | HotelRoomWhereUniqueInput[]
    update?: HotelRoomUpdateWithWhereUniqueWithoutHotelInput | HotelRoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelRoomUpdateManyWithWhereWithoutHotelInput | HotelRoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
  }

  export type HotelBookingUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput> | HotelBookingCreateWithoutHotelInput[] | HotelBookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutHotelInput | HotelBookingCreateOrConnectWithoutHotelInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutHotelInput | HotelBookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelBookingCreateManyHotelInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutHotelInput | HotelBookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutHotelInput | HotelBookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelRoomCreateimagesInput = {
    set: string[]
  }

  export type HotelRoomCreateamenitiesInput = {
    set: string[]
  }

  export type HotelCreateNestedOneWithoutRoomsInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelBookingCreateNestedManyWithoutRoomInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelBookingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
  }

  export type HotelRoomUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelRoomUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    upsert?: HotelUpsertWithoutRoomsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomsInput, HotelUpdateWithoutRoomsInput>, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelBookingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRoomInput | HotelBookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRoomInput | HotelBookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRoomInput | HotelBookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelBookingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput> | HotelBookingCreateWithoutRoomInput[] | HotelBookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: HotelBookingCreateOrConnectWithoutRoomInput | HotelBookingCreateOrConnectWithoutRoomInput[]
    upsert?: HotelBookingUpsertWithWhereUniqueWithoutRoomInput | HotelBookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: HotelBookingCreateManyRoomInputEnvelope
    set?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    disconnect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    delete?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    connect?: HotelBookingWhereUniqueInput | HotelBookingWhereUniqueInput[]
    update?: HotelBookingUpdateWithWhereUniqueWithoutRoomInput | HotelBookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: HotelBookingUpdateManyWithWhereWithoutRoomInput | HotelBookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelRoomCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelRoomCreateOrConnectWithoutBookingsInput
    connect?: HotelRoomWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    upsert?: HotelUpsertWithoutBookingsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutBookingsInput, HotelUpdateWithoutBookingsInput>, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelRoomUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelRoomCreateOrConnectWithoutBookingsInput
    upsert?: HotelRoomUpsertWithoutBookingsInput
    connect?: HotelRoomWhereUniqueInput
    update?: XOR<XOR<HotelRoomUpdateToOneWithWhereWithoutBookingsInput, HotelRoomUpdateWithoutBookingsInput>, HotelRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type UserFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type UserInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type UserFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
  }

  export type UserInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutUserInput | UserFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutUserInput | UserFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutUserInput | UserFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type UserInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutUserInput | UserInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutUserInput | UserInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutUserInput | UserInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type UserFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput> | UserFeedbackCreateWithoutUserInput[] | UserFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeedbackCreateOrConnectWithoutUserInput | UserFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: UserFeedbackUpsertWithWhereUniqueWithoutUserInput | UserFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeedbackCreateManyUserInputEnvelope
    set?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    disconnect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    delete?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    connect?: UserFeedbackWhereUniqueInput | UserFeedbackWhereUniqueInput[]
    update?: UserFeedbackUpdateWithWhereUniqueWithoutUserInput | UserFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeedbackUpdateManyWithWhereWithoutUserInput | UserFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
  }

  export type UserInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput> | UserInterestCreateWithoutUserInput[] | UserInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutUserInput | UserInterestCreateOrConnectWithoutUserInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutUserInput | UserInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInterestCreateManyUserInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutUserInput | UserInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutUserInput | UserInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type UserAccountCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutFeedbacksInput
    connect?: UserAccountWhereUniqueInput
  }

  export type ItineraryCreateNestedOneWithoutUserFeedbackInput = {
    create?: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutUserFeedbackInput
    connect?: ItineraryWhereUniqueInput
  }

  export type TourCreateNestedOneWithoutUserFeedbackInput = {
    create?: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: TourCreateOrConnectWithoutUserFeedbackInput
    connect?: TourWhereUniqueInput
  }

  export type UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutFeedbacksInput
    upsert?: UserAccountUpsertWithoutFeedbacksInput
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutFeedbacksInput, UserAccountUpdateWithoutFeedbacksInput>, UserAccountUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ItineraryUpdateOneWithoutUserFeedbackNestedInput = {
    create?: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutUserFeedbackInput
    upsert?: ItineraryUpsertWithoutUserFeedbackInput
    disconnect?: ItineraryWhereInput | boolean
    delete?: ItineraryWhereInput | boolean
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutUserFeedbackInput, ItineraryUpdateWithoutUserFeedbackInput>, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type TourUpdateOneWithoutUserFeedbackNestedInput = {
    create?: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    connectOrCreate?: TourCreateOrConnectWithoutUserFeedbackInput
    upsert?: TourUpsertWithoutUserFeedbackInput
    disconnect?: TourWhereInput | boolean
    delete?: TourWhereInput | boolean
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutUserFeedbackInput, TourUpdateWithoutUserFeedbackInput>, TourUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type HotelCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput> | HotelCreateWithoutCategoryInput[] | HotelUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCategoryInput | HotelCreateOrConnectWithoutCategoryInput[]
    createMany?: HotelCreateManyCategoryInputEnvelope
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
  }

  export type HotelUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput> | HotelCreateWithoutCategoryInput[] | HotelUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCategoryInput | HotelCreateOrConnectWithoutCategoryInput[]
    createMany?: HotelCreateManyCategoryInputEnvelope
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
  }

  export type HotelUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput> | HotelCreateWithoutCategoryInput[] | HotelUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCategoryInput | HotelCreateOrConnectWithoutCategoryInput[]
    upsert?: HotelUpsertWithWhereUniqueWithoutCategoryInput | HotelUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HotelCreateManyCategoryInputEnvelope
    set?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    disconnect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    delete?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    update?: HotelUpdateWithWhereUniqueWithoutCategoryInput | HotelUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HotelUpdateManyWithWhereWithoutCategoryInput | HotelUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HotelScalarWhereInput | HotelScalarWhereInput[]
  }

  export type HotelUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput> | HotelCreateWithoutCategoryInput[] | HotelUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCategoryInput | HotelCreateOrConnectWithoutCategoryInput[]
    upsert?: HotelUpsertWithWhereUniqueWithoutCategoryInput | HotelUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HotelCreateManyCategoryInputEnvelope
    set?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    disconnect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    delete?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    update?: HotelUpdateWithWhereUniqueWithoutCategoryInput | HotelUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HotelUpdateManyWithWhereWithoutCategoryInput | HotelUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HotelScalarWhereInput | HotelScalarWhereInput[]
  }

  export type UserInterestCreateNestedManyWithoutInterestInput = {
    create?: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput> | UserInterestCreateWithoutInterestInput[] | UserInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutInterestInput | UserInterestCreateOrConnectWithoutInterestInput[]
    createMany?: UserInterestCreateManyInterestInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type CustomTourInterestCreateNestedManyWithoutInterestInput = {
    create?: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput> | CustomTourInterestCreateWithoutInterestInput[] | CustomTourInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutInterestInput | CustomTourInterestCreateOrConnectWithoutInterestInput[]
    createMany?: CustomTourInterestCreateManyInterestInputEnvelope
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
  }

  export type UserInterestUncheckedCreateNestedManyWithoutInterestInput = {
    create?: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput> | UserInterestCreateWithoutInterestInput[] | UserInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutInterestInput | UserInterestCreateOrConnectWithoutInterestInput[]
    createMany?: UserInterestCreateManyInterestInputEnvelope
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
  }

  export type CustomTourInterestUncheckedCreateNestedManyWithoutInterestInput = {
    create?: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput> | CustomTourInterestCreateWithoutInterestInput[] | CustomTourInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutInterestInput | CustomTourInterestCreateOrConnectWithoutInterestInput[]
    createMany?: CustomTourInterestCreateManyInterestInputEnvelope
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
  }

  export type UserInterestUpdateManyWithoutInterestNestedInput = {
    create?: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput> | UserInterestCreateWithoutInterestInput[] | UserInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutInterestInput | UserInterestCreateOrConnectWithoutInterestInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutInterestInput | UserInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: UserInterestCreateManyInterestInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutInterestInput | UserInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutInterestInput | UserInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type CustomTourInterestUpdateManyWithoutInterestNestedInput = {
    create?: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput> | CustomTourInterestCreateWithoutInterestInput[] | CustomTourInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutInterestInput | CustomTourInterestCreateOrConnectWithoutInterestInput[]
    upsert?: CustomTourInterestUpsertWithWhereUniqueWithoutInterestInput | CustomTourInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: CustomTourInterestCreateManyInterestInputEnvelope
    set?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    disconnect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    delete?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    update?: CustomTourInterestUpdateWithWhereUniqueWithoutInterestInput | CustomTourInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: CustomTourInterestUpdateManyWithWhereWithoutInterestInput | CustomTourInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
  }

  export type UserInterestUncheckedUpdateManyWithoutInterestNestedInput = {
    create?: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput> | UserInterestCreateWithoutInterestInput[] | UserInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: UserInterestCreateOrConnectWithoutInterestInput | UserInterestCreateOrConnectWithoutInterestInput[]
    upsert?: UserInterestUpsertWithWhereUniqueWithoutInterestInput | UserInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: UserInterestCreateManyInterestInputEnvelope
    set?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    disconnect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    delete?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    connect?: UserInterestWhereUniqueInput | UserInterestWhereUniqueInput[]
    update?: UserInterestUpdateWithWhereUniqueWithoutInterestInput | UserInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: UserInterestUpdateManyWithWhereWithoutInterestInput | UserInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
  }

  export type CustomTourInterestUncheckedUpdateManyWithoutInterestNestedInput = {
    create?: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput> | CustomTourInterestCreateWithoutInterestInput[] | CustomTourInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: CustomTourInterestCreateOrConnectWithoutInterestInput | CustomTourInterestCreateOrConnectWithoutInterestInput[]
    upsert?: CustomTourInterestUpsertWithWhereUniqueWithoutInterestInput | CustomTourInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: CustomTourInterestCreateManyInterestInputEnvelope
    set?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    disconnect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    delete?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    connect?: CustomTourInterestWhereUniqueInput | CustomTourInterestWhereUniqueInput[]
    update?: CustomTourInterestUpdateWithWhereUniqueWithoutInterestInput | CustomTourInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: CustomTourInterestUpdateManyWithWhereWithoutInterestInput | CustomTourInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
  }

  export type FlightBookingCreateNestedManyWithoutFlightRouteInput = {
    create?: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput> | FlightBookingCreateWithoutFlightRouteInput[] | FlightBookingUncheckedCreateWithoutFlightRouteInput[]
    connectOrCreate?: FlightBookingCreateOrConnectWithoutFlightRouteInput | FlightBookingCreateOrConnectWithoutFlightRouteInput[]
    createMany?: FlightBookingCreateManyFlightRouteInputEnvelope
    connect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
  }

  export type FlightBookingUncheckedCreateNestedManyWithoutFlightRouteInput = {
    create?: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput> | FlightBookingCreateWithoutFlightRouteInput[] | FlightBookingUncheckedCreateWithoutFlightRouteInput[]
    connectOrCreate?: FlightBookingCreateOrConnectWithoutFlightRouteInput | FlightBookingCreateOrConnectWithoutFlightRouteInput[]
    createMany?: FlightBookingCreateManyFlightRouteInputEnvelope
    connect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
  }

  export type FlightBookingUpdateManyWithoutFlightRouteNestedInput = {
    create?: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput> | FlightBookingCreateWithoutFlightRouteInput[] | FlightBookingUncheckedCreateWithoutFlightRouteInput[]
    connectOrCreate?: FlightBookingCreateOrConnectWithoutFlightRouteInput | FlightBookingCreateOrConnectWithoutFlightRouteInput[]
    upsert?: FlightBookingUpsertWithWhereUniqueWithoutFlightRouteInput | FlightBookingUpsertWithWhereUniqueWithoutFlightRouteInput[]
    createMany?: FlightBookingCreateManyFlightRouteInputEnvelope
    set?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    disconnect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    delete?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    connect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    update?: FlightBookingUpdateWithWhereUniqueWithoutFlightRouteInput | FlightBookingUpdateWithWhereUniqueWithoutFlightRouteInput[]
    updateMany?: FlightBookingUpdateManyWithWhereWithoutFlightRouteInput | FlightBookingUpdateManyWithWhereWithoutFlightRouteInput[]
    deleteMany?: FlightBookingScalarWhereInput | FlightBookingScalarWhereInput[]
  }

  export type FlightBookingUncheckedUpdateManyWithoutFlightRouteNestedInput = {
    create?: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput> | FlightBookingCreateWithoutFlightRouteInput[] | FlightBookingUncheckedCreateWithoutFlightRouteInput[]
    connectOrCreate?: FlightBookingCreateOrConnectWithoutFlightRouteInput | FlightBookingCreateOrConnectWithoutFlightRouteInput[]
    upsert?: FlightBookingUpsertWithWhereUniqueWithoutFlightRouteInput | FlightBookingUpsertWithWhereUniqueWithoutFlightRouteInput[]
    createMany?: FlightBookingCreateManyFlightRouteInputEnvelope
    set?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    disconnect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    delete?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    connect?: FlightBookingWhereUniqueInput | FlightBookingWhereUniqueInput[]
    update?: FlightBookingUpdateWithWhereUniqueWithoutFlightRouteInput | FlightBookingUpdateWithWhereUniqueWithoutFlightRouteInput[]
    updateMany?: FlightBookingUpdateManyWithWhereWithoutFlightRouteInput | FlightBookingUpdateManyWithWhereWithoutFlightRouteInput[]
    deleteMany?: FlightBookingScalarWhereInput | FlightBookingScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<BookingCreateWithoutActivitiesInput, BookingUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutActivitiesInput
    connect?: BookingWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutBookingActivitiesInput = {
    create?: XOR<ActivityCreateWithoutBookingActivitiesInput, ActivityUncheckedCreateWithoutBookingActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutBookingActivitiesInput
    connect?: ActivityWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<BookingCreateWithoutActivitiesInput, BookingUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutActivitiesInput
    upsert?: BookingUpsertWithoutActivitiesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutActivitiesInput, BookingUpdateWithoutActivitiesInput>, BookingUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityUpdateOneRequiredWithoutBookingActivitiesNestedInput = {
    create?: XOR<ActivityCreateWithoutBookingActivitiesInput, ActivityUncheckedCreateWithoutBookingActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutBookingActivitiesInput
    upsert?: ActivityUpsertWithoutBookingActivitiesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutBookingActivitiesInput, ActivityUpdateWithoutBookingActivitiesInput>, ActivityUncheckedUpdateWithoutBookingActivitiesInput>
  }

  export type UserAccountCreateNestedOneWithoutInterestsInput = {
    create?: XOR<UserAccountCreateWithoutInterestsInput, UserAccountUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInterestsInput
    connect?: UserAccountWhereUniqueInput
  }

  export type TravelInterestCreateNestedOneWithoutUserInterestsInput = {
    create?: XOR<TravelInterestCreateWithoutUserInterestsInput, TravelInterestUncheckedCreateWithoutUserInterestsInput>
    connectOrCreate?: TravelInterestCreateOrConnectWithoutUserInterestsInput
    connect?: TravelInterestWhereUniqueInput
  }

  export type UserAccountUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<UserAccountCreateWithoutInterestsInput, UserAccountUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserAccountCreateOrConnectWithoutInterestsInput
    upsert?: UserAccountUpsertWithoutInterestsInput
    connect?: UserAccountWhereUniqueInput
    update?: XOR<XOR<UserAccountUpdateToOneWithWhereWithoutInterestsInput, UserAccountUpdateWithoutInterestsInput>, UserAccountUncheckedUpdateWithoutInterestsInput>
  }

  export type TravelInterestUpdateOneRequiredWithoutUserInterestsNestedInput = {
    create?: XOR<TravelInterestCreateWithoutUserInterestsInput, TravelInterestUncheckedCreateWithoutUserInterestsInput>
    connectOrCreate?: TravelInterestCreateOrConnectWithoutUserInterestsInput
    upsert?: TravelInterestUpsertWithoutUserInterestsInput
    connect?: TravelInterestWhereUniqueInput
    update?: XOR<XOR<TravelInterestUpdateToOneWithWhereWithoutUserInterestsInput, TravelInterestUpdateWithoutUserInterestsInput>, TravelInterestUncheckedUpdateWithoutUserInterestsInput>
  }

  export type CustomTourRequestCreateNestedOneWithoutInterestsInput = {
    create?: XOR<CustomTourRequestCreateWithoutInterestsInput, CustomTourRequestUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutInterestsInput
    connect?: CustomTourRequestWhereUniqueInput
  }

  export type TravelInterestCreateNestedOneWithoutCustomTourInterestsInput = {
    create?: XOR<TravelInterestCreateWithoutCustomTourInterestsInput, TravelInterestUncheckedCreateWithoutCustomTourInterestsInput>
    connectOrCreate?: TravelInterestCreateOrConnectWithoutCustomTourInterestsInput
    connect?: TravelInterestWhereUniqueInput
  }

  export type CustomTourRequestUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<CustomTourRequestCreateWithoutInterestsInput, CustomTourRequestUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: CustomTourRequestCreateOrConnectWithoutInterestsInput
    upsert?: CustomTourRequestUpsertWithoutInterestsInput
    connect?: CustomTourRequestWhereUniqueInput
    update?: XOR<XOR<CustomTourRequestUpdateToOneWithWhereWithoutInterestsInput, CustomTourRequestUpdateWithoutInterestsInput>, CustomTourRequestUncheckedUpdateWithoutInterestsInput>
  }

  export type TravelInterestUpdateOneRequiredWithoutCustomTourInterestsNestedInput = {
    create?: XOR<TravelInterestCreateWithoutCustomTourInterestsInput, TravelInterestUncheckedCreateWithoutCustomTourInterestsInput>
    connectOrCreate?: TravelInterestCreateOrConnectWithoutCustomTourInterestsInput
    upsert?: TravelInterestUpsertWithoutCustomTourInterestsInput
    connect?: TravelInterestWhereUniqueInput
    update?: XOR<XOR<TravelInterestUpdateToOneWithWhereWithoutCustomTourInterestsInput, TravelInterestUpdateWithoutCustomTourInterestsInput>, TravelInterestUncheckedUpdateWithoutCustomTourInterestsInput>
  }

  export type FlightRouteCreateNestedOneWithoutFlightBookingsInput = {
    create?: XOR<FlightRouteCreateWithoutFlightBookingsInput, FlightRouteUncheckedCreateWithoutFlightBookingsInput>
    connectOrCreate?: FlightRouteCreateOrConnectWithoutFlightBookingsInput
    connect?: FlightRouteWhereUniqueInput
  }

  export type FlightRouteUpdateOneRequiredWithoutFlightBookingsNestedInput = {
    create?: XOR<FlightRouteCreateWithoutFlightBookingsInput, FlightRouteUncheckedCreateWithoutFlightBookingsInput>
    connectOrCreate?: FlightRouteCreateOrConnectWithoutFlightBookingsInput
    upsert?: FlightRouteUpsertWithoutFlightBookingsInput
    connect?: FlightRouteWhereUniqueInput
    update?: XOR<XOR<FlightRouteUpdateToOneWithWhereWithoutFlightBookingsInput, FlightRouteUpdateWithoutFlightBookingsInput>, FlightRouteUncheckedUpdateWithoutFlightBookingsInput>
  }

  export type TourActivityJunctionCreateNestedManyWithoutActivityInput = {
    create?: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput> | TourActivityJunctionCreateWithoutActivityInput[] | TourActivityJunctionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutActivityInput | TourActivityJunctionCreateOrConnectWithoutActivityInput[]
    createMany?: TourActivityJunctionCreateManyActivityInputEnvelope
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
  }

  export type BookingActivityCreateNestedManyWithoutActivityInput = {
    create?: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput> | BookingActivityCreateWithoutActivityInput[] | BookingActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutActivityInput | BookingActivityCreateOrConnectWithoutActivityInput[]
    createMany?: BookingActivityCreateManyActivityInputEnvelope
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
  }

  export type TourActivityJunctionUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput> | TourActivityJunctionCreateWithoutActivityInput[] | TourActivityJunctionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutActivityInput | TourActivityJunctionCreateOrConnectWithoutActivityInput[]
    createMany?: TourActivityJunctionCreateManyActivityInputEnvelope
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
  }

  export type BookingActivityUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput> | BookingActivityCreateWithoutActivityInput[] | BookingActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutActivityInput | BookingActivityCreateOrConnectWithoutActivityInput[]
    createMany?: BookingActivityCreateManyActivityInputEnvelope
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
  }

  export type TourActivityJunctionUpdateManyWithoutActivityNestedInput = {
    create?: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput> | TourActivityJunctionCreateWithoutActivityInput[] | TourActivityJunctionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutActivityInput | TourActivityJunctionCreateOrConnectWithoutActivityInput[]
    upsert?: TourActivityJunctionUpsertWithWhereUniqueWithoutActivityInput | TourActivityJunctionUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: TourActivityJunctionCreateManyActivityInputEnvelope
    set?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    disconnect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    delete?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    update?: TourActivityJunctionUpdateWithWhereUniqueWithoutActivityInput | TourActivityJunctionUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: TourActivityJunctionUpdateManyWithWhereWithoutActivityInput | TourActivityJunctionUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
  }

  export type BookingActivityUpdateManyWithoutActivityNestedInput = {
    create?: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput> | BookingActivityCreateWithoutActivityInput[] | BookingActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutActivityInput | BookingActivityCreateOrConnectWithoutActivityInput[]
    upsert?: BookingActivityUpsertWithWhereUniqueWithoutActivityInput | BookingActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: BookingActivityCreateManyActivityInputEnvelope
    set?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    disconnect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    delete?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    update?: BookingActivityUpdateWithWhereUniqueWithoutActivityInput | BookingActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: BookingActivityUpdateManyWithWhereWithoutActivityInput | BookingActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
  }

  export type TourActivityJunctionUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput> | TourActivityJunctionCreateWithoutActivityInput[] | TourActivityJunctionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: TourActivityJunctionCreateOrConnectWithoutActivityInput | TourActivityJunctionCreateOrConnectWithoutActivityInput[]
    upsert?: TourActivityJunctionUpsertWithWhereUniqueWithoutActivityInput | TourActivityJunctionUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: TourActivityJunctionCreateManyActivityInputEnvelope
    set?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    disconnect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    delete?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    connect?: TourActivityJunctionWhereUniqueInput | TourActivityJunctionWhereUniqueInput[]
    update?: TourActivityJunctionUpdateWithWhereUniqueWithoutActivityInput | TourActivityJunctionUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: TourActivityJunctionUpdateManyWithWhereWithoutActivityInput | TourActivityJunctionUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
  }

  export type BookingActivityUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput> | BookingActivityCreateWithoutActivityInput[] | BookingActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: BookingActivityCreateOrConnectWithoutActivityInput | BookingActivityCreateOrConnectWithoutActivityInput[]
    upsert?: BookingActivityUpsertWithWhereUniqueWithoutActivityInput | BookingActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: BookingActivityCreateManyActivityInputEnvelope
    set?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    disconnect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    delete?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    connect?: BookingActivityWhereUniqueInput | BookingActivityWhereUniqueInput[]
    update?: BookingActivityUpdateWithWhereUniqueWithoutActivityInput | BookingActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: BookingActivityUpdateManyWithWhereWithoutActivityInput | BookingActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
  }

  export type TourCreateNestedOneWithoutTourActivitiesInput = {
    create?: XOR<TourCreateWithoutTourActivitiesInput, TourUncheckedCreateWithoutTourActivitiesInput>
    connectOrCreate?: TourCreateOrConnectWithoutTourActivitiesInput
    connect?: TourWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutTourActivitiesInput = {
    create?: XOR<ActivityCreateWithoutTourActivitiesInput, ActivityUncheckedCreateWithoutTourActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutTourActivitiesInput
    connect?: ActivityWhereUniqueInput
  }

  export type TourUpdateOneRequiredWithoutTourActivitiesNestedInput = {
    create?: XOR<TourCreateWithoutTourActivitiesInput, TourUncheckedCreateWithoutTourActivitiesInput>
    connectOrCreate?: TourCreateOrConnectWithoutTourActivitiesInput
    upsert?: TourUpsertWithoutTourActivitiesInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutTourActivitiesInput, TourUpdateWithoutTourActivitiesInput>, TourUncheckedUpdateWithoutTourActivitiesInput>
  }

  export type ActivityUpdateOneRequiredWithoutTourActivitiesNestedInput = {
    create?: XOR<ActivityCreateWithoutTourActivitiesInput, ActivityUncheckedCreateWithoutTourActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutTourActivitiesInput
    upsert?: ActivityUpsertWithoutTourActivitiesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutTourActivitiesInput, ActivityUpdateWithoutTourActivitiesInput>, ActivityUncheckedUpdateWithoutTourActivitiesInput>
  }

  export type InterestCreateexperiencesInput = {
    set: string[]
  }

  export type InterestUpdateexperiencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FlightCreatefeaturesInput = {
    set: string[]
  }

  export type FlightUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourCreateNestedOneWithoutTourFestivalsInput = {
    create?: XOR<TourCreateWithoutTourFestivalsInput, TourUncheckedCreateWithoutTourFestivalsInput>
    connectOrCreate?: TourCreateOrConnectWithoutTourFestivalsInput
    connect?: TourWhereUniqueInput
  }

  export type FestivalCreateNestedOneWithoutTourFestivalsInput = {
    create?: XOR<FestivalCreateWithoutTourFestivalsInput, FestivalUncheckedCreateWithoutTourFestivalsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutTourFestivalsInput
    connect?: FestivalWhereUniqueInput
  }

  export type TourUpdateOneRequiredWithoutTourFestivalsNestedInput = {
    create?: XOR<TourCreateWithoutTourFestivalsInput, TourUncheckedCreateWithoutTourFestivalsInput>
    connectOrCreate?: TourCreateOrConnectWithoutTourFestivalsInput
    upsert?: TourUpsertWithoutTourFestivalsInput
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutTourFestivalsInput, TourUpdateWithoutTourFestivalsInput>, TourUncheckedUpdateWithoutTourFestivalsInput>
  }

  export type FestivalUpdateOneRequiredWithoutTourFestivalsNestedInput = {
    create?: XOR<FestivalCreateWithoutTourFestivalsInput, FestivalUncheckedCreateWithoutTourFestivalsInput>
    connectOrCreate?: FestivalCreateOrConnectWithoutTourFestivalsInput
    upsert?: FestivalUpsertWithoutTourFestivalsInput
    connect?: FestivalWhereUniqueInput
    update?: XOR<XOR<FestivalUpdateToOneWithWhereWithoutTourFestivalsInput, FestivalUpdateWithoutTourFestivalsInput>, FestivalUncheckedUpdateWithoutTourFestivalsInput>
  }

  export type ChatMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type ChatSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatSessionUpsertWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutMessagesInput, ChatSessionUpdateWithoutMessagesInput>, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BookingCreateWithoutTourInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    activities?: BookingActivityCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTourInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    activities?: BookingActivityUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTourInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput>
  }

  export type BookingCreateManyTourInputEnvelope = {
    data: BookingCreateManyTourInput | BookingCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutTourInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutTourInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput>
  }

  export type ItineraryCreateManyTourInputEnvelope = {
    data: ItineraryCreateManyTourInput | ItineraryCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type TourOperatorCreateWithoutToursInput = {
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorUncheckedCreateWithoutToursInput = {
    id?: number
    name: string
    website: string
    description: string
    bestFeature: string
    specialties?: TourOperatorCreatespecialtiesInput | string[]
    rating?: number
    reviewCount?: number
    logoUrl?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    isActive?: boolean
    establishedYear?: number | null
    certifications?: TourOperatorCreatecertificationsInput | string[]
    awards?: TourOperatorCreateawardsInput | string[]
    createdAt?: Date | string
  }

  export type TourOperatorCreateOrConnectWithoutToursInput = {
    where: TourOperatorWhereUniqueInput
    create: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
  }

  export type UserFeedbackCreateWithoutTourInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutTourInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput>
  }

  export type UserFeedbackCreateManyTourInputEnvelope = {
    data: UserFeedbackCreateManyTourInput | UserFeedbackCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type TourFestivalCreateWithoutTourInput = {
    festival: FestivalCreateNestedOneWithoutTourFestivalsInput
  }

  export type TourFestivalUncheckedCreateWithoutTourInput = {
    id?: number
    festivalId: number
  }

  export type TourFestivalCreateOrConnectWithoutTourInput = {
    where: TourFestivalWhereUniqueInput
    create: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput>
  }

  export type TourFestivalCreateManyTourInputEnvelope = {
    data: TourFestivalCreateManyTourInput | TourFestivalCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type TourActivityJunctionCreateWithoutTourInput = {
    included?: boolean
    optional?: boolean
    activity: ActivityCreateNestedOneWithoutTourActivitiesInput
  }

  export type TourActivityJunctionUncheckedCreateWithoutTourInput = {
    activityId: number
    included?: boolean
    optional?: boolean
  }

  export type TourActivityJunctionCreateOrConnectWithoutTourInput = {
    where: TourActivityJunctionWhereUniqueInput
    create: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput>
  }

  export type TourActivityJunctionCreateManyTourInputEnvelope = {
    data: TourActivityJunctionCreateManyTourInput | TourActivityJunctionCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutTourInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTourInput, BookingUncheckedUpdateWithoutTourInput>
    create: XOR<BookingCreateWithoutTourInput, BookingUncheckedCreateWithoutTourInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTourInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTourInput, BookingUncheckedUpdateWithoutTourInput>
  }

  export type BookingUpdateManyWithWhereWithoutTourInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTourInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    tourId?: IntFilter<"Booking"> | number
    firstName?: StringFilter<"Booking"> | string
    lastName?: StringFilter<"Booking"> | string
    email?: StringFilter<"Booking"> | string
    phone?: StringNullableFilter<"Booking"> | string | null
    travelDate?: StringFilter<"Booking"> | string
    groupSize?: IntFilter<"Booking"> | number
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ItineraryUpsertWithWhereUniqueWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutTourInput, ItineraryUncheckedUpdateWithoutTourInput>
    create: XOR<ItineraryCreateWithoutTourInput, ItineraryUncheckedCreateWithoutTourInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutTourInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutTourInput, ItineraryUncheckedUpdateWithoutTourInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutTourInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutTourInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    OR?: ItineraryScalarWhereInput[]
    NOT?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    id?: IntFilter<"Itinerary"> | number
    tourId?: IntFilter<"Itinerary"> | number
    name?: StringFilter<"Itinerary"> | string
    description?: StringNullableFilter<"Itinerary"> | string | null
    startDate?: DateTimeFilter<"Itinerary"> | Date | string
    endDate?: DateTimeFilter<"Itinerary"> | Date | string
    guideId?: IntNullableFilter<"Itinerary"> | number | null
    driverId?: IntNullableFilter<"Itinerary"> | number | null
    maxParticipants?: IntFilter<"Itinerary"> | number
    currentParticipants?: IntFilter<"Itinerary"> | number
    status?: StringFilter<"Itinerary"> | string
    createdAt?: DateTimeFilter<"Itinerary"> | Date | string
  }

  export type TourOperatorUpsertWithoutToursInput = {
    update: XOR<TourOperatorUpdateWithoutToursInput, TourOperatorUncheckedUpdateWithoutToursInput>
    create: XOR<TourOperatorCreateWithoutToursInput, TourOperatorUncheckedCreateWithoutToursInput>
    where?: TourOperatorWhereInput
  }

  export type TourOperatorUpdateToOneWithWhereWithoutToursInput = {
    where?: TourOperatorWhereInput
    data: XOR<TourOperatorUpdateWithoutToursInput, TourOperatorUncheckedUpdateWithoutToursInput>
  }

  export type TourOperatorUpdateWithoutToursInput = {
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourOperatorUncheckedUpdateWithoutToursInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bestFeature?: StringFieldUpdateOperationsInput | string
    specialties?: TourOperatorUpdatespecialtiesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    certifications?: TourOperatorUpdatecertificationsInput | string[]
    awards?: TourOperatorUpdateawardsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutTourInput, UserFeedbackUncheckedUpdateWithoutTourInput>
    create: XOR<UserFeedbackCreateWithoutTourInput, UserFeedbackUncheckedCreateWithoutTourInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutTourInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutTourInput, UserFeedbackUncheckedUpdateWithoutTourInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutTourInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutTourInput>
  }

  export type UserFeedbackScalarWhereInput = {
    AND?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
    OR?: UserFeedbackScalarWhereInput[]
    NOT?: UserFeedbackScalarWhereInput | UserFeedbackScalarWhereInput[]
    id?: IntFilter<"UserFeedback"> | number
    userId?: IntFilter<"UserFeedback"> | number
    itineraryId?: IntNullableFilter<"UserFeedback"> | number | null
    tourId?: IntNullableFilter<"UserFeedback"> | number | null
    rating?: IntFilter<"UserFeedback"> | number
    comment?: StringNullableFilter<"UserFeedback"> | string | null
    category?: StringFilter<"UserFeedback"> | string
    isPublic?: BoolFilter<"UserFeedback"> | boolean
    createdAt?: DateTimeFilter<"UserFeedback"> | Date | string
  }

  export type TourFestivalUpsertWithWhereUniqueWithoutTourInput = {
    where: TourFestivalWhereUniqueInput
    update: XOR<TourFestivalUpdateWithoutTourInput, TourFestivalUncheckedUpdateWithoutTourInput>
    create: XOR<TourFestivalCreateWithoutTourInput, TourFestivalUncheckedCreateWithoutTourInput>
  }

  export type TourFestivalUpdateWithWhereUniqueWithoutTourInput = {
    where: TourFestivalWhereUniqueInput
    data: XOR<TourFestivalUpdateWithoutTourInput, TourFestivalUncheckedUpdateWithoutTourInput>
  }

  export type TourFestivalUpdateManyWithWhereWithoutTourInput = {
    where: TourFestivalScalarWhereInput
    data: XOR<TourFestivalUpdateManyMutationInput, TourFestivalUncheckedUpdateManyWithoutTourInput>
  }

  export type TourFestivalScalarWhereInput = {
    AND?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
    OR?: TourFestivalScalarWhereInput[]
    NOT?: TourFestivalScalarWhereInput | TourFestivalScalarWhereInput[]
    id?: IntFilter<"TourFestival"> | number
    tourId?: IntFilter<"TourFestival"> | number
    festivalId?: IntFilter<"TourFestival"> | number
  }

  export type TourActivityJunctionUpsertWithWhereUniqueWithoutTourInput = {
    where: TourActivityJunctionWhereUniqueInput
    update: XOR<TourActivityJunctionUpdateWithoutTourInput, TourActivityJunctionUncheckedUpdateWithoutTourInput>
    create: XOR<TourActivityJunctionCreateWithoutTourInput, TourActivityJunctionUncheckedCreateWithoutTourInput>
  }

  export type TourActivityJunctionUpdateWithWhereUniqueWithoutTourInput = {
    where: TourActivityJunctionWhereUniqueInput
    data: XOR<TourActivityJunctionUpdateWithoutTourInput, TourActivityJunctionUncheckedUpdateWithoutTourInput>
  }

  export type TourActivityJunctionUpdateManyWithWhereWithoutTourInput = {
    where: TourActivityJunctionScalarWhereInput
    data: XOR<TourActivityJunctionUpdateManyMutationInput, TourActivityJunctionUncheckedUpdateManyWithoutTourInput>
  }

  export type TourActivityJunctionScalarWhereInput = {
    AND?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
    OR?: TourActivityJunctionScalarWhereInput[]
    NOT?: TourActivityJunctionScalarWhereInput | TourActivityJunctionScalarWhereInput[]
    tourId?: IntFilter<"TourActivityJunction"> | number
    activityId?: IntFilter<"TourActivityJunction"> | number
    included?: BoolFilter<"TourActivityJunction"> | boolean
    optional?: BoolFilter<"TourActivityJunction"> | boolean
  }

  export type TourCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutBookingsInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
  }

  export type BookingActivityCreateWithoutBookingInput = {
    activity: ActivityCreateNestedOneWithoutBookingActivitiesInput
  }

  export type BookingActivityUncheckedCreateWithoutBookingInput = {
    activityId: number
  }

  export type BookingActivityCreateOrConnectWithoutBookingInput = {
    where: BookingActivityWhereUniqueInput
    create: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput>
  }

  export type BookingActivityCreateManyBookingInputEnvelope = {
    data: BookingActivityCreateManyBookingInput | BookingActivityCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithoutBookingsInput = {
    update: XOR<TourUpdateWithoutBookingsInput, TourUncheckedUpdateWithoutBookingsInput>
    create: XOR<TourCreateWithoutBookingsInput, TourUncheckedCreateWithoutBookingsInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutBookingsInput, TourUncheckedUpdateWithoutBookingsInput>
  }

  export type TourUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type BookingActivityUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingActivityWhereUniqueInput
    update: XOR<BookingActivityUpdateWithoutBookingInput, BookingActivityUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingActivityCreateWithoutBookingInput, BookingActivityUncheckedCreateWithoutBookingInput>
  }

  export type BookingActivityUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingActivityWhereUniqueInput
    data: XOR<BookingActivityUpdateWithoutBookingInput, BookingActivityUncheckedUpdateWithoutBookingInput>
  }

  export type BookingActivityUpdateManyWithWhereWithoutBookingInput = {
    where: BookingActivityScalarWhereInput
    data: XOR<BookingActivityUpdateManyMutationInput, BookingActivityUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingActivityScalarWhereInput = {
    AND?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
    OR?: BookingActivityScalarWhereInput[]
    NOT?: BookingActivityScalarWhereInput | BookingActivityScalarWhereInput[]
    bookingId?: IntFilter<"BookingActivity"> | number
    activityId?: IntFilter<"BookingActivity"> | number
  }

  export type ItineraryCreateWithoutGuideInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutGuideInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput>
  }

  export type ItineraryCreateManyGuideInputEnvelope = {
    data: ItineraryCreateManyGuideInput | ItineraryCreateManyGuideInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutDriverInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutDriverInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput>
  }

  export type ItineraryCreateManyDriverInputEnvelope = {
    data: ItineraryCreateManyDriverInput | ItineraryCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryUpsertWithWhereUniqueWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutGuideInput, ItineraryUncheckedUpdateWithoutGuideInput>
    create: XOR<ItineraryCreateWithoutGuideInput, ItineraryUncheckedCreateWithoutGuideInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutGuideInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutGuideInput, ItineraryUncheckedUpdateWithoutGuideInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutGuideInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutGuideInput>
  }

  export type ItineraryUpsertWithWhereUniqueWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutDriverInput, ItineraryUncheckedUpdateWithoutDriverInput>
    create: XOR<ItineraryCreateWithoutDriverInput, ItineraryUncheckedCreateWithoutDriverInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutDriverInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutDriverInput, ItineraryUncheckedUpdateWithoutDriverInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutDriverInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutDriverInput>
  }

  export type TourCreateWithoutItinerariesInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutItinerariesInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutItinerariesInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
  }

  export type GuideCreateWithoutGuidedItinerariesInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    drivenItineraries?: ItineraryCreateNestedManyWithoutDriverInput
  }

  export type GuideUncheckedCreateWithoutGuidedItinerariesInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    drivenItineraries?: ItineraryUncheckedCreateNestedManyWithoutDriverInput
  }

  export type GuideCreateOrConnectWithoutGuidedItinerariesInput = {
    where: GuideWhereUniqueInput
    create: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
  }

  export type GuideCreateWithoutDrivenItinerariesInput = {
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryCreateNestedManyWithoutGuideInput
  }

  export type GuideUncheckedCreateWithoutDrivenItinerariesInput = {
    id?: number
    name: string
    email: string
    phone: string
    licenseImageUrl: string
    registrationType: string
    specializations?: GuideCreatespecializationsInput | string[]
    status?: string
    createdAt?: Date | string
    guidedItineraries?: ItineraryUncheckedCreateNestedManyWithoutGuideInput
  }

  export type GuideCreateOrConnectWithoutDrivenItinerariesInput = {
    where: GuideWhereUniqueInput
    create: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
  }

  export type ItineraryDayCreateWithoutItineraryInput = {
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayUncheckedCreateWithoutItineraryInput = {
    id?: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type ItineraryDayCreateOrConnectWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    create: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput>
  }

  export type ItineraryDayCreateManyItineraryInputEnvelope = {
    data: ItineraryDayCreateManyItineraryInput | ItineraryDayCreateManyItineraryInput[]
    skipDuplicates?: boolean
  }

  export type CustomTourRequestCreateWithoutAssignedItineraryInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
    interests?: CustomTourInterestCreateNestedManyWithoutCustomTourRequestInput
  }

  export type CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
    interests?: CustomTourInterestUncheckedCreateNestedManyWithoutCustomTourRequestInput
  }

  export type CustomTourRequestCreateOrConnectWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    create: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestCreateManyAssignedItineraryInputEnvelope = {
    data: CustomTourRequestCreateManyAssignedItineraryInput | CustomTourRequestCreateManyAssignedItineraryInput[]
    skipDuplicates?: boolean
  }

  export type UserFeedbackCreateWithoutItineraryInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    user: UserAccountCreateNestedOneWithoutFeedbacksInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutItineraryInput = {
    id?: number
    userId: number
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput>
  }

  export type UserFeedbackCreateManyItineraryInputEnvelope = {
    data: UserFeedbackCreateManyItineraryInput | UserFeedbackCreateManyItineraryInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithoutItinerariesInput = {
    update: XOR<TourUpdateWithoutItinerariesInput, TourUncheckedUpdateWithoutItinerariesInput>
    create: XOR<TourCreateWithoutItinerariesInput, TourUncheckedCreateWithoutItinerariesInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutItinerariesInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutItinerariesInput, TourUncheckedUpdateWithoutItinerariesInput>
  }

  export type TourUpdateWithoutItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type GuideUpsertWithoutGuidedItinerariesInput = {
    update: XOR<GuideUpdateWithoutGuidedItinerariesInput, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
    create: XOR<GuideCreateWithoutGuidedItinerariesInput, GuideUncheckedCreateWithoutGuidedItinerariesInput>
    where?: GuideWhereInput
  }

  export type GuideUpdateToOneWithWhereWithoutGuidedItinerariesInput = {
    where?: GuideWhereInput
    data: XOR<GuideUpdateWithoutGuidedItinerariesInput, GuideUncheckedUpdateWithoutGuidedItinerariesInput>
  }

  export type GuideUpdateWithoutGuidedItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivenItineraries?: ItineraryUpdateManyWithoutDriverNestedInput
  }

  export type GuideUncheckedUpdateWithoutGuidedItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivenItineraries?: ItineraryUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type GuideUpsertWithoutDrivenItinerariesInput = {
    update: XOR<GuideUpdateWithoutDrivenItinerariesInput, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
    create: XOR<GuideCreateWithoutDrivenItinerariesInput, GuideUncheckedCreateWithoutDrivenItinerariesInput>
    where?: GuideWhereInput
  }

  export type GuideUpdateToOneWithWhereWithoutDrivenItinerariesInput = {
    where?: GuideWhereInput
    data: XOR<GuideUpdateWithoutDrivenItinerariesInput, GuideUncheckedUpdateWithoutDrivenItinerariesInput>
  }

  export type GuideUpdateWithoutDrivenItinerariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUpdateManyWithoutGuideNestedInput
  }

  export type GuideUncheckedUpdateWithoutDrivenItinerariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    licenseImageUrl?: StringFieldUpdateOperationsInput | string
    registrationType?: StringFieldUpdateOperationsInput | string
    specializations?: GuideUpdatespecializationsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guidedItineraries?: ItineraryUncheckedUpdateManyWithoutGuideNestedInput
  }

  export type ItineraryDayUpsertWithWhereUniqueWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    update: XOR<ItineraryDayUpdateWithoutItineraryInput, ItineraryDayUncheckedUpdateWithoutItineraryInput>
    create: XOR<ItineraryDayCreateWithoutItineraryInput, ItineraryDayUncheckedCreateWithoutItineraryInput>
  }

  export type ItineraryDayUpdateWithWhereUniqueWithoutItineraryInput = {
    where: ItineraryDayWhereUniqueInput
    data: XOR<ItineraryDayUpdateWithoutItineraryInput, ItineraryDayUncheckedUpdateWithoutItineraryInput>
  }

  export type ItineraryDayUpdateManyWithWhereWithoutItineraryInput = {
    where: ItineraryDayScalarWhereInput
    data: XOR<ItineraryDayUpdateManyMutationInput, ItineraryDayUncheckedUpdateManyWithoutItineraryInput>
  }

  export type ItineraryDayScalarWhereInput = {
    AND?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
    OR?: ItineraryDayScalarWhereInput[]
    NOT?: ItineraryDayScalarWhereInput | ItineraryDayScalarWhereInput[]
    id?: IntFilter<"ItineraryDay"> | number
    itineraryId?: IntFilter<"ItineraryDay"> | number
    dayNumber?: IntFilter<"ItineraryDay"> | number
    title?: StringFilter<"ItineraryDay"> | string
    description?: StringFilter<"ItineraryDay"> | string
    activities?: StringNullableListFilter<"ItineraryDay">
    accommodation?: StringNullableFilter<"ItineraryDay"> | string | null
    meals?: StringNullableListFilter<"ItineraryDay">
    transportation?: StringNullableFilter<"ItineraryDay"> | string | null
    notes?: StringNullableFilter<"ItineraryDay"> | string | null
  }

  export type CustomTourRequestUpsertWithWhereUniqueWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    update: XOR<CustomTourRequestUpdateWithoutAssignedItineraryInput, CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput>
    create: XOR<CustomTourRequestCreateWithoutAssignedItineraryInput, CustomTourRequestUncheckedCreateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestUpdateWithWhereUniqueWithoutAssignedItineraryInput = {
    where: CustomTourRequestWhereUniqueInput
    data: XOR<CustomTourRequestUpdateWithoutAssignedItineraryInput, CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestUpdateManyWithWhereWithoutAssignedItineraryInput = {
    where: CustomTourRequestScalarWhereInput
    data: XOR<CustomTourRequestUpdateManyMutationInput, CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryInput>
  }

  export type CustomTourRequestScalarWhereInput = {
    AND?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
    OR?: CustomTourRequestScalarWhereInput[]
    NOT?: CustomTourRequestScalarWhereInput | CustomTourRequestScalarWhereInput[]
    id?: IntFilter<"CustomTourRequest"> | number
    firstName?: StringFilter<"CustomTourRequest"> | string
    lastName?: StringFilter<"CustomTourRequest"> | string
    email?: StringFilter<"CustomTourRequest"> | string
    phone?: StringNullableFilter<"CustomTourRequest"> | string | null
    duration?: IntFilter<"CustomTourRequest"> | number
    groupSize?: IntFilter<"CustomTourRequest"> | number
    budget?: IntNullableFilter<"CustomTourRequest"> | number | null
    preferredDates?: StringNullableFilter<"CustomTourRequest"> | string | null
    specialRequirements?: StringNullableFilter<"CustomTourRequest"> | string | null
    destinations?: StringNullableListFilter<"CustomTourRequest">
    accommodationType?: StringNullableFilter<"CustomTourRequest"> | string | null
    transportPreference?: StringNullableFilter<"CustomTourRequest"> | string | null
    status?: StringFilter<"CustomTourRequest"> | string
    adminNotes?: StringNullableFilter<"CustomTourRequest"> | string | null
    estimatedPrice?: IntNullableFilter<"CustomTourRequest"> | number | null
    assignedItineraryId?: IntNullableFilter<"CustomTourRequest"> | number | null
    createdAt?: DateTimeFilter<"CustomTourRequest"> | Date | string
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutItineraryInput, UserFeedbackUncheckedUpdateWithoutItineraryInput>
    create: XOR<UserFeedbackCreateWithoutItineraryInput, UserFeedbackUncheckedCreateWithoutItineraryInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutItineraryInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutItineraryInput, UserFeedbackUncheckedUpdateWithoutItineraryInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutItineraryInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutItineraryInput>
  }

  export type ItineraryCreateWithoutDaysInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutDaysInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutDaysInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
  }

  export type ItineraryUpsertWithoutDaysInput = {
    update: XOR<ItineraryUpdateWithoutDaysInput, ItineraryUncheckedUpdateWithoutDaysInput>
    create: XOR<ItineraryCreateWithoutDaysInput, ItineraryUncheckedCreateWithoutDaysInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutDaysInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutDaysInput, ItineraryUncheckedUpdateWithoutDaysInput>
  }

  export type ItineraryUpdateWithoutDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutDaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateWithoutAssignedCustomTourRequestsInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    UserFeedback?: UserFeedbackCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    UserFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutAssignedCustomTourRequestsInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
  }

  export type CustomTourInterestCreateWithoutCustomTourRequestInput = {
    interest: TravelInterestCreateNestedOneWithoutCustomTourInterestsInput
  }

  export type CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput = {
    interestId: string
  }

  export type CustomTourInterestCreateOrConnectWithoutCustomTourRequestInput = {
    where: CustomTourInterestWhereUniqueInput
    create: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput>
  }

  export type CustomTourInterestCreateManyCustomTourRequestInputEnvelope = {
    data: CustomTourInterestCreateManyCustomTourRequestInput | CustomTourInterestCreateManyCustomTourRequestInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryUpsertWithoutAssignedCustomTourRequestsInput = {
    update: XOR<ItineraryUpdateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
    create: XOR<ItineraryCreateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedCreateWithoutAssignedCustomTourRequestsInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutAssignedCustomTourRequestsInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutAssignedCustomTourRequestsInput, ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput>
  }

  export type ItineraryUpdateWithoutAssignedCustomTourRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutAssignedCustomTourRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type CustomTourInterestUpsertWithWhereUniqueWithoutCustomTourRequestInput = {
    where: CustomTourInterestWhereUniqueInput
    update: XOR<CustomTourInterestUpdateWithoutCustomTourRequestInput, CustomTourInterestUncheckedUpdateWithoutCustomTourRequestInput>
    create: XOR<CustomTourInterestCreateWithoutCustomTourRequestInput, CustomTourInterestUncheckedCreateWithoutCustomTourRequestInput>
  }

  export type CustomTourInterestUpdateWithWhereUniqueWithoutCustomTourRequestInput = {
    where: CustomTourInterestWhereUniqueInput
    data: XOR<CustomTourInterestUpdateWithoutCustomTourRequestInput, CustomTourInterestUncheckedUpdateWithoutCustomTourRequestInput>
  }

  export type CustomTourInterestUpdateManyWithWhereWithoutCustomTourRequestInput = {
    where: CustomTourInterestScalarWhereInput
    data: XOR<CustomTourInterestUpdateManyMutationInput, CustomTourInterestUncheckedUpdateManyWithoutCustomTourRequestInput>
  }

  export type CustomTourInterestScalarWhereInput = {
    AND?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
    OR?: CustomTourInterestScalarWhereInput[]
    NOT?: CustomTourInterestScalarWhereInput | CustomTourInterestScalarWhereInput[]
    customTourRequestId?: IntFilter<"CustomTourInterest"> | number
    interestId?: StringFilter<"CustomTourInterest"> | string
  }

  export type TourCreateWithoutTourOperatorInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutTourOperatorInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput>
  }

  export type TourCreateManyTourOperatorInputEnvelope = {
    data: TourCreateManyTourOperatorInput | TourCreateManyTourOperatorInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithWhereUniqueWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutTourOperatorInput, TourUncheckedUpdateWithoutTourOperatorInput>
    create: XOR<TourCreateWithoutTourOperatorInput, TourUncheckedCreateWithoutTourOperatorInput>
  }

  export type TourUpdateWithWhereUniqueWithoutTourOperatorInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutTourOperatorInput, TourUncheckedUpdateWithoutTourOperatorInput>
  }

  export type TourUpdateManyWithWhereWithoutTourOperatorInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutTourOperatorInput>
  }

  export type TourScalarWhereInput = {
    AND?: TourScalarWhereInput | TourScalarWhereInput[]
    OR?: TourScalarWhereInput[]
    NOT?: TourScalarWhereInput | TourScalarWhereInput[]
    id?: IntFilter<"Tour"> | number
    name?: StringFilter<"Tour"> | string
    description?: StringNullableFilter<"Tour"> | string | null
    duration?: StringFilter<"Tour"> | string
    price?: FloatFilter<"Tour"> | number
    maxPrice?: FloatNullableFilter<"Tour"> | number | null
    categoryName?: StringFilter<"Tour"> | string
    difficulty?: StringNullableFilter<"Tour"> | string | null
    groupSize?: StringNullableFilter<"Tour"> | string | null
    imageUrl?: StringNullableFilter<"Tour"> | string | null
    highlights?: StringNullableListFilter<"Tour">
    includes?: StringNullableListFilter<"Tour">
    excludes?: StringNullableListFilter<"Tour">
    itinerary?: StringNullableFilter<"Tour"> | string | null
    bestTime?: StringNullableListFilter<"Tour">
    physicalRating?: StringNullableFilter<"Tour"> | string | null
    culturalLevel?: StringNullableFilter<"Tour"> | string | null
    luxuryLevel?: StringNullableFilter<"Tour"> | string | null
    spiritualLevel?: StringNullableFilter<"Tour"> | string | null
    rating?: FloatFilter<"Tour"> | number
    isActive?: BoolFilter<"Tour"> | boolean
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    tourOperatorId?: IntNullableFilter<"Tour"> | number | null
  }

  export type TourFestivalCreateWithoutFestivalInput = {
    tour: TourCreateNestedOneWithoutTourFestivalsInput
  }

  export type TourFestivalUncheckedCreateWithoutFestivalInput = {
    id?: number
    tourId: number
  }

  export type TourFestivalCreateOrConnectWithoutFestivalInput = {
    where: TourFestivalWhereUniqueInput
    create: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput>
  }

  export type TourFestivalCreateManyFestivalInputEnvelope = {
    data: TourFestivalCreateManyFestivalInput | TourFestivalCreateManyFestivalInput[]
    skipDuplicates?: boolean
  }

  export type FestivalBookingCreateWithoutFestivalInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingUncheckedCreateWithoutFestivalInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type FestivalBookingCreateOrConnectWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    create: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput>
  }

  export type FestivalBookingCreateManyFestivalInputEnvelope = {
    data: FestivalBookingCreateManyFestivalInput | FestivalBookingCreateManyFestivalInput[]
    skipDuplicates?: boolean
  }

  export type TourFestivalUpsertWithWhereUniqueWithoutFestivalInput = {
    where: TourFestivalWhereUniqueInput
    update: XOR<TourFestivalUpdateWithoutFestivalInput, TourFestivalUncheckedUpdateWithoutFestivalInput>
    create: XOR<TourFestivalCreateWithoutFestivalInput, TourFestivalUncheckedCreateWithoutFestivalInput>
  }

  export type TourFestivalUpdateWithWhereUniqueWithoutFestivalInput = {
    where: TourFestivalWhereUniqueInput
    data: XOR<TourFestivalUpdateWithoutFestivalInput, TourFestivalUncheckedUpdateWithoutFestivalInput>
  }

  export type TourFestivalUpdateManyWithWhereWithoutFestivalInput = {
    where: TourFestivalScalarWhereInput
    data: XOR<TourFestivalUpdateManyMutationInput, TourFestivalUncheckedUpdateManyWithoutFestivalInput>
  }

  export type FestivalBookingUpsertWithWhereUniqueWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    update: XOR<FestivalBookingUpdateWithoutFestivalInput, FestivalBookingUncheckedUpdateWithoutFestivalInput>
    create: XOR<FestivalBookingCreateWithoutFestivalInput, FestivalBookingUncheckedCreateWithoutFestivalInput>
  }

  export type FestivalBookingUpdateWithWhereUniqueWithoutFestivalInput = {
    where: FestivalBookingWhereUniqueInput
    data: XOR<FestivalBookingUpdateWithoutFestivalInput, FestivalBookingUncheckedUpdateWithoutFestivalInput>
  }

  export type FestivalBookingUpdateManyWithWhereWithoutFestivalInput = {
    where: FestivalBookingScalarWhereInput
    data: XOR<FestivalBookingUpdateManyMutationInput, FestivalBookingUncheckedUpdateManyWithoutFestivalInput>
  }

  export type FestivalBookingScalarWhereInput = {
    AND?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
    OR?: FestivalBookingScalarWhereInput[]
    NOT?: FestivalBookingScalarWhereInput | FestivalBookingScalarWhereInput[]
    id?: IntFilter<"FestivalBooking"> | number
    festivalId?: IntFilter<"FestivalBooking"> | number
    firstName?: StringFilter<"FestivalBooking"> | string
    lastName?: StringFilter<"FestivalBooking"> | string
    email?: StringFilter<"FestivalBooking"> | string
    phone?: StringNullableFilter<"FestivalBooking"> | string | null
    numberOfTickets?: IntFilter<"FestivalBooking"> | number
    totalAmount?: IntFilter<"FestivalBooking"> | number
    specialRequests?: StringNullableFilter<"FestivalBooking"> | string | null
    status?: StringFilter<"FestivalBooking"> | string
    createdAt?: DateTimeFilter<"FestivalBooking"> | Date | string
  }

  export type FestivalCreateWithoutFestivalBookingsInput = {
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourFestivals?: TourFestivalCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUncheckedCreateWithoutFestivalBookingsInput = {
    id?: number
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutFestivalInput
  }

  export type FestivalCreateOrConnectWithoutFestivalBookingsInput = {
    where: FestivalWhereUniqueInput
    create: XOR<FestivalCreateWithoutFestivalBookingsInput, FestivalUncheckedCreateWithoutFestivalBookingsInput>
  }

  export type FestivalUpsertWithoutFestivalBookingsInput = {
    update: XOR<FestivalUpdateWithoutFestivalBookingsInput, FestivalUncheckedUpdateWithoutFestivalBookingsInput>
    create: XOR<FestivalCreateWithoutFestivalBookingsInput, FestivalUncheckedCreateWithoutFestivalBookingsInput>
    where?: FestivalWhereInput
  }

  export type FestivalUpdateToOneWithWhereWithoutFestivalBookingsInput = {
    where?: FestivalWhereInput
    data: XOR<FestivalUpdateWithoutFestivalBookingsInput, FestivalUncheckedUpdateWithoutFestivalBookingsInput>
  }

  export type FestivalUpdateWithoutFestivalBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourFestivals?: TourFestivalUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalUncheckedUpdateWithoutFestivalBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutFestivalNestedInput
  }

  export type HotelCategoryCreateWithoutHotelsInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type HotelCategoryUncheckedCreateWithoutHotelsInput = {
    id: string
    name: string
    icon: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
  }

  export type HotelCategoryCreateOrConnectWithoutHotelsInput = {
    where: HotelCategoryWhereUniqueInput
    create: XOR<HotelCategoryCreateWithoutHotelsInput, HotelCategoryUncheckedCreateWithoutHotelsInput>
  }

  export type HotelRoomCreateWithoutHotelInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomUncheckedCreateWithoutHotelInput = {
    id?: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type HotelRoomCreateOrConnectWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    create: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput>
  }

  export type HotelRoomCreateManyHotelInputEnvelope = {
    data: HotelRoomCreateManyHotelInput | HotelRoomCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelBookingCreateWithoutHotelInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    room: HotelRoomCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutHotelInput = {
    id?: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingCreateOrConnectWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput>
  }

  export type HotelBookingCreateManyHotelInputEnvelope = {
    data: HotelBookingCreateManyHotelInput | HotelBookingCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelCategoryUpsertWithoutHotelsInput = {
    update: XOR<HotelCategoryUpdateWithoutHotelsInput, HotelCategoryUncheckedUpdateWithoutHotelsInput>
    create: XOR<HotelCategoryCreateWithoutHotelsInput, HotelCategoryUncheckedCreateWithoutHotelsInput>
    where?: HotelCategoryWhereInput
  }

  export type HotelCategoryUpdateToOneWithWhereWithoutHotelsInput = {
    where?: HotelCategoryWhereInput
    data: XOR<HotelCategoryUpdateWithoutHotelsInput, HotelCategoryUncheckedUpdateWithoutHotelsInput>
  }

  export type HotelCategoryUpdateWithoutHotelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelCategoryUncheckedUpdateWithoutHotelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HotelRoomUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    update: XOR<HotelRoomUpdateWithoutHotelInput, HotelRoomUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelRoomCreateWithoutHotelInput, HotelRoomUncheckedCreateWithoutHotelInput>
  }

  export type HotelRoomUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelRoomWhereUniqueInput
    data: XOR<HotelRoomUpdateWithoutHotelInput, HotelRoomUncheckedUpdateWithoutHotelInput>
  }

  export type HotelRoomUpdateManyWithWhereWithoutHotelInput = {
    where: HotelRoomScalarWhereInput
    data: XOR<HotelRoomUpdateManyMutationInput, HotelRoomUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelRoomScalarWhereInput = {
    AND?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
    OR?: HotelRoomScalarWhereInput[]
    NOT?: HotelRoomScalarWhereInput | HotelRoomScalarWhereInput[]
    id?: IntFilter<"HotelRoom"> | number
    hotelId?: IntFilter<"HotelRoom"> | number
    roomType?: StringFilter<"HotelRoom"> | string
    roomName?: StringFilter<"HotelRoom"> | string
    description?: StringFilter<"HotelRoom"> | string
    imageUrl?: StringFilter<"HotelRoom"> | string
    images?: StringNullableListFilter<"HotelRoom">
    maxOccupancy?: IntFilter<"HotelRoom"> | number
    bedType?: StringFilter<"HotelRoom"> | string
    roomSize?: StringNullableFilter<"HotelRoom"> | string | null
    amenities?: StringNullableListFilter<"HotelRoom">
    pricePerNight?: IntFilter<"HotelRoom"> | number
    totalRooms?: IntFilter<"HotelRoom"> | number
    isActive?: BoolFilter<"HotelRoom"> | boolean
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutHotelInput, HotelBookingUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelBookingCreateWithoutHotelInput, HotelBookingUncheckedCreateWithoutHotelInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutHotelInput, HotelBookingUncheckedUpdateWithoutHotelInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutHotelInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelBookingScalarWhereInput = {
    AND?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    OR?: HotelBookingScalarWhereInput[]
    NOT?: HotelBookingScalarWhereInput | HotelBookingScalarWhereInput[]
    id?: IntFilter<"HotelBooking"> | number
    hotelId?: IntFilter<"HotelBooking"> | number
    roomId?: IntFilter<"HotelBooking"> | number
    firstName?: StringFilter<"HotelBooking"> | string
    lastName?: StringFilter<"HotelBooking"> | string
    email?: StringFilter<"HotelBooking"> | string
    phone?: StringNullableFilter<"HotelBooking"> | string | null
    checkInDate?: DateTimeFilter<"HotelBooking"> | Date | string
    checkOutDate?: DateTimeFilter<"HotelBooking"> | Date | string
    numberOfRooms?: IntFilter<"HotelBooking"> | number
    numberOfGuests?: IntFilter<"HotelBooking"> | number
    totalAmount?: IntFilter<"HotelBooking"> | number
    specialRequests?: StringNullableFilter<"HotelBooking"> | string | null
    status?: StringFilter<"HotelBooking"> | string
    paymentStatus?: StringFilter<"HotelBooking"> | string
    createdAt?: DateTimeFilter<"HotelBooking"> | Date | string
  }

  export type HotelCreateWithoutRoomsInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    category: HotelCategoryCreateNestedOneWithoutHotelsInput
    bookings?: HotelBookingCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    categoryId: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
  }

  export type HotelBookingCreateWithoutRoomInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
    hotel: HotelCreateNestedOneWithoutBookingsInput
  }

  export type HotelBookingUncheckedCreateWithoutRoomInput = {
    id?: number
    hotelId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingCreateOrConnectWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    create: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput>
  }

  export type HotelBookingCreateManyRoomInputEnvelope = {
    data: HotelBookingCreateManyRoomInput | HotelBookingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type HotelUpsertWithoutRoomsInput = {
    update: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HotelCategoryUpdateOneRequiredWithoutHotelsNestedInput
    bookings?: HotelBookingUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: HotelBookingUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelBookingUpsertWithWhereUniqueWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    update: XOR<HotelBookingUpdateWithoutRoomInput, HotelBookingUncheckedUpdateWithoutRoomInput>
    create: XOR<HotelBookingCreateWithoutRoomInput, HotelBookingUncheckedCreateWithoutRoomInput>
  }

  export type HotelBookingUpdateWithWhereUniqueWithoutRoomInput = {
    where: HotelBookingWhereUniqueInput
    data: XOR<HotelBookingUpdateWithoutRoomInput, HotelBookingUncheckedUpdateWithoutRoomInput>
  }

  export type HotelBookingUpdateManyWithWhereWithoutRoomInput = {
    where: HotelBookingScalarWhereInput
    data: XOR<HotelBookingUpdateManyMutationInput, HotelBookingUncheckedUpdateManyWithoutRoomInput>
  }

  export type HotelCreateWithoutBookingsInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    category: HotelCategoryCreateNestedOneWithoutHotelsInput
    rooms?: HotelRoomCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    categoryId: string
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutBookingsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
  }

  export type HotelRoomCreateWithoutBookingsInput = {
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
    hotel: HotelCreateNestedOneWithoutRoomsInput
  }

  export type HotelRoomUncheckedCreateWithoutBookingsInput = {
    id?: number
    hotelId: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelRoomCreateOrConnectWithoutBookingsInput = {
    where: HotelRoomWhereUniqueInput
    create: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
  }

  export type HotelUpsertWithoutBookingsInput = {
    update: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HotelCategoryUpdateOneRequiredWithoutHotelsNestedInput
    rooms?: HotelRoomUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    categoryId?: StringFieldUpdateOperationsInput | string
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelRoomUpsertWithoutBookingsInput = {
    update: XOR<HotelRoomUpdateWithoutBookingsInput, HotelRoomUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelRoomCreateWithoutBookingsInput, HotelRoomUncheckedCreateWithoutBookingsInput>
    where?: HotelRoomWhereInput
  }

  export type HotelRoomUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelRoomWhereInput
    data: XOR<HotelRoomUpdateWithoutBookingsInput, HotelRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelRoomUpdateWithoutBookingsInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type HotelRoomUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeedbackCreateWithoutUserInput = {
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
    itinerary?: ItineraryCreateNestedOneWithoutUserFeedbackInput
    tour?: TourCreateNestedOneWithoutUserFeedbackInput
  }

  export type UserFeedbackUncheckedCreateWithoutUserInput = {
    id?: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserFeedbackCreateOrConnectWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    create: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput>
  }

  export type UserFeedbackCreateManyUserInputEnvelope = {
    data: UserFeedbackCreateManyUserInput | UserFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInterestCreateWithoutUserInput = {
    interest: TravelInterestCreateNestedOneWithoutUserInterestsInput
  }

  export type UserInterestUncheckedCreateWithoutUserInput = {
    interestId: string
  }

  export type UserInterestCreateOrConnectWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    create: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput>
  }

  export type UserInterestCreateManyUserInputEnvelope = {
    data: UserInterestCreateManyUserInput | UserInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    update: XOR<UserFeedbackUpdateWithoutUserInput, UserFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeedbackCreateWithoutUserInput, UserFeedbackUncheckedCreateWithoutUserInput>
  }

  export type UserFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFeedbackWhereUniqueInput
    data: XOR<UserFeedbackUpdateWithoutUserInput, UserFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type UserFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: UserFeedbackScalarWhereInput
    data: XOR<UserFeedbackUpdateManyMutationInput, UserFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    update: XOR<UserInterestUpdateWithoutUserInput, UserInterestUncheckedUpdateWithoutUserInput>
    create: XOR<UserInterestCreateWithoutUserInput, UserInterestUncheckedCreateWithoutUserInput>
  }

  export type UserInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInterestWhereUniqueInput
    data: XOR<UserInterestUpdateWithoutUserInput, UserInterestUncheckedUpdateWithoutUserInput>
  }

  export type UserInterestUpdateManyWithWhereWithoutUserInput = {
    where: UserInterestScalarWhereInput
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInterestScalarWhereInput = {
    AND?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
    OR?: UserInterestScalarWhereInput[]
    NOT?: UserInterestScalarWhereInput | UserInterestScalarWhereInput[]
    userId?: IntFilter<"UserInterest"> | number
    interestId?: StringFilter<"UserInterest"> | string
  }

  export type UserAccountCreateWithoutFeedbacksInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    interests?: UserInterestCreateNestedManyWithoutUserInput
  }

  export type UserAccountUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    interests?: UserInterestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAccountCreateOrConnectWithoutFeedbacksInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
  }

  export type ItineraryCreateWithoutUserFeedbackInput = {
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutItinerariesInput
    guide?: GuideCreateNestedOneWithoutGuidedItinerariesInput
    driver?: GuideCreateNestedOneWithoutDrivenItinerariesInput
    days?: ItineraryDayCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestCreateNestedManyWithoutAssignedItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutUserFeedbackInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
    days?: ItineraryDayUncheckedCreateNestedManyWithoutItineraryInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedCreateNestedManyWithoutAssignedItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutUserFeedbackInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
  }

  export type TourCreateWithoutUserFeedbackInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutUserFeedbackInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutUserFeedbackInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
  }

  export type UserAccountUpsertWithoutFeedbacksInput = {
    update: XOR<UserAccountUpdateWithoutFeedbacksInput, UserAccountUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserAccountCreateWithoutFeedbacksInput, UserAccountUncheckedCreateWithoutFeedbacksInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutFeedbacksInput, UserAccountUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserAccountUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interests?: UserInterestUpdateManyWithoutUserNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interests?: UserInterestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ItineraryUpsertWithoutUserFeedbackInput = {
    update: XOR<ItineraryUpdateWithoutUserFeedbackInput, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
    create: XOR<ItineraryCreateWithoutUserFeedbackInput, ItineraryUncheckedCreateWithoutUserFeedbackInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutUserFeedbackInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutUserFeedbackInput, ItineraryUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type ItineraryUpdateWithoutUserFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutUserFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
  }

  export type TourUpsertWithoutUserFeedbackInput = {
    update: XOR<TourUpdateWithoutUserFeedbackInput, TourUncheckedUpdateWithoutUserFeedbackInput>
    create: XOR<TourCreateWithoutUserFeedbackInput, TourUncheckedCreateWithoutUserFeedbackInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutUserFeedbackInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutUserFeedbackInput, TourUncheckedUpdateWithoutUserFeedbackInput>
  }

  export type TourUpdateWithoutUserFeedbackInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutUserFeedbackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type HotelCreateWithoutCategoryInput = {
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
    rooms?: HotelRoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: HotelBookingUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutCategoryInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput>
  }

  export type HotelCreateManyCategoryInputEnvelope = {
    data: HotelCreateManyCategoryInput | HotelCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type HotelUpsertWithWhereUniqueWithoutCategoryInput = {
    where: HotelWhereUniqueInput
    update: XOR<HotelUpdateWithoutCategoryInput, HotelUncheckedUpdateWithoutCategoryInput>
    create: XOR<HotelCreateWithoutCategoryInput, HotelUncheckedCreateWithoutCategoryInput>
  }

  export type HotelUpdateWithWhereUniqueWithoutCategoryInput = {
    where: HotelWhereUniqueInput
    data: XOR<HotelUpdateWithoutCategoryInput, HotelUncheckedUpdateWithoutCategoryInput>
  }

  export type HotelUpdateManyWithWhereWithoutCategoryInput = {
    where: HotelScalarWhereInput
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyWithoutCategoryInput>
  }

  export type HotelScalarWhereInput = {
    AND?: HotelScalarWhereInput | HotelScalarWhereInput[]
    OR?: HotelScalarWhereInput[]
    NOT?: HotelScalarWhereInput | HotelScalarWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    location?: StringFilter<"Hotel"> | string
    address?: StringFilter<"Hotel"> | string
    imageUrl?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    categoryId?: StringFilter<"Hotel"> | string
    starRating?: IntFilter<"Hotel"> | number
    amenities?: StringNullableListFilter<"Hotel">
    features?: StringNullableListFilter<"Hotel">
    pricePerNight?: IntFilter<"Hotel"> | number
    isActive?: BoolFilter<"Hotel"> | boolean
    contactEmail?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    checkInTime?: StringFilter<"Hotel"> | string
    checkOutTime?: StringFilter<"Hotel"> | string
    cancellationPolicy?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
  }

  export type UserInterestCreateWithoutInterestInput = {
    user: UserAccountCreateNestedOneWithoutInterestsInput
  }

  export type UserInterestUncheckedCreateWithoutInterestInput = {
    userId: number
  }

  export type UserInterestCreateOrConnectWithoutInterestInput = {
    where: UserInterestWhereUniqueInput
    create: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput>
  }

  export type UserInterestCreateManyInterestInputEnvelope = {
    data: UserInterestCreateManyInterestInput | UserInterestCreateManyInterestInput[]
    skipDuplicates?: boolean
  }

  export type CustomTourInterestCreateWithoutInterestInput = {
    customTourRequest: CustomTourRequestCreateNestedOneWithoutInterestsInput
  }

  export type CustomTourInterestUncheckedCreateWithoutInterestInput = {
    customTourRequestId: number
  }

  export type CustomTourInterestCreateOrConnectWithoutInterestInput = {
    where: CustomTourInterestWhereUniqueInput
    create: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput>
  }

  export type CustomTourInterestCreateManyInterestInputEnvelope = {
    data: CustomTourInterestCreateManyInterestInput | CustomTourInterestCreateManyInterestInput[]
    skipDuplicates?: boolean
  }

  export type UserInterestUpsertWithWhereUniqueWithoutInterestInput = {
    where: UserInterestWhereUniqueInput
    update: XOR<UserInterestUpdateWithoutInterestInput, UserInterestUncheckedUpdateWithoutInterestInput>
    create: XOR<UserInterestCreateWithoutInterestInput, UserInterestUncheckedCreateWithoutInterestInput>
  }

  export type UserInterestUpdateWithWhereUniqueWithoutInterestInput = {
    where: UserInterestWhereUniqueInput
    data: XOR<UserInterestUpdateWithoutInterestInput, UserInterestUncheckedUpdateWithoutInterestInput>
  }

  export type UserInterestUpdateManyWithWhereWithoutInterestInput = {
    where: UserInterestScalarWhereInput
    data: XOR<UserInterestUpdateManyMutationInput, UserInterestUncheckedUpdateManyWithoutInterestInput>
  }

  export type CustomTourInterestUpsertWithWhereUniqueWithoutInterestInput = {
    where: CustomTourInterestWhereUniqueInput
    update: XOR<CustomTourInterestUpdateWithoutInterestInput, CustomTourInterestUncheckedUpdateWithoutInterestInput>
    create: XOR<CustomTourInterestCreateWithoutInterestInput, CustomTourInterestUncheckedCreateWithoutInterestInput>
  }

  export type CustomTourInterestUpdateWithWhereUniqueWithoutInterestInput = {
    where: CustomTourInterestWhereUniqueInput
    data: XOR<CustomTourInterestUpdateWithoutInterestInput, CustomTourInterestUncheckedUpdateWithoutInterestInput>
  }

  export type CustomTourInterestUpdateManyWithWhereWithoutInterestInput = {
    where: CustomTourInterestScalarWhereInput
    data: XOR<CustomTourInterestUpdateManyMutationInput, CustomTourInterestUncheckedUpdateManyWithoutInterestInput>
  }

  export type FlightBookingCreateWithoutFlightRouteInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type FlightBookingUncheckedCreateWithoutFlightRouteInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type FlightBookingCreateOrConnectWithoutFlightRouteInput = {
    where: FlightBookingWhereUniqueInput
    create: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput>
  }

  export type FlightBookingCreateManyFlightRouteInputEnvelope = {
    data: FlightBookingCreateManyFlightRouteInput | FlightBookingCreateManyFlightRouteInput[]
    skipDuplicates?: boolean
  }

  export type FlightBookingUpsertWithWhereUniqueWithoutFlightRouteInput = {
    where: FlightBookingWhereUniqueInput
    update: XOR<FlightBookingUpdateWithoutFlightRouteInput, FlightBookingUncheckedUpdateWithoutFlightRouteInput>
    create: XOR<FlightBookingCreateWithoutFlightRouteInput, FlightBookingUncheckedCreateWithoutFlightRouteInput>
  }

  export type FlightBookingUpdateWithWhereUniqueWithoutFlightRouteInput = {
    where: FlightBookingWhereUniqueInput
    data: XOR<FlightBookingUpdateWithoutFlightRouteInput, FlightBookingUncheckedUpdateWithoutFlightRouteInput>
  }

  export type FlightBookingUpdateManyWithWhereWithoutFlightRouteInput = {
    where: FlightBookingScalarWhereInput
    data: XOR<FlightBookingUpdateManyMutationInput, FlightBookingUncheckedUpdateManyWithoutFlightRouteInput>
  }

  export type FlightBookingScalarWhereInput = {
    AND?: FlightBookingScalarWhereInput | FlightBookingScalarWhereInput[]
    OR?: FlightBookingScalarWhereInput[]
    NOT?: FlightBookingScalarWhereInput | FlightBookingScalarWhereInput[]
    id?: IntFilter<"FlightBooking"> | number
    flightRouteId?: StringFilter<"FlightBooking"> | string
    firstName?: StringFilter<"FlightBooking"> | string
    lastName?: StringFilter<"FlightBooking"> | string
    email?: StringFilter<"FlightBooking"> | string
    phone?: StringNullableFilter<"FlightBooking"> | string | null
    departureDate?: DateTimeFilter<"FlightBooking"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightBooking"> | Date | string | null
    numberOfPassengers?: IntFilter<"FlightBooking"> | number
    totalAmount?: IntFilter<"FlightBooking"> | number
    specialRequests?: StringNullableFilter<"FlightBooking"> | string | null
    status?: StringFilter<"FlightBooking"> | string
    paymentStatus?: StringFilter<"FlightBooking"> | string
    createdAt?: DateTimeFilter<"FlightBooking"> | Date | string
  }

  export type BookingCreateWithoutActivitiesInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    tour: TourCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutActivitiesInput = {
    id?: number
    tourId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutActivitiesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutActivitiesInput, BookingUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityCreateWithoutBookingActivitiesInput = {
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutBookingActivitiesInput = {
    id?: number
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutBookingActivitiesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutBookingActivitiesInput, ActivityUncheckedCreateWithoutBookingActivitiesInput>
  }

  export type BookingUpsertWithoutActivitiesInput = {
    update: XOR<BookingUpdateWithoutActivitiesInput, BookingUncheckedUpdateWithoutActivitiesInput>
    create: XOR<BookingCreateWithoutActivitiesInput, BookingUncheckedCreateWithoutActivitiesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutActivitiesInput, BookingUncheckedUpdateWithoutActivitiesInput>
  }

  export type BookingUpdateWithoutActivitiesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpsertWithoutBookingActivitiesInput = {
    update: XOR<ActivityUpdateWithoutBookingActivitiesInput, ActivityUncheckedUpdateWithoutBookingActivitiesInput>
    create: XOR<ActivityCreateWithoutBookingActivitiesInput, ActivityUncheckedCreateWithoutBookingActivitiesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutBookingActivitiesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutBookingActivitiesInput, ActivityUncheckedUpdateWithoutBookingActivitiesInput>
  }

  export type ActivityUpdateWithoutBookingActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourActivities?: TourActivityJunctionUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutBookingActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserAccountCreateWithoutInterestsInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserAccountUncheckedCreateWithoutInterestsInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    role: string
    isActive?: boolean
    profileImage?: string | null
    createdAt?: Date | string
    lastLoginAt?: Date | string | null
    feedbacks?: UserFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserAccountCreateOrConnectWithoutInterestsInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutInterestsInput, UserAccountUncheckedCreateWithoutInterestsInput>
  }

  export type TravelInterestCreateWithoutUserInterestsInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    customTourInterests?: CustomTourInterestCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestUncheckedCreateWithoutUserInterestsInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    customTourInterests?: CustomTourInterestUncheckedCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestCreateOrConnectWithoutUserInterestsInput = {
    where: TravelInterestWhereUniqueInput
    create: XOR<TravelInterestCreateWithoutUserInterestsInput, TravelInterestUncheckedCreateWithoutUserInterestsInput>
  }

  export type UserAccountUpsertWithoutInterestsInput = {
    update: XOR<UserAccountUpdateWithoutInterestsInput, UserAccountUncheckedUpdateWithoutInterestsInput>
    create: XOR<UserAccountCreateWithoutInterestsInput, UserAccountUncheckedCreateWithoutInterestsInput>
    where?: UserAccountWhereInput
  }

  export type UserAccountUpdateToOneWithWhereWithoutInterestsInput = {
    where?: UserAccountWhereInput
    data: XOR<UserAccountUpdateWithoutInterestsInput, UserAccountUncheckedUpdateWithoutInterestsInput>
  }

  export type UserAccountUpdateWithoutInterestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserAccountUncheckedUpdateWithoutInterestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbacks?: UserFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TravelInterestUpsertWithoutUserInterestsInput = {
    update: XOR<TravelInterestUpdateWithoutUserInterestsInput, TravelInterestUncheckedUpdateWithoutUserInterestsInput>
    create: XOR<TravelInterestCreateWithoutUserInterestsInput, TravelInterestUncheckedCreateWithoutUserInterestsInput>
    where?: TravelInterestWhereInput
  }

  export type TravelInterestUpdateToOneWithWhereWithoutUserInterestsInput = {
    where?: TravelInterestWhereInput
    data: XOR<TravelInterestUpdateWithoutUserInterestsInput, TravelInterestUncheckedUpdateWithoutUserInterestsInput>
  }

  export type TravelInterestUpdateWithoutUserInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    customTourInterests?: CustomTourInterestUpdateManyWithoutInterestNestedInput
  }

  export type TravelInterestUncheckedUpdateWithoutUserInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    customTourInterests?: CustomTourInterestUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type CustomTourRequestCreateWithoutInterestsInput = {
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
    assignedItinerary?: ItineraryCreateNestedOneWithoutAssignedCustomTourRequestsInput
  }

  export type CustomTourRequestUncheckedCreateWithoutInterestsInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    assignedItineraryId?: number | null
    createdAt?: Date | string
  }

  export type CustomTourRequestCreateOrConnectWithoutInterestsInput = {
    where: CustomTourRequestWhereUniqueInput
    create: XOR<CustomTourRequestCreateWithoutInterestsInput, CustomTourRequestUncheckedCreateWithoutInterestsInput>
  }

  export type TravelInterestCreateWithoutCustomTourInterestsInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    userInterests?: UserInterestCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestUncheckedCreateWithoutCustomTourInterestsInput = {
    id: string
    name: string
    description: string
    isActive?: boolean
    displayOrder?: number | null
    userInterests?: UserInterestUncheckedCreateNestedManyWithoutInterestInput
  }

  export type TravelInterestCreateOrConnectWithoutCustomTourInterestsInput = {
    where: TravelInterestWhereUniqueInput
    create: XOR<TravelInterestCreateWithoutCustomTourInterestsInput, TravelInterestUncheckedCreateWithoutCustomTourInterestsInput>
  }

  export type CustomTourRequestUpsertWithoutInterestsInput = {
    update: XOR<CustomTourRequestUpdateWithoutInterestsInput, CustomTourRequestUncheckedUpdateWithoutInterestsInput>
    create: XOR<CustomTourRequestCreateWithoutInterestsInput, CustomTourRequestUncheckedCreateWithoutInterestsInput>
    where?: CustomTourRequestWhereInput
  }

  export type CustomTourRequestUpdateToOneWithWhereWithoutInterestsInput = {
    where?: CustomTourRequestWhereInput
    data: XOR<CustomTourRequestUpdateWithoutInterestsInput, CustomTourRequestUncheckedUpdateWithoutInterestsInput>
  }

  export type CustomTourRequestUpdateWithoutInterestsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedItinerary?: ItineraryUpdateOneWithoutAssignedCustomTourRequestsNestedInput
  }

  export type CustomTourRequestUncheckedUpdateWithoutInterestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    assignedItineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TravelInterestUpsertWithoutCustomTourInterestsInput = {
    update: XOR<TravelInterestUpdateWithoutCustomTourInterestsInput, TravelInterestUncheckedUpdateWithoutCustomTourInterestsInput>
    create: XOR<TravelInterestCreateWithoutCustomTourInterestsInput, TravelInterestUncheckedCreateWithoutCustomTourInterestsInput>
    where?: TravelInterestWhereInput
  }

  export type TravelInterestUpdateToOneWithWhereWithoutCustomTourInterestsInput = {
    where?: TravelInterestWhereInput
    data: XOR<TravelInterestUpdateWithoutCustomTourInterestsInput, TravelInterestUncheckedUpdateWithoutCustomTourInterestsInput>
  }

  export type TravelInterestUpdateWithoutCustomTourInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    userInterests?: UserInterestUpdateManyWithoutInterestNestedInput
  }

  export type TravelInterestUncheckedUpdateWithoutCustomTourInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    userInterests?: UserInterestUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type FlightRouteCreateWithoutFlightBookingsInput = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive?: boolean
  }

  export type FlightRouteUncheckedCreateWithoutFlightBookingsInput = {
    id: string
    origin: string
    destination: string
    airline: string
    duration: string
    frequency: string
    price: number
    isActive?: boolean
  }

  export type FlightRouteCreateOrConnectWithoutFlightBookingsInput = {
    where: FlightRouteWhereUniqueInput
    create: XOR<FlightRouteCreateWithoutFlightBookingsInput, FlightRouteUncheckedCreateWithoutFlightBookingsInput>
  }

  export type FlightRouteUpsertWithoutFlightBookingsInput = {
    update: XOR<FlightRouteUpdateWithoutFlightBookingsInput, FlightRouteUncheckedUpdateWithoutFlightBookingsInput>
    create: XOR<FlightRouteCreateWithoutFlightBookingsInput, FlightRouteUncheckedCreateWithoutFlightBookingsInput>
    where?: FlightRouteWhereInput
  }

  export type FlightRouteUpdateToOneWithWhereWithoutFlightBookingsInput = {
    where?: FlightRouteWhereInput
    data: XOR<FlightRouteUpdateWithoutFlightBookingsInput, FlightRouteUncheckedUpdateWithoutFlightBookingsInput>
  }

  export type FlightRouteUpdateWithoutFlightBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlightRouteUncheckedUpdateWithoutFlightBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TourActivityJunctionCreateWithoutActivityInput = {
    included?: boolean
    optional?: boolean
    tour: TourCreateNestedOneWithoutTourActivitiesInput
  }

  export type TourActivityJunctionUncheckedCreateWithoutActivityInput = {
    tourId: number
    included?: boolean
    optional?: boolean
  }

  export type TourActivityJunctionCreateOrConnectWithoutActivityInput = {
    where: TourActivityJunctionWhereUniqueInput
    create: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput>
  }

  export type TourActivityJunctionCreateManyActivityInputEnvelope = {
    data: TourActivityJunctionCreateManyActivityInput | TourActivityJunctionCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type BookingActivityCreateWithoutActivityInput = {
    booking: BookingCreateNestedOneWithoutActivitiesInput
  }

  export type BookingActivityUncheckedCreateWithoutActivityInput = {
    bookingId: number
  }

  export type BookingActivityCreateOrConnectWithoutActivityInput = {
    where: BookingActivityWhereUniqueInput
    create: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput>
  }

  export type BookingActivityCreateManyActivityInputEnvelope = {
    data: BookingActivityCreateManyActivityInput | BookingActivityCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type TourActivityJunctionUpsertWithWhereUniqueWithoutActivityInput = {
    where: TourActivityJunctionWhereUniqueInput
    update: XOR<TourActivityJunctionUpdateWithoutActivityInput, TourActivityJunctionUncheckedUpdateWithoutActivityInput>
    create: XOR<TourActivityJunctionCreateWithoutActivityInput, TourActivityJunctionUncheckedCreateWithoutActivityInput>
  }

  export type TourActivityJunctionUpdateWithWhereUniqueWithoutActivityInput = {
    where: TourActivityJunctionWhereUniqueInput
    data: XOR<TourActivityJunctionUpdateWithoutActivityInput, TourActivityJunctionUncheckedUpdateWithoutActivityInput>
  }

  export type TourActivityJunctionUpdateManyWithWhereWithoutActivityInput = {
    where: TourActivityJunctionScalarWhereInput
    data: XOR<TourActivityJunctionUpdateManyMutationInput, TourActivityJunctionUncheckedUpdateManyWithoutActivityInput>
  }

  export type BookingActivityUpsertWithWhereUniqueWithoutActivityInput = {
    where: BookingActivityWhereUniqueInput
    update: XOR<BookingActivityUpdateWithoutActivityInput, BookingActivityUncheckedUpdateWithoutActivityInput>
    create: XOR<BookingActivityCreateWithoutActivityInput, BookingActivityUncheckedCreateWithoutActivityInput>
  }

  export type BookingActivityUpdateWithWhereUniqueWithoutActivityInput = {
    where: BookingActivityWhereUniqueInput
    data: XOR<BookingActivityUpdateWithoutActivityInput, BookingActivityUncheckedUpdateWithoutActivityInput>
  }

  export type BookingActivityUpdateManyWithWhereWithoutActivityInput = {
    where: BookingActivityScalarWhereInput
    data: XOR<BookingActivityUpdateManyMutationInput, BookingActivityUncheckedUpdateManyWithoutActivityInput>
  }

  export type TourCreateWithoutTourActivitiesInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutTourActivitiesInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourFestivals?: TourFestivalUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutTourActivitiesInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutTourActivitiesInput, TourUncheckedCreateWithoutTourActivitiesInput>
  }

  export type ActivityCreateWithoutTourActivitiesInput = {
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingActivities?: BookingActivityCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutTourActivitiesInput = {
    id?: number
    name: string
    category: string
    duration?: string | null
    difficulty?: string | null
    price: number
    description?: string | null
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingActivities?: BookingActivityUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutTourActivitiesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTourActivitiesInput, ActivityUncheckedCreateWithoutTourActivitiesInput>
  }

  export type TourUpsertWithoutTourActivitiesInput = {
    update: XOR<TourUpdateWithoutTourActivitiesInput, TourUncheckedUpdateWithoutTourActivitiesInput>
    create: XOR<TourCreateWithoutTourActivitiesInput, TourUncheckedCreateWithoutTourActivitiesInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutTourActivitiesInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutTourActivitiesInput, TourUncheckedUpdateWithoutTourActivitiesInput>
  }

  export type TourUpdateWithoutTourActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutTourActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
  }

  export type ActivityUpsertWithoutTourActivitiesInput = {
    update: XOR<ActivityUpdateWithoutTourActivitiesInput, ActivityUncheckedUpdateWithoutTourActivitiesInput>
    create: XOR<ActivityCreateWithoutTourActivitiesInput, ActivityUncheckedCreateWithoutTourActivitiesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutTourActivitiesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutTourActivitiesInput, ActivityUncheckedUpdateWithoutTourActivitiesInput>
  }

  export type ActivityUpdateWithoutTourActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingActivities?: BookingActivityUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTourActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingActivities?: BookingActivityUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type TourCreateWithoutTourFestivalsInput = {
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutTourInput
    itineraries?: ItineraryCreateNestedManyWithoutTourInput
    tourOperator?: TourOperatorCreateNestedOneWithoutToursInput
    userFeedback?: UserFeedbackCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutTourFestivalsInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tourOperatorId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutTourInput
    itineraries?: ItineraryUncheckedCreateNestedManyWithoutTourInput
    userFeedback?: UserFeedbackUncheckedCreateNestedManyWithoutTourInput
    tourActivities?: TourActivityJunctionUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutTourFestivalsInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutTourFestivalsInput, TourUncheckedCreateWithoutTourFestivalsInput>
  }

  export type FestivalCreateWithoutTourFestivalsInput = {
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    festivalBookings?: FestivalBookingCreateNestedManyWithoutFestivalInput
  }

  export type FestivalUncheckedCreateWithoutTourFestivalsInput = {
    id?: number
    name: string
    description?: string | null
    location?: string | null
    dates?: string | null
    duration?: string | null
    significance?: string | null
    activities?: FestivalCreateactivitiesInput | string[]
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    festivalBookings?: FestivalBookingUncheckedCreateNestedManyWithoutFestivalInput
  }

  export type FestivalCreateOrConnectWithoutTourFestivalsInput = {
    where: FestivalWhereUniqueInput
    create: XOR<FestivalCreateWithoutTourFestivalsInput, FestivalUncheckedCreateWithoutTourFestivalsInput>
  }

  export type TourUpsertWithoutTourFestivalsInput = {
    update: XOR<TourUpdateWithoutTourFestivalsInput, TourUncheckedUpdateWithoutTourFestivalsInput>
    create: XOR<TourCreateWithoutTourFestivalsInput, TourUncheckedCreateWithoutTourFestivalsInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutTourFestivalsInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutTourFestivalsInput, TourUncheckedUpdateWithoutTourFestivalsInput>
  }

  export type TourUpdateWithoutTourFestivalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    tourOperator?: TourOperatorUpdateOneWithoutToursNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutTourFestivalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tourOperatorId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type FestivalUpsertWithoutTourFestivalsInput = {
    update: XOR<FestivalUpdateWithoutTourFestivalsInput, FestivalUncheckedUpdateWithoutTourFestivalsInput>
    create: XOR<FestivalCreateWithoutTourFestivalsInput, FestivalUncheckedCreateWithoutTourFestivalsInput>
    where?: FestivalWhereInput
  }

  export type FestivalUpdateToOneWithWhereWithoutTourFestivalsInput = {
    where?: FestivalWhereInput
    data: XOR<FestivalUpdateWithoutTourFestivalsInput, FestivalUncheckedUpdateWithoutTourFestivalsInput>
  }

  export type FestivalUpdateWithoutTourFestivalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    festivalBookings?: FestivalBookingUpdateManyWithoutFestivalNestedInput
  }

  export type FestivalUncheckedUpdateWithoutTourFestivalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dates?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    significance?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: FestivalUpdateactivitiesInput | string[]
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    festivalBookings?: FestivalBookingUncheckedUpdateManyWithoutFestivalNestedInput
  }

  export type ChatMessageCreateWithoutSessionInput = {
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutSessionInput = {
    id?: number
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageCreateManySessionInputEnvelope = {
    data: ChatMessageCreateManySessionInput | ChatMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSessionInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    sessionId?: StringFilter<"ChatMessage"> | string
    sender?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    messageType?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatSessionCreateWithoutMessagesInput = {
    sessionId: string
    userId?: number | null
    userEmail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionUncheckedCreateWithoutMessagesInput = {
    id?: number
    sessionId: string
    userId?: number | null
    userEmail?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
  }

  export type ChatSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionUpdateWithoutMessagesInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyTourInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    travelDate: string
    groupSize: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryCreateManyTourInput = {
    id?: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type UserFeedbackCreateManyTourInput = {
    id?: number
    userId: number
    itineraryId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type TourFestivalCreateManyTourInput = {
    id?: number
    festivalId: number
  }

  export type TourActivityJunctionCreateManyTourInput = {
    activityId: number
    included?: boolean
    optional?: boolean
  }

  export type BookingUpdateWithoutTourInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: BookingActivityUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: BookingActivityUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    travelDate?: StringFieldUpdateOperationsInput | string
    groupSize?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutTourInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpdateWithoutTourInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourFestivalUpdateWithoutTourInput = {
    festival?: FestivalUpdateOneRequiredWithoutTourFestivalsNestedInput
  }

  export type TourFestivalUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
  }

  export type TourFestivalUncheckedUpdateManyWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    festivalId?: IntFieldUpdateOperationsInput | number
  }

  export type TourActivityJunctionUpdateWithoutTourInput = {
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
    activity?: ActivityUpdateOneRequiredWithoutTourActivitiesNestedInput
  }

  export type TourActivityJunctionUncheckedUpdateWithoutTourInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TourActivityJunctionUncheckedUpdateManyWithoutTourInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingActivityCreateManyBookingInput = {
    activityId: number
  }

  export type BookingActivityUpdateWithoutBookingInput = {
    activity?: ActivityUpdateOneRequiredWithoutBookingActivitiesNestedInput
  }

  export type BookingActivityUncheckedUpdateWithoutBookingInput = {
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingActivityUncheckedUpdateManyWithoutBookingInput = {
    activityId?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryCreateManyGuideInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    driverId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryCreateManyDriverInput = {
    id?: number
    tourId: number
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    guideId?: number | null
    maxParticipants?: number
    currentParticipants?: number
    status?: string
    createdAt?: Date | string
  }

  export type ItineraryUpdateWithoutGuideInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    driver?: GuideUpdateOneWithoutDrivenItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutGuideInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutGuideInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutDriverInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tour?: TourUpdateOneRequiredWithoutItinerariesNestedInput
    guide?: GuideUpdateOneWithoutGuidedItinerariesNestedInput
    days?: ItineraryDayUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: ItineraryDayUncheckedUpdateManyWithoutItineraryNestedInput
    assignedCustomTourRequests?: CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryNestedInput
    UserFeedback?: UserFeedbackUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    guideId?: NullableIntFieldUpdateOperationsInput | number | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    currentParticipants?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryDayCreateManyItineraryInput = {
    id?: number
    dayNumber: number
    title: string
    description: string
    activities?: ItineraryDayCreateactivitiesInput | string[]
    accommodation?: string | null
    meals?: ItineraryDayCreatemealsInput | string[]
    transportation?: string | null
    notes?: string | null
  }

  export type CustomTourRequestCreateManyAssignedItineraryInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    duration: number
    groupSize: number
    budget?: number | null
    preferredDates?: string | null
    specialRequirements?: string | null
    destinations?: CustomTourRequestCreatedestinationsInput | string[]
    accommodationType?: string | null
    transportPreference?: string | null
    status?: string
    adminNotes?: string | null
    estimatedPrice?: number | null
    createdAt?: Date | string
  }

  export type UserFeedbackCreateManyItineraryInput = {
    id?: number
    userId: number
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type ItineraryDayUpdateWithoutItineraryInput = {
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItineraryDayUncheckedUpdateManyWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    activities?: ItineraryDayUpdateactivitiesInput | string[]
    accommodation?: NullableStringFieldUpdateOperationsInput | string | null
    meals?: ItineraryDayUpdatemealsInput | string[]
    transportation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomTourRequestUpdateWithoutAssignedItineraryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: CustomTourInterestUpdateManyWithoutCustomTourRequestNestedInput
  }

  export type CustomTourRequestUncheckedUpdateWithoutAssignedItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: CustomTourInterestUncheckedUpdateManyWithoutCustomTourRequestNestedInput
  }

  export type CustomTourRequestUncheckedUpdateManyWithoutAssignedItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    groupSize?: IntFieldUpdateOperationsInput | number
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    preferredDates?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequirements?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: CustomTourRequestUpdatedestinationsInput | string[]
    accommodationType?: NullableStringFieldUpdateOperationsInput | string | null
    transportPreference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUpdateWithoutItineraryInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserAccountUpdateOneRequiredWithoutFeedbacksNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutItineraryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomTourInterestCreateManyCustomTourRequestInput = {
    interestId: string
  }

  export type CustomTourInterestUpdateWithoutCustomTourRequestInput = {
    interest?: TravelInterestUpdateOneRequiredWithoutCustomTourInterestsNestedInput
  }

  export type CustomTourInterestUncheckedUpdateWithoutCustomTourRequestInput = {
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomTourInterestUncheckedUpdateManyWithoutCustomTourRequestInput = {
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type TourCreateManyTourOperatorInput = {
    id?: number
    name: string
    description?: string | null
    duration: string
    price: number
    maxPrice?: number | null
    categoryName: string
    difficulty?: string | null
    groupSize?: string | null
    imageUrl?: string | null
    highlights?: TourCreatehighlightsInput | string[]
    includes?: TourCreateincludesInput | string[]
    excludes?: TourCreateexcludesInput | string[]
    itinerary?: string | null
    bestTime?: TourCreatebestTimeInput | string[]
    physicalRating?: string | null
    culturalLevel?: string | null
    luxuryLevel?: string | null
    spiritualLevel?: string | null
    rating?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateWithoutTourOperatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutTourOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutTourNestedInput
    itineraries?: ItineraryUncheckedUpdateManyWithoutTourNestedInput
    userFeedback?: UserFeedbackUncheckedUpdateManyWithoutTourNestedInput
    tourFestivals?: TourFestivalUncheckedUpdateManyWithoutTourNestedInput
    tourActivities?: TourActivityJunctionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateManyWithoutTourOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryName?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: TourUpdatehighlightsInput | string[]
    includes?: TourUpdateincludesInput | string[]
    excludes?: TourUpdateexcludesInput | string[]
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    bestTime?: TourUpdatebestTimeInput | string[]
    physicalRating?: NullableStringFieldUpdateOperationsInput | string | null
    culturalLevel?: NullableStringFieldUpdateOperationsInput | string | null
    luxuryLevel?: NullableStringFieldUpdateOperationsInput | string | null
    spiritualLevel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourFestivalCreateManyFestivalInput = {
    id?: number
    tourId: number
  }

  export type FestivalBookingCreateManyFestivalInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    numberOfTickets: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type TourFestivalUpdateWithoutFestivalInput = {
    tour?: TourUpdateOneRequiredWithoutTourFestivalsNestedInput
  }

  export type TourFestivalUncheckedUpdateWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
  }

  export type TourFestivalUncheckedUpdateManyWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    tourId?: IntFieldUpdateOperationsInput | number
  }

  export type FestivalBookingUpdateWithoutFestivalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FestivalBookingUncheckedUpdateManyWithoutFestivalInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfTickets?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelRoomCreateManyHotelInput = {
    id?: number
    roomType: string
    roomName: string
    description: string
    imageUrl: string
    images?: HotelRoomCreateimagesInput | string[]
    maxOccupancy: number
    bedType: string
    roomSize?: string | null
    amenities?: HotelRoomCreateamenitiesInput | string[]
    pricePerNight: number
    totalRooms: number
    isActive?: boolean
  }

  export type HotelBookingCreateManyHotelInput = {
    id?: number
    roomId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelRoomUpdateWithoutHotelInput = {
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookings?: HotelBookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type HotelRoomUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomType?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelRoomUpdateimagesInput | string[]
    maxOccupancy?: IntFieldUpdateOperationsInput | number
    bedType?: StringFieldUpdateOperationsInput | string
    roomSize?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: HotelRoomUpdateamenitiesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    totalRooms?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelBookingUpdateWithoutHotelInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: HotelRoomUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingCreateManyRoomInput = {
    id?: number
    hotelId: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    numberOfRooms: number
    numberOfGuests: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type HotelBookingUpdateWithoutRoomInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type HotelBookingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelBookingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    numberOfGuests?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackCreateManyUserInput = {
    id?: number
    itineraryId?: number | null
    tourId?: number | null
    rating: number
    comment?: string | null
    category: string
    isPublic?: boolean
    createdAt?: Date | string
  }

  export type UserInterestCreateManyUserInput = {
    interestId: string
  }

  export type UserFeedbackUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerary?: ItineraryUpdateOneWithoutUserFeedbackNestedInput
    tour?: TourUpdateOneWithoutUserFeedbackNestedInput
  }

  export type UserFeedbackUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itineraryId?: NullableIntFieldUpdateOperationsInput | number | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInterestUpdateWithoutUserInput = {
    interest?: TravelInterestUpdateOneRequiredWithoutUserInterestsNestedInput
  }

  export type UserInterestUncheckedUpdateWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInterestUncheckedUpdateManyWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
  }

  export type HotelCreateManyCategoryInput = {
    id?: number
    name: string
    description: string
    location: string
    address: string
    imageUrl: string
    images?: HotelCreateimagesInput | string[]
    starRating: number
    amenities?: HotelCreateamenitiesInput | string[]
    features?: HotelCreatefeaturesInput | string[]
    pricePerNight: number
    isActive?: boolean
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    checkInTime?: string
    checkOutTime?: string
    cancellationPolicy?: string | null
    createdAt?: Date | string
  }

  export type HotelUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: HotelRoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: HotelBookingUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    starRating?: IntFieldUpdateOperationsInput | number
    amenities?: HotelUpdateamenitiesInput | string[]
    features?: HotelUpdatefeaturesInput | string[]
    pricePerNight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: StringFieldUpdateOperationsInput | string
    checkOutTime?: StringFieldUpdateOperationsInput | string
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInterestCreateManyInterestInput = {
    userId: number
  }

  export type CustomTourInterestCreateManyInterestInput = {
    customTourRequestId: number
  }

  export type UserInterestUpdateWithoutInterestInput = {
    user?: UserAccountUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type UserInterestUncheckedUpdateWithoutInterestInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserInterestUncheckedUpdateManyWithoutInterestInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomTourInterestUpdateWithoutInterestInput = {
    customTourRequest?: CustomTourRequestUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type CustomTourInterestUncheckedUpdateWithoutInterestInput = {
    customTourRequestId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomTourInterestUncheckedUpdateManyWithoutInterestInput = {
    customTourRequestId?: IntFieldUpdateOperationsInput | number
  }

  export type FlightBookingCreateManyFlightRouteInput = {
    id?: number
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    departureDate: Date | string
    returnDate?: Date | string | null
    numberOfPassengers: number
    totalAmount: number
    specialRequests?: string | null
    status?: string
    paymentStatus?: string
    createdAt?: Date | string
  }

  export type FlightBookingUpdateWithoutFlightRouteInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightBookingUncheckedUpdateWithoutFlightRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightBookingUncheckedUpdateManyWithoutFlightRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numberOfPassengers?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourActivityJunctionCreateManyActivityInput = {
    tourId: number
    included?: boolean
    optional?: boolean
  }

  export type BookingActivityCreateManyActivityInput = {
    bookingId: number
  }

  export type TourActivityJunctionUpdateWithoutActivityInput = {
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
    tour?: TourUpdateOneRequiredWithoutTourActivitiesNestedInput
  }

  export type TourActivityJunctionUncheckedUpdateWithoutActivityInput = {
    tourId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TourActivityJunctionUncheckedUpdateManyWithoutActivityInput = {
    tourId?: IntFieldUpdateOperationsInput | number
    included?: BoolFieldUpdateOperationsInput | boolean
    optional?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingActivityUpdateWithoutActivityInput = {
    booking?: BookingUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type BookingActivityUncheckedUpdateWithoutActivityInput = {
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingActivityUncheckedUpdateManyWithoutActivityInput = {
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageCreateManySessionInput = {
    id?: number
    sender: string
    message: string
    messageType?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutSessionInput = {
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TourCountOutputTypeDefaultArgs instead
     */
    export type TourCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuideCountOutputTypeDefaultArgs instead
     */
    export type GuideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryCountOutputTypeDefaultArgs instead
     */
    export type ItineraryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomTourRequestCountOutputTypeDefaultArgs instead
     */
    export type CustomTourRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomTourRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourOperatorCountOutputTypeDefaultArgs instead
     */
    export type TourOperatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourOperatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalCountOutputTypeDefaultArgs instead
     */
    export type FestivalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelCountOutputTypeDefaultArgs instead
     */
    export type HotelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelRoomCountOutputTypeDefaultArgs instead
     */
    export type HotelRoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelRoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAccountCountOutputTypeDefaultArgs instead
     */
    export type UserAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelCategoryCountOutputTypeDefaultArgs instead
     */
    export type HotelCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TravelInterestCountOutputTypeDefaultArgs instead
     */
    export type TravelInterestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TravelInterestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlightRouteCountOutputTypeDefaultArgs instead
     */
    export type FlightRouteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlightRouteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityCountOutputTypeDefaultArgs instead
     */
    export type ActivityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatSessionCountOutputTypeDefaultArgs instead
     */
    export type ChatSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourDefaultArgs instead
     */
    export type TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InquiryDefaultArgs instead
     */
    export type InquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InquiryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestimonialDefaultArgs instead
     */
    export type TestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuideDefaultArgs instead
     */
    export type GuideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDefaultArgs instead
     */
    export type ItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDayDefaultArgs instead
     */
    export type ItineraryDayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomTourRequestDefaultArgs instead
     */
    export type CustomTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomTourRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourOperatorDefaultArgs instead
     */
    export type TourOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourOperatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalDefaultArgs instead
     */
    export type FestivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FestivalBookingDefaultArgs instead
     */
    export type FestivalBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FestivalBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelDefaultArgs instead
     */
    export type HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelRoomDefaultArgs instead
     */
    export type HotelRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelBookingDefaultArgs instead
     */
    export type HotelBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAccountDefaultArgs instead
     */
    export type UserAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFeedbackDefaultArgs instead
     */
    export type UserFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourCategoryDefaultArgs instead
     */
    export type TourCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelCategoryDefaultArgs instead
     */
    export type HotelCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TravelActivityDefaultArgs instead
     */
    export type TravelActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TravelActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TravelInterestDefaultArgs instead
     */
    export type TravelInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TravelInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlightRouteDefaultArgs instead
     */
    export type FlightRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlightRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccommodationTypeDefaultArgs instead
     */
    export type AccommodationTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccommodationTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DifficultyLevelDefaultArgs instead
     */
    export type DifficultyLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DifficultyLevelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonalPeriodDefaultArgs instead
     */
    export type SeasonalPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonalPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingActivityDefaultArgs instead
     */
    export type BookingActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserInterestDefaultArgs instead
     */
    export type UserInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomTourInterestDefaultArgs instead
     */
    export type CustomTourInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomTourInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlightBookingDefaultArgs instead
     */
    export type FlightBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlightBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourActivityJunctionDefaultArgs instead
     */
    export type TourActivityJunctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourActivityJunctionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterestDefaultArgs instead
     */
    export type InterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlightDefaultArgs instead
     */
    export type FlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourFestivalDefaultArgs instead
     */
    export type TourFestivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourFestivalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatSessionDefaultArgs instead
     */
    export type ChatSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMessageDefaultArgs instead
     */
    export type ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}